{"instruction": "", "input": "# This is the normalized code:\nstatic bool func1(struct type1 *var1, struct type2 *var2, const char *var3) {\n  if (var2->field1->field2 & var4) {\n    if (func2(\"RTSP/\", var3, 5)) return TRUE;\n    return FALSE;\n  }\n  return func3(var1, var3);\n}\n# What is the source code?\n", "output": "static bool checkprotoprefix(struct SessionHandle *data,\n                             struct connectdata *conn, const char *s) {\n#ifndef CURL_DISABLE_RTSP\n  if (conn->handler->protocol & CURLPROTO_RTSP) return checkrtspprefix(data, s);\n#else\n  (void)conn;\n#endif\n  return checkhttpprefix(data, s);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic type1 func1(type2 *var1, type3 *var2) {\n  type4 *var3;\n  int var4;\n  var4 = _dbus_string_get_length(var2);\n  if (!_dbus_string_append_byte(var2, 'a')) goto oom;\n  if (!_dbus_string_append(var2, \"{i\")) goto oom;\n  var3 = _dbus_list_get_first(&var1->field1);\n  if (var3->field2->field3) {\n    if (!var3->field2->field3(var3, var2)) goto oom;\n  } else {\n    if (!_dbus_string_append_byte(var2, var3->field2->field4)) goto oom;\n  }\n  if (!_dbus_string_append_byte(var2, '}')) goto oom;\n  return TRUE;\noom:\n  _dbus_string_set_length(var2, var4);\n  return FALSE;\n}\n# What is the source code?\n", "output": "static dbus_bool_t dict_build_signature(TestTypeNode *node, DBusString *str) {\n  TestTypeNodeContainer *container = (TestTypeNodeContainer *)node;\n  int orig_len;\n  orig_len = _dbus_string_get_length(str);\n  if (!_dbus_string_append_byte(str, DBUS_TYPE_ARRAY)) goto oom;\n  if (!_dbus_string_append(\n          str, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_INT32_AS_STRING))\n    goto oom;\n  if (!node_build_signature(_dbus_list_get_first(&container->children), str))\n    goto oom;\n  if (!_dbus_string_append_byte(str, DBUS_DICT_ENTRY_END_CHAR)) goto oom;\n  return TRUE;\noom:\n  _dbus_string_set_length(str, orig_len);\n  return FALSE;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nint compiler_addglobal(type1 *var1, type2 *var2, type3 *var3) {\n  int var4 = compiler_findglobal(var1, var3, NULL);\n  if (var4 == -1) {\n    var4 = program_addglobal(var1->field1, var3);\n    type3 *var5 = program_internsymbol(var1->field1, var3);\n    if (dictionary_insert(&var1->field2, var5, func1(var4))) {\n      debugannotation_setglobal(&var1->field1->field3, var4, var3);\n    }\n  }\n  return var4;\n}\n# What is the source code?\n", "output": "globalindx compiler_addglobal(compiler *c, syntaxtreenode *node, value symbol) {\n  globalindx indx = compiler_findglobal(c, symbol, false);\n  if (indx == GLOBAL_UNALLOCATED) {\n    indx = program_addglobal(c->out, symbol);\n    value key = program_internsymbol(c->out, symbol);\n    if (dictionary_insert(&c->globals, key, MORPHO_INTEGER(indx))) {\n      debugannotation_setglobal(&c->out->annotations, indx, symbol);\n    }\n  }\n  return indx;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic int func1(int var1, int var2, int var3) {\n  int var4 = 0;\n  int var5;\n  unsigned char *var6 = var7;\n  unsigned char *var8 = var9;\n  for (var5 = 0; var5 < var1 * var2; var5++) {\n    if (var6[var5] != var8[var5]) {\n      if (var6[var5] > var8[var5]) {\n        if (var6[var5] - var3 < var8[var5]) {\n          var6[var5] = var8[var5];\n        } else {\n          var6[var5] -= var3;\n        }\n      } else {\n        if (var6[var5] + var3 > var8[var5]) {\n          var6[var5] = var8[var5];\n        } else {\n          var6[var5] += var3;\n        }\n      }\n      var4 = 1;\n    }\n  }\n  return !var4;\n}\n# What is the source code?\n", "output": "int wipe_doColorXForm(int width, int height, int ticks) {\n  boolean changed;\n  pixel_t* w;\n  pixel_t* e;\n  int newval;\n  changed = false;\n  w = wipe_scr;\n  e = wipe_scr_end;\n  while (w != wipe_scr + width * height) {\n    if (*w != *e) {\n      if (*w > *e) {\n        newval = *w - ticks;\n        if (newval < *e)\n          *w = *e;\n        else\n          *w = newval;\n        changed = true;\n      } else if (*w < *e) {\n        newval = *w + ticks;\n        if (newval > *e)\n          *w = *e;\n        else\n          *w = newval;\n        changed = true;\n      }\n    }\n    w++;\n    e++;\n  }\n  return !changed;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nsize_t func1(const unsigned char *var1, const unsigned char *var2, size_t var3) {\n  size_t var4, var5;\n  var4 = (((size_t)var2) + 15) & ~15;\n  var5 = var4 - (size_t)var2;\n  if (var5 < var3) {\n    for (size_t var6 = 0; var6 < var5; var6++) {\n      unsigned char var7 = var2[var6];\n      if (var7 < 128 && (var1[var7 >> 3] & (1 << (var7 & 7)))) return var6;\n    }\n  } else {\n    var5 = var3;\n  }\n  size_t var8 = var3 - var5;\n  if (var8 >= 16) {\n    for (size_t var6 = 0; var6 < var8 / 16; var6++) {\n      unsigned char var9[16];\n      for (size_t var10 = 0; var10 < 16; var10++) {\n        unsigned char var7 = var2[var6 * 16 + var10];\n        var9[var10] = var7 < 128 ? var1[var7 >> 3] & (1 << (var7 & 7)) : 0;\n      }\n      for (size_t var10 = 0; var10 < 16; var10++) {\n        if (var9[var10] == 0) continue;\n        unsigned char var7 = var2[var6 * 16 + var10];\n        if (var7 < 128) return var6 * 16 + var10;\n      }\n    }\n    var5 = var8 & ~15;\n  }\n  for (size_t var6 = var5; var6 < var3; var6++) {\n    unsigned char var7 = var2[var6];\n    if (var7 < 128 && (var1[var7 >> 3] & (1 << (var7 & 7)))) return var6;\n  }\n  return var3;\n}\n# What is the source code?\n", "output": "size_t find_FildeshMascii(const FildeshMascii* mascii, const char* s,\n                          size_t n) {\n  size_t i;\n  const FildeshMascii* t =\n      (const FildeshMascii*)(((uintptr_t)s + 15) & ~(uintptr_t)15);\n  const size_t t_offset =\n      ((uintptr_t)t - (uintptr_t)s >= n ? n : (uintptr_t)t - (uintptr_t)s);\n  const size_t t_count = ((n - t_offset) / 16);\n  for (i = 0; i < t_offset; ++i) {\n    if (get_FildeshMascii(mascii, (unsigned char)s[i])) {\n      return i;\n    }\n  }\n  for (i = 0; i < t_count; ++i) {\n    unsigned idx = get16_FildeshMascii(*mascii, t[i]);\n    if (idx < 16) {\n      return t_offset + 16 * i + (size_t)idx;\n    }\n  }\n  for (i = t_offset + 16 * t_count; i < n; ++i) {\n    if (get_FildeshMascii(mascii, (unsigned char)s[i])) {\n      return i;\n    }\n  }\n  return n;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic const char* func1(unsigned short var1) {\n  switch (var1 & 0x0110) {\n    case 0x0000:\n      return \"Request\";\n    case 0x0100:\n      return \"Success Response\";\n    case 0x0110:\n      return \"Error Response\";\n    case 0x0010:\n      return \"Indication\";\n    default:\n      return \"???\";\n  }\n}\n# What is the source code?\n", "output": "const char *stun_class_name(uint16_t type) {\n  if (STUN_IS_REQUEST(type))\n    return \"Request\";\n  else if (STUN_IS_SUCCESS_RESPONSE(type))\n    return \"Success Response\";\n  else if (STUN_IS_ERROR_RESPONSE(type))\n    return \"Error Response\";\n  else if (STUN_IS_INDICATION(type))\n    return \"Indication\";\n  else\n    return \"???\";\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nvoid func_timer_use(type1 *var1, type1 *var2, type1 *var3) {\n  if (!var1 || !var3) {\n    return;\n  }\n  var1->field1 = var3;\n  if (var1->field2) {\n    var1->field2 = 0;\n    return;\n  }\n  if (var1->field3) {\n    var1->field2 = var4.field4 + var1->field3;\n    return;\n  }\n  func1(var1);\n}\n# What is the source code?\n", "output": "void func_timer_use(edict_t *self, edict_t *other, edict_t *activator) {\n  if (!self || !activator) {\n    return;\n  }\n  self->activator = activator;\n  if (self->nextthink) {\n    self->nextthink = 0;\n    return;\n  }\n  if (self->delay)\n    self->nextthink = level.time + self->delay;\n  else\n    func_timer_think(self);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic int func1(const char *var1, const char *var2, const char **var3) {\n  int var4 = 0;\n  size_t var5;\n  int var6;\n  log_debug(\"Check %s/%s against %s(%d)\", var1, var2, *var3, func2(*var3));\n  var5 = func2(*var3);\n  if (var5) {\n    if (var5 == 1 && **var3 == '*') {\n      (*var3)++;\n      var4 = 1;\n    } else {\n      var6 = func3(var1, *var3, var5);\n      *var3 += var5;\n      if (var6) var4 = 1;\n    }\n  }\n  if (**var3 == '/') {\n    (*var3)++;\n    var5 = func2(*var3);\n    if (var5) {\n      if (var5 == 1 && **var3 == '*')\n        var6 = 1;\n      else\n        var6 = func3(var2, *var3, var5);\n    } else\n      var6 = 0;\n    *var3 += var5;\n    var4 &= var6;\n  }\n  log_debug(\"%satch!\", var4 ? \"M\" : \"No m\");\n  return var4;\n}\n# What is the source code?\n", "output": "int _runCommand(const char *origCommand, const abl_info *info,\n                int(execFun)(char *const arg[])) {\n  int err = 0;\n  int bufSize = 0;\n  int argNum = 0;\n  char **result = NULL;\n  char **substResult = NULL;\n  char *command = NULL;\n  if (!origCommand || !*origCommand) return 0;\n  command = strdup(origCommand);\n  if (!command) return 1;\n  argNum = splitCommand(command, NULL);\n  if (argNum == 0) goto cleanup;\n  if (argNum < 0) {\n    err = 1;\n    goto cleanup;\n  }\n  result = malloc((argNum + 1) * sizeof(char *));\n  substResult = malloc((argNum + 1) * sizeof(char *));\n  memset(result, 0, (argNum + 1) * sizeof(char *));\n  memset(substResult, 0, (argNum + 1) * sizeof(char *));\n  argNum = splitCommand(command, result);\n  int partIndex = 0;\n  while (result[partIndex]) {\n    bufSize = prepare_string(result[partIndex], info, NULL);\n    if (bufSize <= 0) {\n      log_warning(\"failed to substitute %s.\", result[partIndex]);\n      err = 1;\n      goto cleanup;\n    }\n    if (bufSize > COMMAND_SIZE) {\n      log_warning(\"command length error.\");\n      goto cleanup;\n    }\n    substResult[partIndex] = malloc(bufSize * sizeof(char));\n    if (substResult[partIndex] == NULL) {\n      err = 1;\n      goto cleanup;\n    }\n    bufSize = prepare_string(result[partIndex], info, substResult[partIndex]);\n    ++partIndex;\n  }\n  err = execFun(substResult);\ncleanup:\n  if (result) {\n    free(result);\n  }\n  if (substResult) {\n    partIndex = 0;\n    while (substResult[partIndex]) {\n      free(substResult[partIndex]);\n      ++partIndex;\n    }\n    free(substResult);\n  }\n  if (command) free(command);\n  return err;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\ntype1 eb_open_narrow_font_file(type2 *var1, int var2) {\n  type3 *var3;\n  char var4[var5];\n  int var6;\n  int var7;\n  func1((\"in: eb_open_narrow_font(book=%d, font_code=%d)\", (int)var1->field1,\n         var2));\n  var3 = var1->field2 + var2;\n  if (var3->field3 == -1) goto failed;\n  if (zio_file(var3->field4) >= 0) goto succeeded;\n  var6 = -1;\n  if (var1->field5 == var8) {\n    if (var3->field6) {\n      if (zio_mode(var3->field4) != -1) var6 = var9;\n    } else {\n      var6 = zio_mode(var3->field7);\n    }\n    eb_compose_path_name2(var1->field8, var3->field9, var3->field10, var4);\n  } else {\n    if (var3->field6) {\n      if (zio_mode(var3->field4) != -1) var6 = var9;\n      eb_compose_path_name3(var1->field8, var3->field9, var3->field10,\n                            var3->field11, var4);\n    } else {\n      eb_canonicalize_file_name(var3->field11);\n      if (eb_find_file_name3(var1->field8, var3->field9, var3->field10,\n                             var3->field11, var3->field11) != var10)\n        goto failed;\n      eb_compose_path_name3(var1->field8, var3->field9, var3->field10,\n                            var3->field11, var4);\n      eb_path_name_zio_code(var4, var11, &var6);\n    }\n  }\n  if (var6 != -1) {\n    var7 = zio_open(var3->field4, var4, var6);\n    if (var7 < 0) goto failed;\n  }\nsucceeded:\n  func1((\"out: eb_open_narrow_font_file(file=%d) = %s\", zio_file(var3->field4),\n         eb_error_string(var10)));\n  return var10;\nfailed:\n  func1((\"out: eb_open_narrow_font_file() = %s\", eb_error_string(var12)));\n  return var12;\n}\n# What is the source code?\n", "output": "EB_Error_Code eb_open_narrow_font_file(EB_Book *book, EB_Font_Code font_code) {\n  EB_Error_Code error_code;\n  EB_Subbook *subbook;\n  EB_Font *narrow_font;\n  char font_path_name[EB_MAX_PATH_LENGTH + 1];\n  Zio_Code zio_code;\n  LOG((\"in: eb_open_narrow_font(book=%d, font_code=%d)\", (int)book->code,\n       (int)font_code));\n  subbook = book->subbook_current;\n  narrow_font = subbook->narrow_fonts + font_code;\n  if (narrow_font->font_code == EB_FONT_INVALID) {\n    error_code = EB_ERR_FAIL_OPEN_FONT;\n    goto failed;\n  }\n  if (0 <= zio_file(&narrow_font->zio)) goto succeeded;\n  zio_code = ZIO_INVALID;\n  if (book->disc_code == EB_DISC_EB) {\n    if (narrow_font->initialized) {\n      if (zio_mode(&narrow_font->zio) != ZIO_INVALID) zio_code = ZIO_REOPEN;\n    } else {\n      zio_code = zio_mode(&subbook->text_zio);\n    }\n    eb_compose_path_name2(book->path, subbook->directory_name,\n                          subbook->text_file_name, font_path_name);\n  } else {\n    if (narrow_font->initialized) {\n      if (zio_mode(&narrow_font->zio) != ZIO_INVALID) zio_code = ZIO_REOPEN;\n      eb_compose_path_name3(book->path, subbook->directory_name,\n                            subbook->gaiji_directory_name,\n                            narrow_font->file_name, font_path_name);\n    } else {\n      eb_canonicalize_file_name(narrow_font->file_name);\n      if (eb_find_file_name3(book->path, subbook->directory_name,\n                             subbook->gaiji_directory_name,\n                             narrow_font->file_name,\n                             narrow_font->file_name) != EB_SUCCESS) {\n        error_code = EB_ERR_FAIL_OPEN_FONT;\n        goto failed;\n      }\n      eb_compose_path_name3(book->path, subbook->directory_name,\n                            subbook->gaiji_directory_name,\n                            narrow_font->file_name, font_path_name);\n      eb_path_name_zio_code(font_path_name, ZIO_PLAIN, &zio_code);\n    }\n  }\n  if (zio_code != ZIO_INVALID &&\n      zio_open(&narrow_font->zio, font_path_name, zio_code) < 0) {\n    error_code = EB_ERR_FAIL_OPEN_FONT;\n    goto failed;\n  }\nsucceeded:\n  LOG((\"out: eb_open_narrow_font_file(file=%d) = %s\",\n       zio_file(&narrow_font->zio), eb_error_string(EB_SUCCESS)));\n  return EB_SUCCESS;\nfailed:\n  LOG((\"out: eb_open_narrow_font_file() = %s\", eb_error_string(error_code)));\n  return error_code;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic int func1(type1* var1) {\n  int var2, var3;\n  type2* var4;\n  assert(!func2(var1));\n  var2 = *var1->field1;\n  assert(!func3(var1, var2));\n  func4(4, var2, \"popped\");\n  var4 = func5(var1, var2);\n  assert(!var4->field2);\n  var4->field2 = -1;\n  var3 = func6(var1);\n  if (var3) {\n    var4 = func5(var1, var3);\n    assert(var4->field2 == var3);\n    var4->field2 = 0;\n    *var1->field1 = var3;\n    func7(var1, var3);\n  } else\n    assert(var2 == var3);\n  return var2;\n}\n# What is the source code?\n", "output": "static int lglpopesched(LGL* lgl) {\n  Stk* s = &lgl->esched;\n  int res, last, cnt, *p;\n  EVar* ev;\n  assert(!lglmtstk(s));\n  res = *s->start;\n  assert(!lglifrozen(lgl, res));\n  LOGESCHED(4, res, \"popped\");\n  ev = lglevar(lgl, res);\n  assert(!ev->pos);\n  ev->pos = -1;\n  last = lglpopstk(s);\n  cnt = lglcntstk(s);\n  if (!cnt) {\n    assert(last == res);\n    return res;\n  }\n  p = lglepos(lgl, last);\n  assert(*p == cnt);\n  *p = 0;\n  *s->start = last;\n  lgledown(lgl, last);\n  return res;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nssize_t func1(const type1 *var1, char *var2, size_t var3) {\n  size_t var4;\n  ssize_t var5 = -1;\n  type2 assert(type3 != NULL);\n  if (NULL == var1->field1)\n    func2(var6, var7, var8, \"no filename available for that reference\");\n  var4 = strlen(var1->field1);\n  assert(var4 <= var9);\n  if (var2) {\n    var4 = func3(var4, var3 - 1);\n    func4(var2, var1->field1, var4);\n    var2[var4] = '\\0';\n  }\n  var5 = (ssize_t)var4 + 1;\nvar10:\n  var11(type4)\n}\n# What is the source code?\n", "output": "ssize_t H5R__get_file_name(const H5R_ref_priv_t *ref, char *buf, size_t size) {\n  size_t copy_len;\n  ssize_t ret_value = -1;\n  FUNC_ENTER_PACKAGE\n  assert(ref != NULL);\n  if (!ref->info.obj.filename)\n    HGOTO_ERROR(H5E_REFERENCE, H5E_ARGS, (-1),\n                \"no filename available for that reference\");\n  copy_len = strlen(ref->info.obj.filename);\n  assert(copy_len <= H5R_MAX_STRING_LEN);\n  if (buf) {\n    copy_len = MIN(copy_len, size - 1);\n    H5MM_memcpy(buf, ref->info.obj.filename, copy_len);\n    buf[copy_len] = '\\0';\n  }\n  ret_value = (ssize_t)(copy_len + 1);\ndone:\n  FUNC_LEAVE_NOAPI(ret_value)\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic void func1(type1 *var1, type2 *var2) {\n  static int var3 = 0;\n  static char *var4[10];\n  int var5 = var1->field1 == var1->field2;\n  if (!var3) {\n    var4[0] = func2(\"_Undo\");\n    var4[2] = func2(\"Cu_t\");\n    var4[4] = func2(\"_Copy\");\n    var4[5] = func2(\"_Paste\");\n    var4[7] = func2(\"_Save in UTF8\");\n    var4[8] = func2(\"Save in _UCS2\");\n    var4[9] = func2(\"_Import\");\n    var3 = true;\n  }\n  var4[1] = var1->field3 == NULL ? \"F\" : \"\";\n  var4[3] = var5 ? \"T\" : \"\";\n  var4[5] = var5 ? \"T\" : \"\";\n  var4[6] = func3(var1->field4, true, \"text/plain;charset=ISO-10646-UCS-2\") ||\n                    func3(var1->field4, true, \"UTF8_STRING\") ||\n                    func3(var1->field4, true, \"STRING\")\n                ? \"\"\n                : \"T\";\n  var6 = var1;\n  func4(var1->field4, var2, var4);\n}\n# What is the source code?\n", "output": "static void GTFPopupMenu(GTextField *gt, GEvent *event) {\n  int no_sel = gt->sel_start == gt->sel_end;\n  if (first) {\n    gtf_popuplist[0].ti.text = (unichar_t *)_(\"_Undo\");\n    gtf_popuplist[2].ti.text = (unichar_t *)_(\"Cu_t\");\n    gtf_popuplist[3].ti.text = (unichar_t *)_(\"_Copy\");\n    gtf_popuplist[4].ti.text = (unichar_t *)_(\"_Paste\");\n    gtf_popuplist[6].ti.text = (unichar_t *)_(\"_Save in UTF8\");\n    gtf_popuplist[7].ti.text = (unichar_t *)_(\"Save in _UCS2\");\n    gtf_popuplist[8].ti.text = (unichar_t *)_(\"_Import\");\n    first = false;\n  }\n  gtf_popuplist[0].ti.disabled = gt->oldtext == NULL;\n  gtf_popuplist[2].ti.disabled = no_sel;\n  gtf_popuplist[3].ti.disabled = no_sel;\n  gtf_popuplist[4].ti.disabled =\n      !GDrawSelectionHasType(gt->g.base, sn_clipboard,\n                             \"text/plain;charset=ISO-10646-UCS-2\") &&\n      !GDrawSelectionHasType(gt->g.base, sn_clipboard, \"UTF8_STRING\") &&\n      !GDrawSelectionHasType(gt->g.base, sn_clipboard, \"STRING\");\n  popup_kludge = gt;\n  GMenuCreatePopupMenu(gt->g.base, event, gtf_popuplist);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic void func1(type1 *var1) {\n  type2 *var2;\n  int var3;\n  func2(var1->field1, var2, var3) func3(var2);\n  func4(&var1->field1);\n  func5(var1->field2);\n  func5(var1);\n}\n# What is the source code?\n", "output": "static inline void Abc_SclCellFree(SC_Cell* p) {\n  SC_Pin* pTemp;\n  int i;\n  SC_CellForEachPin(p, pTemp, i) Abc_SclPinFree(pTemp);\n  Vec_PtrErase(&p->vPins);\n  ABC_FREE(p->pName);\n  ABC_FREE(p);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic int func1(const struct type1 *var1, const struct type2 *var2) {\n  const struct type3 *var3 = func2(var1, var4 var5, var1);\n  if (!func3(var3->field1, var2->field2) || var2->field3 != var3->field4)\n    return 0;\n  func4(\" using listen skt from vhost %s\\n\", var3->field1->field5);\n  return 1;\n}\n# What is the source code?\n", "output": "static int check_extant(struct lws_dll2 *d, void *user) {\n  struct lws *wsi = lws_container_of(d, struct lws, listen_list);\n  struct vh_sock_args *a = (struct vh_sock_args *)user;\n  if (!lws_vhost_compare_listen(wsi->a.vhost, a->vhost)) return 0;\n  if (wsi->af != a->af) return 0;\n  lwsl_notice(\" using listen skt from vhost %s\\n\", wsi->a.vhost->name);\n  return 1;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nstatic void func1(struct type1 *var1, void *var2) {\n  struct type2 *var3, *var4;\n  var3 = bufferevent_socket_new(var5, (intptr_t)var2, var6);\n  if (var7 && var8) {\n    type3 *var9 = SSL_new(var7);\n    var4 = bufferevent_openssl_socket_new(var5, -1, var9, var10, var6);\n  } else {\n    var4 = bufferevent_socket_new(var5, -1, var6);\n  }\n  if (bufferevent_socket_connect(var4, (struct type4 *)&var11, var12) < 0) {\n    perror(\"bufferevent_socket_connect\");\n    bufferevent_free(var4);\n    bufferevent_free(var3);\n    return;\n  }\n  if (var7 && !var8) {\n    type3 *var9 = SSL_new(var7);\n    struct type2 *var13 =\n        bufferevent_openssl_filter_new(var5, var4, var9, var10, var6);\n    if (!var13) {\n      perror(\"Bufferevent_openssl_new\");\n      bufferevent_free(var4);\n      bufferevent_free(var3);\n      return;\n    }\n    var4 = var13;\n  }\n  bufferevent_setcb(var3, var14, NULL, var15, var4);\n  bufferevent_setcb(var4, var14, NULL, var15, var3);\n  bufferevent_enable(var3, var16);\n  bufferevent_enable(var4, var16);\n}\n# What is the source code?\n", "output": "static void accept_cb(struct evconnlistener *listener, evutil_socket_t fd,\n                      struct sockaddr *a, int slen, void *p) {\n  struct bufferevent *b_out, *b_in;\n  b_in = bufferevent_socket_new(\n      base, fd, BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);\n  if (!ssl_ctx || use_wrapper)\n    b_out = bufferevent_socket_new(\n        base, -1, BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);\n  else {\n    SSL *ssl = SSL_new(ssl_ctx);\n    b_out = bufferevent_openssl_socket_new(\n        base, -1, ssl, BUFFEREVENT_SSL_CONNECTING,\n        BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);\n  }\n  assert(b_in && b_out);\n  if (bufferevent_socket_connect(b_out, (struct sockaddr *)&connect_to_addr,\n                                 connect_to_addrlen) < 0) {\n    perror(\"bufferevent_socket_connect\");\n    bufferevent_free(b_out);\n    bufferevent_free(b_in);\n    return;\n  }\n  if (ssl_ctx && use_wrapper) {\n    struct bufferevent *b_ssl;\n    SSL *ssl = SSL_new(ssl_ctx);\n    b_ssl = bufferevent_openssl_filter_new(\n        base, b_out, ssl, BUFFEREVENT_SSL_CONNECTING,\n        BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);\n    if (!b_ssl) {\n      perror(\"Bufferevent_openssl_new\");\n      bufferevent_free(b_out);\n      bufferevent_free(b_in);\n      return;\n    }\n    b_out = b_ssl;\n  }\n  bufferevent_setcb(b_in, readcb, NULL, eventcb, b_out);\n  bufferevent_setcb(b_out, readcb, NULL, eventcb, b_in);\n  bufferevent_enable(b_in, EV_READ | EV_WRITE);\n  bufferevent_enable(b_out, EV_READ | EV_WRITE);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nint fluid_synth_get_cc(type1 *var1, int var2, int var3, int *var4) {\n  int var5 = var6;\n  func1(var3 >= 0 && var3 <= 127, var5);\n  func2(var4);\n  func3(var5);\n}\n# What is the source code?\n", "output": "int fluid_synth_get_cc(fluid_synth_t *synth, int chan, int num, int *pval) {\n  fluid_return_val_if_fail(num >= 0 && num < 128, FLUID_FAILED);\n  fluid_return_val_if_fail(pval != NULL, FLUID_FAILED);\n  FLUID_API_ENTRY_CHAN(FLUID_FAILED);\n  FLUID_API_RETURN_IF_CHAN_DISABLED(FLUID_FAILED);\n  *pval = fluid_channel_get_cc(synth->channel[chan], num);\n  FLUID_API_RETURN(FLUID_OK);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nvoid func1() {\n  type1 *var1 = NULL;\n  func2(&var1, 5);\n  assert(func3(var1) == 1);\n  func2(&var1, 8);\n  func2(&var1, 12);\n  assert(func3(var1) == 3);\n  func4(var1);\n}\n# What is the source code?\n", "output": "void test_push_front() {\n  node_t *head = NULL;\n  push_front(&head, 5);\n  assert(size(head) == 1);\n  push_front(&head, 8);\n  push_front(&head, 12);\n  assert(size(head) == 3);\n  destroy_list(head);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nvoid test_astronode_request_perf_counters_r(void) {\n  uint8_t var1[14] = {0};\n  uint8_t var2[14] = {0};\n  var3 = var4;\n  int var5 = astronode_request_perf_counters_r(var2);\n  func1(1, var6.field1);\n  func1(0, var5);\n  func1(0xE7, var2[0]);\n  func1(0xF1, var2[1]);\n  func1(0xF2, var2[2]);\n  func1(0xF3, var2[3]);\n  func1(0xF4, var2[4]);\n  func1(0xF5, var2[5]);\n  func1(0xF6, var2[6]);\n  func1(0xF7, var2[7]);\n  func1(0xF8, var2[8]);\n  func1(0xF9, var2[9]);\n  func1(0xFA, var2[10]);\n  func1(0xFB, var2[11]);\n  func1(0xFC, var2[12]);\n  func1(0xFD, var2[13]);\n}\n# What is the source code?\n", "output": "void test_astronode_request_perf_counters_r(void) {\n  perf_counters_r_response_t ans = {0};\n  astronode_transport_send_receive_fake.custom_fake =\n      astronode_transport_send_receive_custom_fake_perf_counters_r;\n  as_return_status_t ret_status = astronode_request_perf_counters_r(&ans);\n  TEST_ASSERT_EQUAL(1, astronode_transport_send_receive_fake.call_count);\n  TEST_ASSERT_EQUAL(RS_ASSET_SUCCESS, ret_status);\n  TEST_ASSERT_EQUAL(ASTRONODE_OP_CODE_PER_RA, ans.data.opcode);\n  TEST_ASSERT_EQUAL(0xF1, ans.data.sat_search_phase);\n  TEST_ASSERT_EQUAL(0xF2, ans.data.sat_search_try);\n  TEST_ASSERT_EQUAL(0xF3, ans.data.sat_demod_phase);\n  TEST_ASSERT_EQUAL(0xF4, ans.data.sat_demod_try);\n  TEST_ASSERT_EQUAL(0xF5, ans.data.valid_sat_demod);\n  TEST_ASSERT_EQUAL(0xF6, ans.data.ack_demod_try);\n  TEST_ASSERT_EQUAL(0xF7, ans.data.valid_ack_demod);\n  TEST_ASSERT_EQUAL(0xF8, ans.data.msg_queued);\n  TEST_ASSERT_EQUAL(0xF9, ans.data.msg_dequeued);\n  TEST_ASSERT_EQUAL(0xFA, ans.data.msg_ack);\n  TEST_ASSERT_EQUAL(0xFB, ans.data.fragment_tx);\n  TEST_ASSERT_EQUAL(0xFC, ans.data.fragment_ack);\n  TEST_ASSERT_EQUAL(0xFD, ans.data.unicast_demod_try);\n  TEST_ASSERT_EQUAL(0xFE, ans.data.valid_unicast_demod);\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\nint Str_ManVectorAffinity(type1* var1, type2* var2, type2* var3, type3* var4,\n                          int var5) {\n  int var6, var7, var8, var9, var10, var11, var12[64];\n  var10 = func1(var2);\n  assert(var10 > 2);\n  if (var10 > 64) {\n    memset(var4, 0, 64 * sizeof(var13));\n    return 0;\n  }\n  Gia_ManIncrementTravId(var1);\n  func2(var2, var6, var7) {\n    func3(var1, var6);\n    func4(var1, var6, var7);\n    var4[var7] = 1ULL << (var7);\n    var12[var7] = 0;\n  }\n  for (var9 = 1; var9 < 8; var9++) {\n    func2(var2, var6, var7) {\n      func5(var1, var6, var8, var11) {\n        if (func6(var1, var8)) continue;\n        if (var5 == func1(var2)) continue;\n        func3(var1, var8);\n        var4[func1(var2)] = 0;\n        var12[func1(var2)] = var9;\n        func4(var1, var8, func1(var2));\n        var4[func4(var1, var8, var7)] |= var4[var7];\n      }\n      if (func7(var1, var6)) var4[func4(var1, var6, var7)] |= var4[var7];\n    }\n  }\n  var11 = 0;\n  func2(var2, var6, var7) {\n    assert(var4[var7]);\n    if (var4[var7] == (1ULL << (var10 - 1))) continue;\n    var4[var11] = var4[var7];\n    var12[var11] = var12[var7];\n    if (++var11 == 64) break;\n  }\n  for (var7 = var11; var7 < 64; var7++) var4[var7] = 0;\n  func8(var4, 64);\n  if (func1(var2) > var10) func9(var2, var10);\n  return var11;\n}\n# What is the source code?\n", "output": "int Str_ManVectorAffinity(Gia_Man_t* p, Vec_Int_t* vSuper, Vec_Int_t* vDelay,\n                          word Matrix[256], int nLimit) {\n  int fVerbose = 0;\n  int Levels[256];\n  int nSize = Vec_IntSize(vSuper);\n  int Prev = nSize, nLevels = 1;\n  int i, k, iLit, iFanin, nSizeNew;\n  word Mask;\n  assert(nSize > 2);\n  if (nSize > 64) {\n    for (i = 0; i < 64; i++) Matrix[i] = 0;\n    return 0;\n  }\n  Gia_ManIncrementTravId(p);\n  Vec_IntForEachEntry(vSuper, iLit, i) {\n    Gia_ObjSetTravIdCurrentId(p, Abc_Lit2Var(iLit));\n    Str_ManSetNum(p, Abc_Lit2Var(iLit), i);\n    Matrix[i] = ((word)1) << (63 - i);\n    Levels[i] = 0;\n  }\n  Vec_IntForEachEntry(vSuper, iLit, i) {\n    Gia_Obj_t* pObj = Gia_ManObj(p, Abc_Lit2Var(iLit));\n    if (Gia_ObjIsAnd(pObj)) {\n      for (k = 0; k < 2; k++) {\n        iFanin = k ? Gia_ObjFaninId1p(p, pObj) : Gia_ObjFaninId0p(p, pObj);\n        if (!Gia_ObjIsTravIdCurrentId(p, iFanin)) {\n          if (Vec_IntSize(vSuper) == nLimit) break;\n          Gia_ObjSetTravIdCurrentId(p, iFanin);\n          Matrix[Vec_IntSize(vSuper)] = 0;\n          Levels[Vec_IntSize(vSuper)] = nLevels;\n          Str_ManSetNum(p, iFanin, Vec_IntSize(vSuper));\n          Vec_IntPush(vSuper, Abc_Var2Lit(iFanin, 0));\n        }\n        Matrix[Str_ManNum(p, iFanin)] |= Matrix[i];\n      }\n    }\n    if (Gia_ObjIsMux(p, pObj)) {\n      iFanin = Gia_ObjFaninId2p(p, pObj);\n      if (!Gia_ObjIsTravIdCurrentId(p, iFanin)) {\n        if (Vec_IntSize(vSuper) == nLimit) break;\n        Gia_ObjSetTravIdCurrentId(p, iFanin);\n        Matrix[Vec_IntSize(vSuper)] = 0;\n        Levels[Vec_IntSize(vSuper)] = nLevels;\n        Str_ManSetNum(p, iFanin, Vec_IntSize(vSuper));\n        Vec_IntPush(vSuper, Abc_Var2Lit(iFanin, 0));\n      }\n      Matrix[Str_ManNum(p, iFanin)] |= Matrix[i];\n    }\n    if (Prev == i) Prev = Vec_IntSize(vSuper), nLevels++;\n    if (nLevels == 8) break;\n  }\n  Mask = (~(word)0) << (64 - nSize);\n  for (k = i = 0; i < Vec_IntSize(vSuper); i++) {\n    assert(Matrix[i]);\n    if ((Matrix[i] & (Matrix[i] - 1)) == 0) continue;\n    if (Matrix[i] == Mask) continue;\n    Matrix[k] = Matrix[i];\n    Levels[k] = Levels[i];\n    k++;\n    if (k == 64) break;\n  }\n  for (i = k; i < 64; i++) Matrix[i] = 0;\n  nSizeNew = k;\n  if (nSizeNew == 0) {\n    Vec_IntShrink(vSuper, nSize);\n    return 0;\n  }\n  transpose64(Matrix);\n  if (fVerbose && nSize > 10) {\n    printf(\n        \"Gate inputs = %d.  Collected fanins = %d.  All = %d.  Good = %d.  \"\n        \"Levels = %d\\n\",\n        nSize, Vec_IntSize(vSuper) - nSize, Vec_IntSize(vSuper), nSizeNew,\n        nLevels);\n    printf(\"                     \");\n    for (i = 0; i < nSizeNew; i++) printf(\"%d\", Levels[i]);\n    printf(\"\\n\");\n    for (i = 0; i < nSize; i++) {\n      printf(\"%6d : \", Abc_Lit2Var(Vec_IntEntry(vSuper, i)));\n      printf(\"%3d   \", Vec_IntEntry(vDelay, i) >> 4);\n      printf(\"%3d   \", Vec_IntEntry(vDelay, i) & 15);\n    }\n    i = 0;\n  }\n  Vec_IntShrink(vSuper, nSize);\n  return nSizeNew;\n}", "system": ""}
{"instruction": "", "input": "# This is the normalized code:\ntype1 xmlAddPrevSibling(type1 var1, type1 var2) {\n  if ((var1 == NULL) || (var1->field1 == var3)) {\n    return (NULL);\n  }\n  if ((var2 == NULL) || (var2->field1 == var3)) {\n    return (NULL);\n  }\n  if (var1 == var2) {\n    return (NULL);\n  }\n  xmlUnlinkNode(var2);\n  if (var2->field1 == var4) {\n    return (func1(var1->field2, var1, var2));\n  }\n  if (var2->field1 == var5) {\n    if (var1->field1 == var5) {\n      type2 *var6;\n      var6 = xmlStrcat(func2(var2->field3), var1->field3);\n      xmlNodeSetContent(var1, var6);\n      xmlFree(var6);\n      xmlFreeNode(var2);\n      return (var1);\n    }\n    if ((var1->field2 != NULL) && (var1->field2->field1 == var5) &&\n        (var1->field4 == var1->field2->field4)) {\n      xmlNodeAddContent(var1->field2, var2->field3);\n      xmlFreeNode(var2);\n      return (var1->field2);\n    }\n  }\n  if (var2->field5 != var1->field5) {\n    xmlSetTreeDoc(var2, var1->field5);\n  }\n  var2->field6 = var1->field6;\n  var2->field7 = var1;\n  var2->field2 = var1->field2;\n  var1->field2 = var2;\n  if (var2->field2 != NULL) {\n    var2->field2->field7 = var2;\n  }\n  if ((var2->field6 != NULL) && (var2->field6->field8 == var1)) {\n    var2->field6->field8 = var2;\n  }\n  return (var2);\n}\n# What is the source code?\n", "output": "xmlNodePtr xmlAddPrevSibling(xmlNodePtr cur, xmlNodePtr elem) {\n  if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {\n#ifdef DEBUG_TREE\n    xmlGenericError(xmlGenericErrorContext,\n                    \"xmlAddPrevSibling : cur == NULL\\n\");\n#endif\n    return (NULL);\n  }\n  if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {\n#ifdef DEBUG_TREE\n    xmlGenericError(xmlGenericErrorContext,\n                    \"xmlAddPrevSibling : elem == NULL\\n\");\n#endif\n    return (NULL);\n  }\n  if (cur == elem) {\n#ifdef DEBUG_TREE\n    xmlGenericError(xmlGenericErrorContext,\n                    \"xmlAddPrevSibling : cur == elem\\n\");\n#endif\n    return (NULL);\n  }\n  xmlUnlinkNode(elem);\n  if (elem->type == XML_TEXT_NODE) {\n    if (cur->type == XML_TEXT_NODE) {\n      xmlChar *tmp;\n      tmp = xmlStrdup(elem->content);\n      tmp = xmlStrcat(tmp, cur->content);\n      xmlNodeSetContent(cur, tmp);\n      xmlFree(tmp);\n      xmlFreeNode(elem);\n      return (cur);\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_TEXT_NODE) &&\n        (cur->name == cur->prev->name)) {\n      xmlNodeAddContent(cur->prev, elem->content);\n      xmlFreeNode(elem);\n      return (cur->prev);\n    }\n  } else if (elem->type == XML_ATTRIBUTE_NODE) {\n    return xmlAddPropSibling(cur->prev, cur, elem);\n  }\n  if (elem->doc != cur->doc) {\n    xmlSetTreeDoc(elem, cur->doc);\n  }\n  elem->parent = cur->parent;\n  elem->next = cur;\n  elem->prev = cur->prev;\n  cur->prev = elem;\n  if (elem->prev != NULL) elem->prev->next = elem;\n  if ((elem->parent != NULL) && (elem->parent->children == cur)) {\n    elem->parent->children = elem;\n  }\n  return (elem);\n}", "system": ""}
