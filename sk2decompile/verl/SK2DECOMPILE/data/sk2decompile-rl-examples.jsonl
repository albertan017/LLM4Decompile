{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long Verifie_Ligne_Produit(long long a1, const char *a2, int a3) {\n  int v4;\n  int v5;\n  char *v6;\n  int v7;\n  int v8;\n  __m128 v9;\n  char *dest;\n  int v12;\n  int v13;\n  int v14;\n  char s[256];\n  char src[264];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  if (a2[(int)strlen(a2) - 1] == 10 || (int)strlen(a2) <= 254) {\n    if (sscanf(a2, \"%d\\t%s\\t%s\\t%f\", &v13, s, src, &v14) == 4) {\n      v4 = v13;\n      if (v13 < 0) {\n        v4 = -1;\n        printf(\"La ligne %d est contient un no de produit invalide (< 0).\\n\",\n               a3 + 1);\n      } else {\n        v12 = v14;\n        v5 = strlen(s);\n        v6 = (char *)malloc((unsigned int)(v5 + 1));\n        v7 = strlen(src);\n        dest = (char *)malloc((unsigned int)(v7 + 1));\n        strcpy(v6, s);\n        strcpy(dest, src);\n      }\n    } else {\n      v4 = -1;\n      printf(\"Le format de la ligne %d est incorrect.\\n\", a3 + 1);\n    }\n  } else {\n    v4 = -1;\n    printf(\"Nombre de caracteres trop grand sur la ligne %d.\\n\", a3 + 1);\n  }\n  v8 = v12;\n  *(uint32_t *)a1 = v4;\n  v9 = _mm_loadh_ps((const double *)&dest);\n  *(uint32_t *)(a1 + 4) = v8;\n  *(__m128 *)(a1 + 8) = v9;\n  return a1;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 Verifie_Ligne_Produit(char var1[], int var2) {\n  int var3, var4, var5;\n  float var6;\n  char var7[255], var8[255];\n  type1 var9;\n  var4 = 0;\n  if (var1[strlen(var1) - 1] != '\\n' && strlen(var1) >= 255) {\n    printf(\"Nombre de caracteres trop grand sur la ligne %d.\\n\", var2 + 1);\n    var4 = 1;\n  } else {\n    var3 = sscanf(var1, \"%d\\t%s\\t%s\\t%f\", &var5, var7, var8, &var6);\n    if (var3 != 4) {\n      printf(\"Le format de la ligne %d est incorrect.\\n\", var2 + 1);\n      var4 = 1;\n    } else {\n      if (var5 < 0) {\n        printf(\"La ligne %d est contient un no de produit invalide (< 0).\\n\",\n               var2 + 1);\n        var4 = 1;\n      } else {\n        var9.field1 = var5;\n        var9.field2 = var6;\n        var9.field3 = (char *)malloc(strlen(var7) * sizeof(char) + 1);\n        var9.field4 = (char *)malloc(strlen(var8) * sizeof(char) + 1);\n        strcpy(var9.field3, var7);\n        strcpy(var9.field4, var8);\n      }\n    }\n  }\n  if (var4) {\n    var9.field1 = -1;\n  }\n  return var9;\n}", "style": "rule"}, "extra_info": {"index": 7761, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int field1; float field2; char* field3; char* field4; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n scalar_t__ malloc (int) ; \n int /*<<< orphan*/  printf (char*,int) ; \n int sscanf (char*,char*,int*,char*,char*,float*) ; \n int /*<<< orphan*/  strcpy (char*,char*) ; \n int strlen (char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long net_send(long long a1) {\n  long long v1;\n  long long v2;\n  uint64_t *udata;\n  uint64_t *v5;\n  long long v6;\n  unsigned int v7;\n  long long v8;\n  long long v9;\n  long long v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  uint8_t v17[4];\n  long long v18;\n  uint64_t v19[9];\n  v19[1] = __readfsqword(40u);\n  udata = (uint64_t *)net_get_udata();\n  if (!udata) return luaL_error(a1, \"invalid user data\");\n  v5 = udata;\n  v6 = *udata;\n  if (v6 == TYPE_TCP_SERVER) return luaL_error(a1, \"invalid user data\");\n  v7 = 3;\n  v8 = 2LL;\n  v18 = 0LL;\n  if (v6 == TYPE_UDP_SOCKET) {\n    v19[0] = 0LL;\n    v1 = luaL_checkinteger(a1, 2LL);\n    if (!v1) return luaL_error(a1, \"need port\");\n    v11 = luaL_checklstring(a1, 3LL, v19);\n    if (!v11) return luaL_error(a1, \"need IP address\");\n    v7 = 5;\n    v8 = 4LL;\n    if (!(unsigned int)ipaddr_aton(v11, v17))\n      return luaL_error(a1, \"invalid IP address\");\n  }\n  v9 = luaL_checklstring(a1, v8, &v18);\n  if (!v9 || !v18) return luaL_error(a1, \"no data to send\");\n  if (lua_isfunction(a1, v7) || lua_islightfunction(a1, v7)) {\n    lua_pushvalue(a1, v7);\n    luaL_unref(a1, (unsigned int)LUA_REGISTRYINDEX, v5[3]);\n    v5[3] = luaL_ref(a1, (unsigned int)LUA_REGISTRYINDEX);\n  }\n  if (*v5 != TYPE_UDP_SOCKET) goto LABEL_10;\n  if (!*((uint32_t *)v5 + 10)) {\n    v14 = udp_new();\n    v5[4] = v14;\n    if (!v14) return luaL_error(a1, \"cannot allocate PCB\");\n    udp_recv(v14, (unsigned int)net_udp_recv_cb, v5);\n    v15 = v5[4];\n    LODWORD(v19[0]) = 0;\n    v16 = udp_bind(v15, v19, 0LL);\n    if (ERR_OK != v16) {\n      udp_remove(v5[4]);\n      v5[4] = 0LL;\n      return lwip_lua_checkerr(a1, v16);\n    }\n    if (v5[1] == LUA_NOREF) {\n      lua_pushvalue(a1, 1LL);\n      v5[1] = luaL_ref(a1, (unsigned int)LUA_REGISTRYINDEX);\n    }\n  LABEL_10:\n    if (*((uint32_t *)v5 + 10) && v5[1] != LUA_NOREF) {\n      if (*v5 != TYPE_UDP_SOCKET) {\n        if (*v5 == TYPE_TCP_CLIENT)\n          v2 = tcp_write(*((unsigned int *)v5 + 4), v9, v18,\n                         (unsigned int)TCP_WRITE_FLAG_COPY);\n        return lwip_lua_checkerr(a1, v2);\n      }\n      goto LABEL_27;\n    }\n    return luaL_error(a1, \"not connected\");\n  }\n  if (LUA_NOREF == v5[1]) return luaL_error(a1, \"not connected\");\nLABEL_27:\n  v12 = pbuf_alloc((unsigned int)PBUF_TRANSPORT, v18, (unsigned int)PBUF_RAM);\n  v13 = v12;\n  if (v12) {\n    pbuf_take(v12, v9, v18);\n    v2 = udp_sendto(v5[4], v13, v17, v1);\n    pbuf_free(v13);\n    if (v5[3] != LUA_NOREF) {\n      lua_rawgeti(a1, (unsigned int)LUA_REGISTRYINDEX);\n      lua_rawgeti(a1, (unsigned int)LUA_REGISTRYINDEX);\n      lua_call(a1, 1LL, 0LL);\n    }\n    return lwip_lua_checkerr(a1, v2);\n  }\n  return luaL_error(a1, \"cannot allocate message buffer\");\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int net_send(type1 *var1) {\n  type2 *var2 = net_get_udata(var1);\n  if (!var2 || var2->field1 == var3)\n    return luaL_error(var1, \"invalid user data\");\n  type3 var4;\n  uint16_t var5;\n  const char *var6;\n  size_t var7 = 0;\n  int var8 = 2;\n  if (var2->field1 == var9) {\n    size_t var10 = 0;\n    var5 = luaL_checkinteger(var1, var8++);\n    if (var5 == 0) return luaL_error(var1, \"need port\");\n    const char *var11 = luaL_checklstring(var1, var8++, &var10);\n    if (!var11) return luaL_error(var1, \"need IP address\");\n    if (!ipaddr_aton(var11, &var4))\n      return luaL_error(var1, \"invalid IP address\");\n  }\n  var6 = luaL_checklstring(var1, var8++, &var7);\n  if (!var6 || var7 == 0) return luaL_error(var1, \"no data to send\");\n  if (lua_isfunction(var1, var8) || lua_islightfunction(var1, var8)) {\n    lua_pushvalue(var1, var8++);\n    luaL_unref(var1, var12, var2->field2.field3);\n    var2->field2.field3 = luaL_ref(var1, var12);\n  }\n  if (var2->field1 == var9 && !var2->field4) {\n    var2->field5 = udp_new();\n    if (!var2->field5) return luaL_error(var1, \"cannot allocate PCB\");\n    udp_recv(var2->field5, var13, var2);\n    type3 var14 = {0};\n    type4 var15 = udp_bind(var2->field5, &var14, 0);\n    if (var15 != var16) {\n      udp_remove(var2->field5);\n      var2->field5 = NULL;\n      return lwip_lua_checkerr(var1, var15);\n    }\n    if (var2->field6 == var17) {\n      lua_pushvalue(var1, 1);\n      var2->field6 = luaL_ref(var1, var12);\n    }\n  }\n  if (!var2->field4 || var2->field6 == var17)\n    return luaL_error(var1, \"not connected\");\n  type4 var15;\n  if (var2->field1 == var9) {\n    struct type5 *var18 = pbuf_alloc(var19, var7, var20);\n    if (!var18) return luaL_error(var1, \"cannot allocate message buffer\");\n    pbuf_take(var18, var6, var7);\n    var15 = udp_sendto(var2->field5, var18, &var4, var5);\n    pbuf_free(var18);\n    if (var2->field2.field3 != var17) {\n      lua_rawgeti(var1, var12, var2->field2.field3);\n      lua_rawgeti(var1, var12, var2->field6);\n      lua_call(var1, 1, 0);\n    }\n  } else if (var2->field1 == var21) {\n    var15 = tcp_write(var2->field7, var6, var7, var22);\n  }\n  return lwip_lua_checkerr(var1, var15);\n}", "style": "rule"}, "extra_info": {"index": 78379, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint16_t ;\ntypedef  scalar_t__ type4 ;\nstruct TYPE_10__ {int /*<<< orphan*/  member_0; } ;\ntypedef  TYPE_2__ type3 ;\nstruct TYPE_9__ {scalar_t__ field3; } ;\nstruct TYPE_11__ {scalar_t__ field1; scalar_t__ field6; int /*<<< orphan*/  field7; TYPE_1__ field2; int /*<<< orphan*/ * field5; int /*<<< orphan*/  field4; } ;\ntypedef  TYPE_3__ type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\nstruct type5 {int dummy; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  ipaddr_aton (char const*,TYPE_2__*) ; \n scalar_t__ luaL_checkinteger (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n char* luaL_checklstring (int /*<<< orphan*/ *,int /*<<< orphan*/ ,size_t*) ; \n int luaL_error (int /*<<< orphan*/ *,char*) ; \n void* luaL_ref (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  luaL_unref (int /*<<< orphan*/ *,int /*<<< orphan*/ ,scalar_t__) ; \n int /*<<< orphan*/  lua_call (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ; \n scalar_t__ lua_isfunction (int /*<<< orphan*/ *,int) ; \n scalar_t__ lua_islightfunction (int /*<<< orphan*/ *,int) ; \n int /*<<< orphan*/  lua_pushvalue (int /*<<< orphan*/ *,int) ; \n int /*<<< orphan*/  lua_rawgeti (int /*<<< orphan*/ *,int /*<<< orphan*/ ,scalar_t__) ; \n int lwip_lua_checkerr (int /*<<< orphan*/ *,scalar_t__) ; \n TYPE_3__* net_get_udata (int /*<<< orphan*/ *) ; \n struct type5* pbuf_alloc (int /*<<< orphan*/ ,size_t,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  pbuf_free (struct type5*) ; \n int /*<<< orphan*/  pbuf_take (struct type5*,char const*,size_t) ; \n scalar_t__ tcp_write (int /*<<< orphan*/ ,char const*,size_t,int /*<<< orphan*/ ) ; \n scalar_t__ udp_bind (int /*<<< orphan*/ *,TYPE_2__*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/ * udp_new () ; \n int /*<<< orphan*/  udp_recv (int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_3__*) ; \n int /*<<< orphan*/  udp_remove (int /*<<< orphan*/ *) ; \n scalar_t__ udp_sendto (int /*<<< orphan*/ *,struct type5*,TYPE_2__*,scalar_t__) ; \n int /*<<< orphan*/  var12 ; \n int /*<<< orphan*/  var13 ; \n scalar_t__ var16 ; \n scalar_t__ var17 ; \n int /*<<< orphan*/  var19 ; \n int /*<<< orphan*/  var20 ; \n scalar_t__ var21 ; \n int /*<<< orphan*/  var22 ; \n scalar_t__ var3 ; \n scalar_t__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long GetTextLine(long long a1, uint8_t *a2, int a3, uint32_t *a4,\n                      uint32_t *a5) {\n  int Character;\n  int v7;\n  int v8;\n  char v9;\n  int i;\n  bool v11;\n  long long v12;\n  long long result;\n  bool v14;\n  bool v15;\n  char v16;\n  int v17;\n  long long v18;\n  char v19;\n  uint8_t *v20;\n  int v21;\n  int v22;\n  v20 = a2;\n  do {\n    do Character = ReadCharacter(a1);\n    while ((unsigned int)(Character - 9) <= 1);\n  } while (Character == 32);\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  v22 = a3 - 1;\n  for (i = 0;; ++i) {\n    if (Character != 34) {\n      while (1) {\n        if (v8) {\n          v9 = 0;\n        } else {\n          v14 = v9;\n          v15 = Character == 47;\n          v16 = v9 & (Character == 47);\n          if (v16) goto LABEL_30;\n          if (Character == 59) {\n          LABEL_29:\n            v16 = v15;\n          LABEL_30:\n            if (i > 0 && v16)\n              LODWORD(v12) = i - 1;\n            else\n              LODWORD(v12) = i;\n            do Character = ReadCharacter(a1);\n            while ((unsigned int)(Character + 1) > 1 && Character != 10);\n            v8 = 0;\n            if (!(uint32_t)v12) {\n              *a2 = 0;\n              goto LABEL_43;\n            }\n            goto LABEL_36;\n          }\n        LABEL_22:\n          while (Character == 42 && v14) {\n            v17 = 42;\n            i = (i == 0) + i - 1;\n            do {\n              while (1) {\n                v14 = v17 != 42 && v17 != -1;\n                if (!v14) break;\n                v17 = ReadCharacter(a1);\n              }\n              v17 = ReadCharacter(a1);\n            } while (v17 != 47);\n            v9 = 0;\n            v8 = 0;\n            Character = ReadCharacter(a1);\n            v15 = Character == 47;\n            if (Character == 34) goto LABEL_11;\n            if (Character == 59) goto LABEL_29;\n          }\n          v8 = 0;\n        }\n        v11 = Character == 10;\n        if (!v7 || Character != 10) break;\n        i = (i == 0) + i - 1;\n        v7 = 0;\n        Character = ReadCharacter(a1);\n        if (Character == 34) goto LABEL_11;\n      }\n      v12 = i;\n      if (Character != 47) goto LABEL_13;\n      v9 = 1;\n      v7 = 0;\n      if (v22 > i) goto LABEL_16;\n    LABEL_19:\n      Report(a1, 3LL, \"Line too long\");\n      return 0LL;\n    }\n  LABEL_11:\n    if (v8 == 1) {\n      v14 = v9;\n      goto LABEL_22;\n    }\n    v11 = 0;\n    v12 = i;\n    v8 ^= 1u;\n  LABEL_13:\n    v7 = Character == 92;\n    if ((unsigned int)(Character + 1) <= 1) break;\n    if (v11) {\n      Character = 10;\n      break;\n    }\n    v9 = 0;\n    if (v22 <= i) goto LABEL_19;\n  LABEL_16:\n    a2[v12] = Character;\n    Character = ReadCharacter(a1);\n  }\n  if (i) {\n  LABEL_36:\n    v18 = (int)v12;\n    do {\n      LODWORD(v12) = v18;\n      v19 = v20[v18 - 1];\n      if (v19 != 32 && v19 != 9) {\n        v20 += v18;\n        goto LABEL_41;\n      }\n      --v18;\n    } while (v18);\n    LODWORD(v12) = 0;\n  }\nLABEL_41:\n  *v20 = 0;\n  if (v8) {\n    v21 = Character;\n    Report(a1, 3LL, \"Open Quotes\");\n    Character = v21;\n  }\nLABEL_43:\n  if (a4) *a4 = v12;\n  result = 1LL;\n  if (a5) {\n    if ((uint32_t)v12 || Character != -1) {\n      *a5 = 0;\n      return 1LL;\n    } else {\n      *a5 = 1;\n    }\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int GetTextLine(type1 *var1, char *var2, int var3, int *var4,\n                       int *var5) {\n  int var6;\n  int var7;\n  int var8, var9, var10;\n  do {\n    var6 = ReadCharacter(var1);\n  } while (var6 == ' ' || var6 == 0x9 || var6 == 0xa);\n  var7 = 0;\n  var8 = 0;\n  var9 = 0;\n  var10 = 0;\n  for (;;) {\n    if (var6 == '\"') var9 ^= 1;\n    if (var9) var8 = 0;\n    if ((var8 && var6 == '/') || (!var9 && var6 == ';')) {\n      if (var6 == '/' && var7 > 0) var7--;\n      while (var6 != 0 && var6 != -1 && var6 != 0xa) var6 = ReadCharacter(var1);\n      break;\n    } else if (var8 && var6 == '*') {\n      if (var7 > 0) --var7;\n      while (1) {\n        while (var6 != -1 && var6 != '*') var6 = ReadCharacter(var1);\n        var6 = ReadCharacter(var1);\n        if (var6 == '/') break;\n      }\n      var6 = ReadCharacter(var1);\n      var8 = 0;\n      continue;\n    } else if (var10 && var6 == '\\n') {\n      if (var7 > 0) --var7;\n      var6 = ReadCharacter(var1);\n      var10 = 0;\n      continue;\n    }\n    if (var6 == '/')\n      var8 = 1;\n    else\n      var8 = 0;\n    if (var6 == '\\\\')\n      var10 = 1;\n    else\n      var10 = 0;\n    if (var6 == 0 || var6 == -1 || var6 == 0xa) break;\n    if (var7 < (var3 - 1)) {\n      if (!(var10 && var6 == '\\n')) var2[var7++] = var6;\n    } else {\n      Report(var1, 3, \"Line too long\");\n      return (0);\n    }\n    var6 = ReadCharacter(var1);\n  }\n  while (var7 > 0 && (var2[var7 - 1] == ' ' || var2[var7 - 1] == 0x9)) var7--;\n  var2[var7] = 0;\n  if (var9) Report(var1, 3, \"Open Quotes\");\n  if (var4) *var4 = var7;\n  if (var5) {\n    if (var7 || var6 != -1)\n      *var5 = 0;\n    else\n      *var5 = 1;\n  }\n  return (1);\n}", "style": "rule"}, "extra_info": {"index": 24378, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int ReadCharacter (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  Report (int /*<<< orphan*/ *,int,char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t ***IoState_createOperatorTable(long long a1) {\n  unsigned int v1;\n  unsigned int v2;\n  int *i;\n  uint64_t ***v5;\n  uint8_t v6[600];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  qmemcpy(v6, &off_120, 592uLL);\n  v5 = (uint64_t ***)IoMap_new(a1, &off_120 + 74, &off_120);\n  for (i = (int *)v6; *(uint64_t *)i; i += 4) {\n    v1 = IoState_numberWithDouble_(***v5, (double)i[2]);\n    v2 = IoState_symbolWithCString_(***v5, *(uint64_t *)i);\n    IoMap_rawAtPut(v5, v2, v1);\n  }\n  return v5;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 *IoState_createOperatorTable(type2 *var1) {\n  typedef struct type3 {\n    char *field1;\n    int field2;\n  } type3;\n  type3 var2[] = {\n      {\"@\", 0},       {\"@@\", 0},  {\"?\", 0},   {\"**\", 1},   {\"*\", 2},\n      {\"/\", 2},       {\"%\", 2},   {\"+\", 3},   {\"-\", 3},    {\"<<\", 4},\n      {\">>\", 4},      {\">\", 5},   {\"<\", 5},   {\"<=\", 5},   {\">=\", 5},\n      {\"==\", 6},      {\"!=\", 6},  {\"&\", 7},   {\"^\", 8},    {\"|\", 9},\n      {\"and\", 10},    {\"&&\", 10}, {\"or\", 11}, {\"||\", 11},  {\"..\", 12},\n      {\"+=\", 13},     {\"-=\", 13}, {\"*=\", 13}, {\"/=\", 13},  {\"%=\", 13},\n      {\"&=\", 13},     {\"^=\", 13}, {\"|=\", 13}, {\"<<=\", 13}, {\">>=\", 13},\n      {\"return\", 14}, {NULL, 0},\n  };\n  type1 *var3 = IoMap_new(var1);\n  type3 *var4 = var2;\n  while (var4->field1) {\n    IoMap_rawAtPut(\n        var3,\n        IoState_symbolWithCString_(\n            (type2 *)((type2 *)((((type4 *)(((type5 *)(var3))->field3))->field4)\n                                    ->field5)),\n            (char *)(var4->field1)),\n        IoState_numberWithDouble_(\n            (type2 *)((type2 *)((((type4 *)(((type5 *)(var3))->field3))->field4)\n                                    ->field5)),\n            (double)var4->field2));\n    var4++;\n  }\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 43083, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ field3; } ;\ntypedef  TYPE_2__ type5 ;\nstruct TYPE_6__ {TYPE_1__* field4; } ;\ntypedef  TYPE_3__ type4 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\nstruct TYPE_4__ {scalar_t__ field5; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/ * IoMap_new (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  IoMap_rawAtPut (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  IoState_numberWithDouble_ (int /*<<< orphan*/ *,double) ; \n int /*<<< orphan*/  IoState_symbolWithCString_ (int /*<<< orphan*/ *,char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint pmat(int a1, int a2, long long a3) {\n  int v3;\n  int i;\n  double *v5;\n  double v6;\n  int result;\n  if (a1 > 0) {\n    v3 = 0;\n    for (i = 0; i != a1; ++i) {\n      printf(\"row %d: \", i);\n      if (a2 > 0) {\n        v5 = (double *)(a3 + 8LL * v3);\n        do {\n          v6 = *v5++;\n          printf(\"%.6f  \", v6);\n        } while (\n            v5 !=\n            (double *)(a3 +\n                       8 * (v3 + (unsigned long long)(unsigned int)(a2 - 1)) +\n                       8));\n        v3 += a2;\n      }\n      result = putchar(10);\n    }\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void pmat(int var1, int var2, double var3[]) {\n  int var4;\n  int var5;\n  int var6;\n  var6 = 0;\n  for (var4 = 0; var4 < var1; var4++) {\n    printf(\"row %d: \", var4);\n    for (var5 = 0; var5 < var2; var5++) {\n      printf(\"%.6f  \", var3[var6]);\n      var6 += 1;\n    }\n    printf(\"\\n\");\n  }\n}", "style": "rule"}, "extra_info": {"index": 37724, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long update_anon_info(uint64_t *a1, const char *a2) {\n  uint64_t *v2;\n  int v3;\n  unsigned int v4;\n  long long **i;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  if (a2) {\n    v2 = (uint64_t *)*a1;\n    if (!*a1) goto LABEL_18;\n    v3 = 0;\n    v4 = 0;\n    do {\n      for (i = (long long **)v2[1]; i; i = (long long **)*i) {\n        v6 = anonymize;\n        if (!i[1]) {\n          while (v6) {\n            LODWORD(v7) = strcmp((const char *)*(unsigned int *)(v6 + 16), a2);\n            if (!v7) {\n              LODWORD(v8) = strcmp((const char *)*((unsigned int *)i + 4),\n                                   *(const char **)v6);\n              if (!v8) {\n                LODWORD(v9) = strcmp((const char *)*((unsigned int *)i + 4),\n                                     *(const char **)v6);\n                if (!v9) {\n                  i[1] = (long long *)v6;\n                  ++v4;\n                  v3 = 1;\n                  break;\n                }\n                v3 = 1;\n              }\n            }\n            v6 = *(uint64_t *)(v6 + 8);\n            if (i[1]) break;\n          }\n        }\n      }\n      v2 = (uint64_t *)*v2;\n    } while (v2);\n    if (!v3)\n    LABEL_18:\n      panic(\"Unknown anonymization\", a2, 0LL);\n  } else {\n    return 0;\n  }\n  return v4;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int update_anon_info(struct type1 *var1, char *var2) {\n  struct type2 *var3 = var1->field1;\n  struct type3 *var4;\n  struct type4 *var5;\n  int var6 = 0;\n  int var7 = 0;\n  if (var2 == NULL) return 0;\n  while (var3 != NULL) {\n    var4 = var3->field2;\n    while (var4 != NULL) {\n      var5 = var8;\n      while (var4->field3 == NULL && var5 != NULL) {\n        if (strcmp(var5->field4, var2) == 0 &&\n            strcmp(var4->field5, var5->field6) == 0) {\n          if (!var7) var7 = 1;\n          if (strcmp(var4->field5, var5->field6) == 0) {\n            var4->field3 = var5;\n            var6++;\n          }\n        }\n        var5 = var5->field7;\n      }\n      var4 = var4->field7;\n    }\n    var3 = var3->field7;\n  }\n  if (!var7) panic(\"Unknown anonymization\", var2, NULL);\n  return var6;\n}", "style": "rule"}, "extra_info": {"index": 11236, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type4 {char* field6; struct type4* field7; int /*<<< orphan*/  field4; } ;\nstruct type3 {struct type3* field7; struct type4* field3; int /*<<< orphan*/  field5; } ;\nstruct type2 {struct type2* field7; struct type3* field2; } ;\nstruct type1 {struct type2* field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  panic (char*,char*,int /*<<< orphan*/ *) ; \n scalar_t__ strcmp (int /*<<< orphan*/ ,char*) ; \n struct type4* var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long yadif_filter(int *a1, uint64_t *a2, unsigned int a3,\n                       unsigned int a4) {\n  unsigned long long v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  long long v11;\n  long long v12;\n  long long v13;\n  long long result;\n  int *v15;\n  char *v16;\n  int *v17;\n  char *v18;\n  unsigned int v19;\n  long long v20;\n  int v21;\n  void *v22;\n  int v23;\n  long long v24;\n  long long v25;\n  long long v26;\n  v5 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(a3), _mm_cvtsi32_si128(a4))\n           .m128i_u64[0];\n  v6 = *a1;\n  v7 = HB_COMB_HEAVY;\n  if ((MODE_DECOMB_SELECTIVE & *a1) != 0)\n    v7 = **(uint32_t **)(*((uint64_t *)a1 + 1) + 8LL);\n  v8 = MODE_DECOMB_BLEND;\n  if ((MODE_DECOMB_BLEND & v6) == 0) {\n    if (HB_COMB_NONE != v7) goto LABEL_6;\n    if (!MODE_DECOMB_BLEND) {\n      ++a1[13];\n      ++a1[10];\n    LABEL_28:\n      *(uint32_t *)(*((uint64_t *)a1 + 2) + 8LL) = 0;\n      return hb_buffer_copy(a2, *(uint64_t *)(*((uint64_t *)a1 + 1) + 8LL),\n                            *(double *)&v5);\n    }\n  LABEL_27:\n    v5 = _mm_add_epi32(_mm_loadl_epi64((const __m128i *)(a1 + 10)),\n                       _mm_loadl_epi64((const __m128i *)&LC0))\n             .m128i_u64[0];\n    *((uint64_t *)a1 + 5) = v5;\n    goto LABEL_28;\n  }\n  if (HB_COMB_LIGHT == v7) {\n    ++a1[13];\n    ++a1[10];\n    if ((MODE_DECOMB_EEDI2 & v8) == 0) goto LABEL_31;\n    goto LABEL_18;\n  }\n  if (v7 == HB_COMB_NONE) goto LABEL_27;\nLABEL_6:\n  v9 = ~MODE_DECOMB_SELECTIVE & v6;\n  if (MODE_DECOMB_BLEND == v9) {\n    ++a1[13];\n    ++a1[10];\n    if ((MODE_DECOMB_EEDI2 & v8) == 0) {\n      if (!v8) goto LABEL_28;\n    LABEL_31:\n      v9 = v8;\n      goto LABEL_9;\n    }\n  LABEL_18:\n    v9 = v8;\n    goto LABEL_19;\n  }\n  if (!v9) goto LABEL_27;\n  ++a1[12];\n  ++a1[10];\n  if ((MODE_DECOMB_EEDI2 & v9) == 0) {\n  LABEL_9:\n    v10 = a1[1];\n    if (v10 > 0) {\n      v11 = *((uint64_t *)a1 + 2);\n      v12 = v11 + 24;\n      v13 = v11 + 24 + 24LL * (unsigned int)(v10 - 1);\n      while (1) {\n        *(uint64_t *)(v11 + 16) = a2;\n        *(uint32_t *)(v11 + 8) = v9;\n        *(uint64_t *)v11 = v5;\n        v11 = v12;\n        if (v13 == v12) break;\n        v12 += 24LL;\n      }\n    }\n    return taskset_cycle(a1 + 6, *(double *)&v5);\n  }\nLABEL_19:\n  eedi2_planer(a1);\n  if ((MODE_DECOMB_EEDI2 & v9) == 0 || (MODE_DECOMB_YADIF & v9) != 0)\n    goto LABEL_9;\n  v26 = 0LL;\n  v25 = 0LL;\n  do {\n    v15 = (int *)(**(uint64_t **)(*((uint64_t *)a1 + 4) + 8 * DST2PF) + v25);\n    v16 = (char *)*((uint64_t *)v15 + 1);\n    v17 = (int *)(*a2 + v26);\n    v18 = (char *)*((uint64_t *)v17 + 2);\n    v19 = *v17;\n    v23 = v17[1];\n    if (v23 > 0) {\n      v20 = 4LL * v17[2];\n      v21 = 0;\n      v24 = 4LL * *v15;\n      do {\n        v22 = v18;\n        v18 += v20;\n        memcpy(v22, v16, v19);\n        ++v21;\n        v16 += v24;\n      } while (v23 != v21);\n    }\n    v25 += 16LL;\n    result = v25;\n    v26 += 24LL;\n  } while (v25 != 48);\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void yadif_filter(type1* var1, type2* var2, int var3, int var4) {\n  int var5 = var6;\n  int var7 = 0;\n  if (var1->field1 & var8) {\n    var5 = var1->field2[1]->field3.field4;\n  }\n  if ((var1->field1 & var9) && var5 == var10) {\n    var7 = var9;\n  } else if (var5 != var11) {\n    var7 = var1->field1 & ~var8;\n  }\n  if (var7 == var9) {\n    var1->field5++;\n  } else if (var7 != 0) {\n    var1->field6++;\n  } else {\n    var1->field7++;\n  }\n  var1->field8++;\n  if (var7 & var12) {\n    eedi2_planer(var1);\n  }\n  if (var7 != 0) {\n    if ((var7 & var12) && !(var7 & var13)) {\n      int var14;\n      for (var14 = 0; var14 < 3; var14++) {\n        uint8_t* var15 = var1->field9[var16]->field10[var14].field11;\n        int var17 = var1->field9[var16]->field10[var14].field12;\n        uint8_t* var18 = var2->field10[var14].field11;\n        int var19 = var2->field10[var14].field13;\n        int var20 = var2->field10[var14].field14;\n        int var21 = var2->field10[var14].field12;\n        int var22;\n        for (var22 = 0; var22 < var20; var22++) {\n          memcpy(var18, var15, var19);\n          var18 += var21;\n          var15 += var17;\n        }\n      }\n    } else {\n      int var23;\n      for (var23 = 0; var23 < var1->field15; var23++) {\n        var1->field16[var23].field17 = var3;\n        var1->field16[var23].field18 = var4;\n        var1->field16[var23].field19 = var2;\n        var1->field16[var23].field1 = var7;\n      }\n      taskset_cycle(&var1->field20);\n    }\n  } else {\n    var1->field16[0].field1 = var7;\n    hb_buffer_copy(var2, var1->field2[1]);\n  }\n}", "style": "rule"}, "extra_info": {"index": 81957, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_20__   TYPE_7__ ;\ntypedef  struct TYPE_19__   TYPE_6__ ;\ntypedef  struct TYPE_18__   TYPE_5__ ;\ntypedef  struct TYPE_17__   TYPE_4__ ;\ntypedef  struct TYPE_16__   TYPE_3__ ;\ntypedef  struct TYPE_15__   TYPE_2__ ;\ntypedef  struct TYPE_14__   TYPE_1__ ;\ntypedef  struct TYPE_13__   TYPE_11__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\nstruct TYPE_19__ {TYPE_4__* field10; } ;\ntypedef  TYPE_6__ type2 ;\nstruct TYPE_20__ {int field1; int field15; TYPE_11__** field2; TYPE_5__* field16; int /*<<< orphan*/  field20; TYPE_3__** field9; int /*<<< orphan*/  field8; int /*<<< orphan*/  field7; int /*<<< orphan*/  field6; int /*<<< orphan*/  field5; } ;\ntypedef  TYPE_7__ type1 ;\nstruct TYPE_18__ {int field17; int field18; int field1; TYPE_6__* field19; } ;\nstruct TYPE_17__ {int field13; int field14; int field12; int /*<<< orphan*/ * field11; } ;\nstruct TYPE_16__ {TYPE_2__* field10; } ;\nstruct TYPE_15__ {int field12; int /*<<< orphan*/ * field11; } ;\nstruct TYPE_14__ {int field4; } ;\nstruct TYPE_13__ {TYPE_1__ field3; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  eedi2_planer (TYPE_7__*) ; \n int /*<<< orphan*/  hb_buffer_copy (TYPE_6__*,TYPE_11__*) ; \n int /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ; \n int /*<<< orphan*/  taskset_cycle (int /*<<< orphan*/ *) ; \n int var10 ; \n int var11 ; \n int var12 ; \n int var13 ; \n size_t var16 ; \n int var6 ; \n int var8 ; \n int var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint printMap(int a1, long long a2) {\n  long long v2;\n  long long v3;\n  int v4;\n  const char *v5;\n  if (a1 > 0) {\n    v2 = a2 + 16LL * (unsigned int)(a1 - 1) + 16;\n    v3 = a2;\n    do {\n      v4 = *(uint32_t *)(v3 + 8);\n      v5 = *(const char **)v3;\n      v3 += 16LL;\n      printf(\"%s:%d\\n\", v5, v4);\n    } while (v3 != v2);\n  }\n  return puts(\"\\n\");\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void printMap(type1 var1) {\n  int var2;\n  for (var2 = 0; var2 < var1.field1; var2++)\n    printf(\"%s:%d\\n\", var1.field2[var2].field3, var1.field2[var2].field4);\n  printf(\"\\n\\n\");\n}", "style": "rule"}, "extra_info": {"index": 48996, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int field1; TYPE_1__* field2; } ;\ntypedef  TYPE_2__ type1 ;\nstruct TYPE_4__ {char* field3; int field4; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int i;\n  int j;\n  uint32_t v7[22];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  v3 = time(0LL);\n  srand(v3);\n  for (i = 1; i <= 20; ++i) v7[i] = rand() % 20;\n  heapsort(v7, 1LL, 20LL);\n  for (j = 1; j <= 20; ++j) printf(\"%i \", v7[j]);\n  putchar(10);\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(void) {\n  int var1;\n  type1 var2[20 + 1];\n  srand(time(NULL));\n  for (var1 = 1; var1 <= 20; ++var1) {\n    var2[var1] = rand() % 20;\n  }\n  heapsort(var2, 1, 20);\n  for (var1 = 1; var1 <= 20; ++var1) {\n    printf(\"%i \", var2[var1]);\n  }\n  printf(\"\\n\");\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 630, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  heapsort (int*,int,int) ; \n int /*<<< orphan*/  printf (char*,...) ; \n int rand () ; \n int /*<<< orphan*/  srand (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  time (int /*<<< orphan*/ *) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long add_option(void **a1, const char *a2, int a3) {\n  const char *v4;\n  int v6;\n  int v7;\n  char *v8;\n  char *v10;\n  v4 = (const char *)*a1;\n  if (v4) {\n    v6 = strlen(v4);\n    v7 = strlen(a2);\n    v8 = (char *)realloc(*a1, (unsigned int)(v7 + v6 + a3 + 2));\n    if (!v8) {\n    LABEL_3:\n      fprintf((FILE *)(unsigned int)stderr, \"%s: failed to allocate memory\\n\",\n              (const char *)progname);\n      return 4294967295LL;\n    }\n    v10 = v8;\n    sprintf(&v8[v6], \",%s\", a2);\n  } else {\n    v10 = strdup(a2);\n    if (!v10) goto LABEL_3;\n  }\n  *a1 = v10;\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int add_option(char **var1, const char *var2, unsigned var3) {\n  char *var4;\n  if (*var1 == NULL)\n    var4 = strdup(var2);\n  else {\n    unsigned var5 = strlen(*var1);\n    unsigned var6 = var5 + 1 + strlen(var2) + var3 + 1;\n    var4 = (char *)realloc(*var1, var6);\n    if (var4) sprintf(var4 + var5, \",%s\", var2);\n  }\n  if (var4 == NULL) {\n    fprintf(var7, \"%s: failed to allocate memory\\n\", var8);\n    return -1;\n  }\n  *var1 = var4;\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 60570, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ; \n scalar_t__ realloc (char*,unsigned int) ; \n int /*<<< orphan*/  sprintf (char*,char*,char const*) ; \n char* strdup (char const*) ; \n unsigned int strlen (char const*) ; \n int /*<<< orphan*/  var7 ; \n char* var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t *on_request_path(uint64_t **a1, const void *a2, unsigned int a3) {\n  uint64_t *result;\n  uint64_t *v5;\n  v5 = *a1;\n  if (**a1 + a3 <= 255) memcpy((void *)(v5[1] + *v5), a2, a3);\n  result = v5;\n  *v5 += a3;\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void on_request_path(type1* var1, const char* var2, size_t var3) {\n  type2* var4 = (type2*)var1->field1;\n  if (var3 + var4->field2 < 256)\n    memcpy(var4->field3 + var4->field2, var2, var3);\n  var4->field2 += var3;\n}", "style": "rule"}, "extra_info": {"index": 32397, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t field2; scalar_t__ field3; } ;\ntypedef  TYPE_1__ type2 ;\nstruct TYPE_5__ {scalar_t__ field1; } ;\ntypedef  TYPE_2__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  memcpy (scalar_t__,char const*,size_t) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long copy_data(int a1, int a2) {\n  ssize_t i;\n  unsigned int v4;\n  long long n;\n  uint8_t *buf;\n  ssize_t j;\n  uint8_t v8[16];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  v4 = 0;\n  for (i = read(a1, v8, 8192uLL);; i = read(a1, v8, 8192uLL)) {\n    n = i;\n    if (i <= 0) break;\n    buf = v8;\n    for (j = 0LL; n > 0; v4 += j) {\n      j = write(a2, buf, n);\n      if (j <= 0) break;\n      buf += j;\n      n -= j;\n    }\n    if (!j) {\n      fprintf((FILE *)(unsigned int)stderr,\n              \"Warning: EOF writing to output file.\\n\");\n      return 4294967295LL;\n    }\n  }\n  return v4;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int copy_data(int var1, int var2) {\n  char var3[8192];\n  ssize_t var4;\n  int var5 = 0;\n  while ((var4 = read(var1, var3, sizeof(var3))) > 0) {\n    char *var6 = var3;\n    ssize_t var7 = 0;\n    while (var4 > 0 && (var7 = write(var2, var6, var4)) > 0) {\n      var6 += var7;\n      var4 -= var7;\n      var5 += var7;\n    }\n    if (var7 == 0) {\n      fprintf(var8, \"Warning: EOF writing to output file.\\n\");\n      return (-1);\n    }\n  }\n  return (var5);\n}", "style": "rule"}, "extra_info": {"index": 23049, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var3 ;\ntypedef  scalar_t__ ssize_t ;\n\n/* Variables and functions */\n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; \n scalar_t__ read (int,char*,int) ; \n int /*<<< orphan*/  var8 ; \n scalar_t__ write (int,char*,scalar_t__) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long get_update_interval() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long v3;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long sensor_update_interval;\n  long long v10;\n  long long v11;\n  long long v12;\n  sensor_update_interval = get_sensor_update_interval(\"4-0040\");\n  if (sensor_update_interval < 0)\n    fprintf(\n        (FILE *)(unsigned int)stderr,\n        \"get_update_interval: Warning: could not read A15 update interval\\n\");\n  v0 = sensor_update_interval;\n  if (sensor_update_interval <= 0) v0 = 0LL;\n  v5 = v0;\n  v10 = get_sensor_update_interval(\"4-0045\");\n  if (v10 < 0)\n    fprintf(\n        (FILE *)(unsigned int)stderr,\n        \"get_update_interval: Warning: could not read A7 update interval\\n\");\n  v1 = v10;\n  if (v5 >= v10) v1 = v5;\n  v6 = v1;\n  v11 = get_sensor_update_interval(\"4-0041\");\n  if (v11 < 0)\n    fprintf(\n        (FILE *)(unsigned int)stderr,\n        \"get_update_interval: Warning: could not read MEM update interval\\n\");\n  v2 = v11;\n  if (v6 >= v11) v2 = v6;\n  v7 = v2;\n  v12 = get_sensor_update_interval(\"4-0044\");\n  if (v12 < 0)\n    fprintf(\n        (FILE *)(unsigned int)stderr,\n        \"get_update_interval: Warning: could not read GPU update interval\\n\");\n  v3 = v12;\n  if (v7 >= v12) v3 = v7;\n  v8 = v3;\n  if (!v3) {\n    v8 = 263808LL;\n    fprintf((FILE *)(unsigned int)stderr,\n            \"get_update_interval: Using default value: %ld us\\n\", 263808LL);\n  }\n  return v8;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static inline long get_update_interval() {\n  long var1 = 0;\n  long var2;\n  var2 = get_sensor_update_interval(\"4-0040\");\n  if (var2 < 0) {\n    fprintf(var3,\n            \"get_update_interval: Warning: could not read A15 update \"\n            \"interval\\n\");\n  }\n  var1 = var2 > var1 ? var2 : var1;\n  var2 = get_sensor_update_interval(\"4-0045\");\n  if (var2 < 0) {\n    fprintf(var3,\n            \"get_update_interval: Warning: could not read A7 update \"\n            \"interval\\n\");\n  }\n  var1 = var2 > var1 ? var2 : var1;\n  var2 = get_sensor_update_interval(\"4-0041\");\n  if (var2 < 0) {\n    fprintf(var3,\n            \"get_update_interval: Warning: could not read MEM update \"\n            \"interval\\n\");\n  }\n  var1 = var2 > var1 ? var2 : var1;\n  var2 = get_sensor_update_interval(\"4-0044\");\n  if (var2 < 0) {\n    fprintf(var3,\n            \"get_update_interval: Warning: could not read GPU update \"\n            \"interval\\n\");\n  }\n  var1 = var2 > var1 ? var2 : var1;\n  if (var1 == 0) {\n    var1 = 263808;\n    fprintf(var3, \"get_update_interval: Using default value: %ld us\\n\", var1);\n  }\n  return var1;\n}", "style": "rule"}, "extra_info": {"index": 30190, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; \n long get_sensor_update_interval (char*) ; \n int /*<<< orphan*/  var3 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long eval_empty_actions(unsigned long long a1, unsigned long long a2) {\n  unsigned int v2;\n  uint64_t *v3;\n  unsigned int v5;\n  unsigned int v6;\n  char *v7;\n  long long v8;\n  long long v9;\n  __m128i v10;\n  long long v11;\n  int v12;\n  unsigned int v13;\n  int **i;\n  int v15;\n  __m128i v16;\n  void *v17;\n  void *ptr;\n  __m128i v19;\n  int v20;\n  long long v21;\n  int v22;\n  unsigned long long v23;\n  v2 = 0;\n  v3 = *(uint64_t **)(a2 + 24);\n  v23 = __readfsqword(40u);\n  v16 = _mm_unpacklo_epi64((__m128i)a1, (__m128i)a2);\n  if (*v3) return v2;\n  v22 = *(uint32_t *)(a2 + 16);\n  v5 = pathname(a2);\n  ptr = strdup((const char *)v5);\n  v6 = subpathname(a2);\n  v7 = strdup((const char *)v6);\n  v10 = _mm_load_si128(&v16);\n  v11 = (unsigned int)empty_count;\n  v17 = v7;\n  v21 = *(uint64_t *)(a2 + 8);\n  v12 = 0;\n  LODWORD(v7) = **(uint32_t **)a2;\n  v19 = v10;\n  v20 = (int)v7;\n  if (empty_count > 0) {\n  LABEL_9:\n    for (i = (int **)(empty_spec + 8LL * v12);; ++i) {\n      ++v12;\n      v15 = **i;\n      if (v15 == 2) {\n        if (v3[1]) goto LABEL_7;\n      } else if (v15 != 1 || !v3[1]) {\n      LABEL_7:\n        v13 = ((long long (*)(int **, void **, long long, long long, long long,\n                              long long, long long, long long))eval_expr_top)(\n            i, &v17, v11, empty_spec, v8, v9, v16.m128i_i64[0],\n            v16.m128i_i64[1]);\n        v11 = (unsigned int)empty_count;\n        v2 = v13;\n        if (empty_count <= v12 || v13) goto LABEL_15;\n        goto LABEL_9;\n      }\n      if ((int)v11 <= v12) break;\n    }\n  }\n  v2 = 0;\nLABEL_15:\n  free(ptr);\n  free(v17);\n  return v2;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int eval_empty_actions(struct type1 *var1, struct type2 *var2) {\n  int var3, var4 = 0;\n  struct type3 var5;\n  struct type4 *var6;\n  struct type1 *var7 = var2->field1;\n  if (var7->field2 != 0) return 0;\n  var5.field3 = var2->field3;\n  var5.field4 = strdup(pathname(var2));\n  var5.field5 = strdup(subpathname(var2));\n  var5.field6 = &var2->field7->field6;\n  var5.field8 = var2->field9->field8;\n  var5.field10 = var2;\n  var5.field11 = var1;\n  for (var3 = 0; var3 < var8 && !var4; var3++) {\n    var6 = var9[var3].field12;\n# 1674 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/plougher/squashfs-tools/refs/heads/master/squashfs-tools/action.c\"\n    if ((var6->field13 == 2 && !var7->field14) ||\n        (var6->field13 == 1 && var7->field14))\n      continue;\n    var4 = func1(&var9[var3], &var5);\n  }\n  free(var5.field4);\n  free(var5.field5);\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 24170, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct type4 {int field13; } ;\nstruct type3 {void* field5; void* field4; struct type1* field11; struct type2* field10; int /*<<< orphan*/  field8; int /*<<< orphan*/ * field6; int /*<<< orphan*/  field3; } ;\nstruct type2 {TYPE_2__* field9; TYPE_1__* field7; int /*<<< orphan*/  field3; struct type1* field1; } ;\nstruct type1 {scalar_t__ field2; scalar_t__ field14; } ;\nstruct TYPE_7__ {struct type4* field12; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  field8; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  field6; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  free (void*) ; \n int func1 (TYPE_3__*,struct type3*) ; \n int /*<<< orphan*/  pathname (struct type2*) ; \n void* strdup (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  subpathname (struct type2*) ; \n int var8 ; \n TYPE_3__* var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long fh_cli_cmd_process(uint8_t *a1) {\n  uint8_t *i;\n  long long v2;\n  unsigned int v3;\n  int v5;\n  int v6;\n  void **v7;\n  uint8_t **v8;\n  int v9;\n  int v10;\n  long long v11;\n  void *v12;\n  uint32_t v13[128];\n  uint64_t v14[135];\n  v14[129] = __readfsqword(40u);\n  if (a1) {\n    for (i = a1;; ++i) {\n      LODWORD(v2) = isspace((char)*i);\n      if (!v2) break;\n    }\n    if (*i && (v5 = fh_cli_cmd_parse(i, v14, 128LL), (v6 = v5) != 0)) {\n      if (v5 <= 0) {\n        v13[0] = 0;\n        return (\n            unsigned int)((long long (*)(void *, uint64_t, uint64_t *, uint64_t,\n                                         uint32_t *, uint64_t))fh_cli_cmd_find)(\n            &cmd_list, (unsigned int)v5, v14, 0LL, v13, 0LL);\n      } else {\n        v7 = (void **)v14;\n        v8 = (uint8_t **)v14;\n        v9 = 0;\n        v10 = 0;\n        do {\n          if (**v8 == 124) {\n            v11 = v9++;\n            v13[v11] = v10;\n          }\n          ++v10;\n          ++v8;\n        } while (v6 > v10 && v9 <= 126);\n        v13[v9] = 0;\n        v3 = ((long long (*)(void *, uint64_t, uint64_t *, uint64_t, uint32_t *,\n                             uint64_t))fh_cli_cmd_find)(\n            &cmd_list, (unsigned int)v6, v14, 0LL, v13, 0LL);\n        do {\n          v12 = *v7++;\n          free(v12);\n        } while (v7 != &v14[(unsigned int)(v6 - 1) + 1]);\n      }\n    } else {\n      return 0;\n    }\n  } else {\n    return (unsigned int)-1;\n  }\n  return v3;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int fh_cli_cmd_process(char *var1) {\n  char *var2[128];\n  int var3[128];\n  int var4;\n  int var5 = 0;\n  int var6, var7;\n  if (!var1) return -1;\n  while (isspace(*var1)) var1++;\n  if (!*var1) {\n    return 0;\n  }\n  var4 = fh_cli_cmd_parse(var1, var2, 128);\n  if (var4 == 0) {\n    return 0;\n  }\n  for (var6 = var7 = 0; var6 < var4 && var7 < 128 - 1; var6++) {\n    if (var2[var6][0] == '|') {\n      var3[var7++] = var6;\n    }\n  }\n  var3[var7] = 0;\n  if (var4) {\n    var5 = func1(&var8, var4, var2, 0, var3, NULL);\n  } else {\n    var5 = -1;\n  }\n  for (var6 = 0; var6 < var4; var6++) {\n    free(var2[var6]);\n  }\n  return var5;\n}", "style": "rule"}, "extra_info": {"index": 84318, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int fh_cli_cmd_parse (char*,char**,int) ; \n int /*<<< orphan*/  free (char*) ; \n int func1 (int /*<<< orphan*/ *,int,char**,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ *) ; \n scalar_t__ isspace (char) ; \n int /*<<< orphan*/  var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  __m128i si128;\n  __m128i v4;\n  long long *v5;\n  __m128i v6;\n  long long v7;\n  int v8;\n  long long v9;\n  uint8_t *v10;\n  pthread_t *v11;\n  unsigned int *v12;\n  unsigned int *v13;\n  pthread_t v14;\n  int v16;\n  uint8_t v17[1024];\n  uint8_t v18[1008];\n  long long v19;\n  int v20;\n  unsigned long long v21;\n  si128 = _mm_load_si128((const __m128i *)&LC0);\n  v4 = _mm_load_si128((const __m128i *)&LC1);\n  v21 = __readfsqword(40u);\n  v5 = (long long *)v18;\n  do {\n    v6 = si128;\n    v5 += 2;\n    si128 = _mm_add_epi32(si128, v4);\n    *((__m128i *)v5 - 1) = v6;\n  } while (v5 != &v19);\n  v20 = 254;\n  v19 = LC2;\n  while (1) {\n    printf(\"Nombre de threads : \");\n    LODWORD(v7) = fscanf((FILE *)(unsigned int)stdin, \"%d\", &v16);\n    if (v7 == EOF) break;\n    if (v16 > 255) {\n      fprintf((FILE *)(unsigned int)stderr, \"La valeur max est 255\\n\");\n    } else {\n      RWLOCK_WRITE(*(double *)si128.m128i_i64);\n      v8 = nb_thread;\n      nb_thread = v16;\n      RWUNLOCK();\n      if (v16 < v8) {\n        v12 = (unsigned int *)&v17[4 * v16];\n        v13 = (unsigned int *)&v17[4 * (unsigned int)(v8 - 1 - v16) + 4 +\n                                   4 * (long long)v16];\n        do {\n          v14 = *v12++;\n          pthread_join(v14, 0LL);\n        } while (v12 != v13);\n      } else if (v16 > v8) {\n        v9 = 4LL * v8;\n        do {\n          ++v8;\n          v10 = &v18[v9];\n          v11 = (pthread_t *)&v17[v9];\n          v9 += 4LL;\n          pthread_create(v11, 0LL, (void *(*)(void *))(unsigned int)thd_main,\n                         v10);\n        } while (v16 > v8);\n      }\n    }\n  }\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char *var2[]) {\n  int var3;\n  type1 var4[255];\n  int var5[255];\n  int var6;\n  int var7;\n  for (var6 = 0; var6 < 255; var6++) {\n    var5[var6] = var6;\n  }\n  while (1) {\n    printf(\"Nombre de threads : \");\n    if (var8 == fscanf(var9, \"%d\", &var3)) {\n      break;\n    }\n    if (var3 > 255) {\n      fprintf(var10, \"La valeur max est 255\\n\");\n      continue;\n    }\n    RWLOCK_WRITE();\n    var7 = var11;\n    var11 = var3;\n    RWUNLOCK();\n    if (var3 < var7) {\n      for (var6 = var3; var6 < var7; var6++) {\n        pthread_join(var4[var6], NULL);\n      }\n    } else if (var3 > var7) {\n      for (var6 = var7; var6 < var3; var6++) {\n        pthread_create(&(var4[var6]), NULL, var12, &(var5[var6]));\n      }\n    }\n  }\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 56913, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  RWLOCK_WRITE () ; \n int /*<<< orphan*/  RWUNLOCK () ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; \n scalar_t__ fscanf (int /*<<< orphan*/ ,char*,int*) ; \n int /*<<< orphan*/  printf (char*) ; \n int /*<<< orphan*/  pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int*) ; \n int /*<<< orphan*/  pthread_join (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  var10 ; \n int var11 ; \n int /*<<< orphan*/  var12 ; \n scalar_t__ var8 ; \n int /*<<< orphan*/  var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint *collect_entries(const char *a1, unsigned int a2) {\n  int *v2;\n  int *v3;\n  int *v4;\n  struct dirent *v5;\n  long long v6;\n  long long v7;\n  __m128 *v8;\n  uint64_t *v9;\n  int v10;\n  __m128 *v13;\n  char *v14;\n  char *v15[9];\n  v15[1] = (char *)__readfsqword(40u);\n  v2 = opendir(a1);\n  if (!v2) return 0LL;\n  v3 = v2;\n  v4 = (int *)directory_new();\n  while (1) {\n    v5 = readdir(v3);\n    if (!v5) break;\n    while (1) {\n      LODWORD(v6) = strcmp((const char *)v5->d_ino, \".\");\n      if (!v6) break;\n      LODWORD(v7) = strcmp((const char *)v5->d_ino, \"..\");\n      if (!v7) break;\n      asprintf(&v14, \"%s\", (const char *)v5->d_ino);\n      asprintf(v15, \"%s\", a1);\n      v8 = (__m128 *)entry_new();\n      *v8 = _mm_loadh_ps((const double *)v15);\n      v8[1].m128_i32[0] = v5->d_off == DT_DIR;\n      if (a2) {\n        v13 = v8;\n        populate_entry_details(v8, a2);\n        v8 = v13;\n      }\n      v9 = (uint64_t *)*((uint64_t *)v4 + 1);\n      v10 = *v4;\n      v9[*v4 - 1] = v8;\n      *v4 = ++v10;\n      *((uint64_t *)v4 + 1) = realloc(v9, (unsigned int)(24 * v10));\n      v5 = readdir(v3);\n      if (!v5) goto LABEL_9;\n    }\n  }\nLABEL_9:\n  closedir(v3);\n  return v4;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 *collect_entries(const char *var1, type2 var2) {\n  struct type3 *var3;\n  type4 *var4 = opendir(var1);\n  if (var4 == NULL) {\n    return NULL;\n  }\n  type1 *var5 = directory_new();\n  while ((var3 = readdir(var4)) != NULL) {\n    if (strcmp(var3->field1, \".\") == 0 || strcmp(var3->field1, \"..\") == 0) {\n      continue;\n    }\n    char *var6, *var7;\n    asprintf(&var6, \"%s\", var3->field1);\n    asprintf(&var7, \"%s\", var1);\n    type5 *var8 = entry_new();\n    var8->field2 = var6;\n    var8->field3 = var7;\n    var8->field4 = (var3->field5 == var9 ? 1 : 0);\n    if (var2) {\n      populate_entry_details(var8, var2);\n    }\n    var5->field6[var5->field7 - 1] = var8;\n    var5->field7++;\n    var5->field6 = realloc(var5->field6, var5->field7 * sizeof(var10));\n  }\n  closedir(var4);\n  return var5;\n}", "style": "rule"}, "extra_info": {"index": 77991, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var10 ;\nstruct TYPE_9__ {char* field2; char* field3; int field4; } ;\ntypedef  TYPE_1__ type5 ;\ntypedef  int /*<<< orphan*/  type4 ;\ntypedef  int /*<<< orphan*/  type2 ;\nstruct TYPE_10__ {int field7; TYPE_1__** field6; } ;\ntypedef  TYPE_2__ type1 ;\nstruct type3 {char const* field1; scalar_t__ field5; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  asprintf (char**,char*,char const*) ; \n int /*<<< orphan*/  closedir (int /*<<< orphan*/ *) ; \n TYPE_2__* directory_new () ; \n TYPE_1__* entry_new () ; \n int /*<<< orphan*/ * opendir (char const*) ; \n int /*<<< orphan*/  populate_entry_details (TYPE_1__*,int /*<<< orphan*/ ) ; \n struct type3* readdir (int /*<<< orphan*/ *) ; \n TYPE_1__** realloc (TYPE_1__**,int) ; \n scalar_t__ strcmp (char const*,char*) ; \n scalar_t__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  const char **v4;\n  int v5;\n  int i;\n  int j;\n  v5 = argc;\n  v4 = argv;\n  for (i = 0; i < argc; ++i) {\n    printf(\"i = %d; \", i);\n    printf(\"argv [ %d ] = %s;\\n\", i, argv[i]);\n  }\n  for (j = 0; j < argc; ++j) {\n    printf(\"* ( argv + %d ) = %s;\\n\", j, argv[j]);\n    printf(\"* ( ( argv + %d ) + %d ) = %c;\\n\", j, 2, argv[j + 2]);\n  }\n  while (v5 > 0) {\n    printf(\"argc = %d;\", v5);\n    printf(\" i = %d;\", j);\n    printf(\" * argv = %s;\", *v4);\n    printf(\" argv [ %d ] = %s;\", j, v4[j]);\n    putchar(10);\n    ++j;\n    --v5;\n    ++v4;\n  }\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char* var2[]) {\n  int var3 = 0;\n  int var4 = 2;\n  while (var3 < var1) {\n    printf(\"i = %d; \", var3);\n    printf(\"argv [ %d ] = %s;\\n\", var3, var2[var3]);\n    var3++;\n  }\n  var3 = 0;\n  while (var3 < var1) {\n    printf(\"* ( argv + %d ) = %s;\\n\", var3, *(var2 + var3));\n    printf(\"* ( ( argv + %d ) + %d ) = %c;\\n\", var3, var4,\n           *((var2 + var3) + var4));\n    var3++;\n  }\n  while (var1 > 0) {\n    printf(\"argc = %d;\", var1);\n    printf(\" i = %d;\", var3);\n    printf(\" * argv = %s;\", *var2);\n    printf(\" argv [ %d ] = %s;\", var3, var2[var3]);\n    printf(\"\\n\");\n    var3++;\n    var1--;\n    *var2++;\n  }\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 87208, "split": "train", "header": null}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long init_recursive_mutex(pthread_mutex_t *mutex) {\n  pthread_mutexattr_t attr;\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n  pthread_mutex_init(mutex, &attr);\n  pthread_mutexattr_destroy(&attr);\n  return v3 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static inline void init_recursive_mutex(type1 *var1) {\n  type2 var2;\n  pthread_mutexattr_init(&var2);\n  pthread_mutexattr_settype(&var2, var3);\n  pthread_mutex_init(var1, &var2);\n  pthread_mutexattr_destroy(&var2);\n}", "style": "rule"}, "extra_info": {"index": 45874, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  pthread_mutexattr_destroy (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  pthread_mutexattr_init (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  pthread_mutexattr_settype (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var3 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t *cl_pool_clear(long long a1) {\n  uint64_t *result;\n  uint64_t *v2;\n  uint64_t *v3;\n  result = *(uint64_t **)a1;\n  if (*(uint64_t *)a1) {\n    v2 = *(uint64_t **)(a1 + 8);\n    while (1) {\n      v3 = (uint64_t *)*result;\n      *result = v2;\n      v2 = result;\n      *(uint64_t *)(a1 + 8) = result;\n      if (!v3) break;\n      result = v3;\n    }\n  }\n  *(uint64_t *)a1 = 0LL;\n  *(uint64_t *)(a1 + 16) = 0LL;\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void cl_pool_clear(struct type1 *var1) {\n  void **var2 = var1->field1;\n  while (var2) {\n    void **var3 = var2;\n    var2 = *var2;\n    *var3 = var1->field2;\n    var1->field2 = var3;\n  }\n  var1->field1 = NULL;\n  var1->field3 = NULL;\n}", "style": "rule"}, "extra_info": {"index": 34514, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {void** field1; void** field2; int /*<<< orphan*/ * field3; } ;\n\n/* Variables and functions */\n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long pci_xhci_cmd_address_device(long long a1, unsigned int a2,\n                                      uint32_t *a3) {\n  long long v4;\n  int *dest;\n  long long v6;\n  v4 = XHCI_GADDR(a1, *a3 & 4294967280);\n  DPRINTF(*(int *)(*(uint64_t *)(v4 + 16) + 40LL));\n  if (!*(uint64_t *)v4 && (*(uint32_t *)(v4 + 8) & 3) == 3) {\n    dest = (int *)pci_xhci_get_dev_ctx(a1, a2);\n    DPRINTF(*dest);\n    v6 = XHCI_SLOTDEV_PTR(a1, a2);\n    assert(v6 != 0);\n  }\n  DPRINTF(\"pci_xhci: address device, input ctl invalid\\r\\n\");\n  return (unsigned int)XHCI_TRB_ERROR_TRB;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static uint32_t pci_xhci_cmd_address_device(struct type1 *var1, uint32_t var2,\n                                            struct type2 *var3) {\n  struct type3 *var4;\n  struct type4 *var5;\n  struct type5 *var6;\n  struct type6 *var7;\n  struct type7 *var8;\n  uint32_t var9;\n  var5 = XHCI_GADDR(var1, var3->field1 & ~0xFUL);\n  var6 = &var5->field2;\n  var8 = &var5->field3[1];\n  var9 = var10;\n  DPRINTF(\n      (\"pci_xhci: address device, input ctl: D 0x%08x A 0x%08x,\\r\\n\"\n       \"          slot %08x %08x %08x %08x\\r\\n\"\n       \"          ep0  %08x %08x %016lx %08x\\r\\n\",\n       var5->field4.field5, var5->field4.field6, var6->field7, var6->field8,\n       var6->field9, var6->field10, var8->field11, var8->field12, var8->field13,\n       var8->field14));\n  if ((var5->field4.field5 != 0) || (var5->field4.field6 & 0x03) != 0x03) {\n    DPRINTF((\"pci_xhci: address device, input ctl invalid\\r\\n\"));\n    var9 = var11;\n    goto done;\n  }\n  var7 = pci_xhci_get_dev_ctx(var1, var2);\n  DPRINTF(\n      (\"pci_xhci: address device, dev ctx\\r\\n\"\n       \"          slot %08x %08x %08x %08x\\r\\n\",\n       var7->field2.field7, var7->field2.field8, var7->field2.field9,\n       var7->field2.field10));\n  var4 = XHCI_SLOTDEV_PTR(var1, var2);\n  assert(var4 != NULL);\n  var4->field15.field16 = var2;\n  var4->field17 = var7;\n  if (var4->field18->field19 == NULL ||\n      var4->field18->field19(var4->field20) < 0) {\n    var9 = var12;\n    goto done;\n  }\n  memcpy(&var7->field2, var6, sizeof(struct type5));\n  var7->field2.field10 = func1(var13) | func2(var2);\n  memcpy(&var7->field3[1], var8, sizeof(struct type7));\n  var8 = &var7->field3[1];\n  var8->field11 = (var8->field11 & ~0x7) | func3(var14);\n  func4(var4, 1);\n  var4->field21 = var15;\n  DPRINTF(\n      (\"pci_xhci: address device, output ctx\\r\\n\"\n       \"          slot %08x %08x %08x %08x\\r\\n\"\n       \"          ep0  %08x %08x %016lx %08x\\r\\n\",\n       var7->field2.field7, var7->field2.field8, var7->field2.field9,\n       var7->field2.field10, var8->field11, var8->field12, var8->field13,\n       var8->field14));\ndone:\n  return (var9);\n}", "style": "rule"}, "extra_info": {"index": 38104, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint32_t ;\nstruct type7 {int field10; int field11; int /*<<< orphan*/  field14; int /*<<< orphan*/  field13; int /*<<< orphan*/  field12; int /*<<< orphan*/  field9; int /*<<< orphan*/  field8; int /*<<< orphan*/  field7; } ;\nstruct type6 {struct type7 field2; struct type7* field3; } ;\nstruct type5 {int field10; int field11; int /*<<< orphan*/  field14; int /*<<< orphan*/  field13; int /*<<< orphan*/  field12; int /*<<< orphan*/  field9; int /*<<< orphan*/  field8; int /*<<< orphan*/  field7; } ;\nstruct TYPE_4__ {scalar_t__ field5; int field6; } ;\nstruct type4 {TYPE_1__ field4; struct type7* field3; struct type7 field2; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  field16; } ;\nstruct type3 {int /*<<< orphan*/  field21; int /*<<< orphan*/  field20; TYPE_3__* field18; struct type6* field17; TYPE_2__ field15; } ;\nstruct type2 {int field1; } ;\nstruct type1 {int dummy; } ;\nstruct TYPE_6__ {scalar_t__ (* field19 ) (int /*<<< orphan*/ ) ;} ;\n\n/* Variables and functions */\n int /*<<< orphan*/  DPRINTF (char*) ; \n struct type4* XHCI_GADDR (struct type1*,int) ; \n struct type3* XHCI_SLOTDEV_PTR (struct type1*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  assert (int /*<<< orphan*/ ) ; \n int func1 (int /*<<< orphan*/ ) ; \n int func2 (int /*<<< orphan*/ ) ; \n int func3 (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  func4 (struct type3*,int) ; \n int /*<<< orphan*/  memcpy (struct type7*,struct type7*,int) ; \n struct type6* pci_xhci_get_dev_ctx (struct type1*,int /*<<< orphan*/ ) ; \n scalar_t__ stub1 (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n int /*<<< orphan*/  var13 ; \n int /*<<< orphan*/  var14 ; \n int /*<<< orphan*/  var15 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long BIO_gets(long long a1, long long a2, int a3, long long a4,\n                   long long a5) {\n  uint64_t *v5;\n  unsigned long long v6;\n  long long result;\n  unsigned long long v8;\n  bool v9;\n  long long v10;\n  uint64_t v11[5];\n  v11[1] = __readfsqword(40u);\n  v11[0] = 0LL;\n  if (!a1 || (v5 = *(uint64_t **)(a1 + 16)) == 0LL || !*v5) {\n    BIOerr((unsigned int)BIO_F_BIO_GETS,\n           (unsigned int)BIO_R_UNSUPPORTED_METHOD);\n    return 4294967294LL;\n  }\n  v6 = a3;\n  if (a3 < 0) {\n    BIOerr((unsigned int)BIO_F_BIO_GETS, (unsigned int)BIO_R_INVALID_ARGUMENT);\n    return 0LL;\n  }\n  if (!*(uint64_t *)(a1 + 8) && !*(uint64_t *)a1 ||\n      (result = bio_call_callback(a1, (unsigned int)BIO_CB_GETS, a2,\n                                  (unsigned int)a3, 0LL, 0LL, 1LL, 0LL),\n       a5 = v10, (int)result > 0)) {\n    if (!*(uint32_t *)(a1 + 24)) {\n      BIOerr((unsigned int)BIO_F_BIO_GETS, (unsigned int)BIO_R_UNINITIALIZED);\n      return 4294967294LL;\n    }\n    result = (**(long long (***)(long long, long long, uint64_t, long long,\n                                 long long))(a1 + 16))(a1, a2, (unsigned int)v6,\n                                                       a4, a5);\n    if ((int)result > 0) {\n      v8 = (int)result;\n      v9 = *(uint64_t *)(a1 + 8) == 0LL;\n      result = 1LL;\n      v11[0] = v8;\n      if (v9 && !*(uint64_t *)a1) {\n      LABEL_12:\n        result = 4294967295LL;\n        if (v6 >= v8) return (unsigned int)v8;\n        return result;\n      }\n    LABEL_10:\n      result = bio_call_callback(a1, BIO_CB_RETURN | (unsigned int)BIO_CB_GETS,\n                                 a2, (unsigned int)v6, 0LL, 0LL, result, v11);\n      if ((int)result <= 0) return result;\n      v8 = v11[0];\n      goto LABEL_12;\n    }\n    if (*(uint64_t *)(a1 + 8) || *(uint64_t *)a1) goto LABEL_10;\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int BIO_gets(type1 *var1, char *var2, int var3) {\n  int var4;\n  size_t var5 = 0;\n  if ((var1 == NULL) || (var1->field1 == NULL) ||\n      (var1->field1->field2 == NULL)) {\n    BIOerr(var6, var7);\n    return -2;\n  }\n  if (var3 < 0) {\n    BIOerr(var6, var8);\n    return 0;\n  }\n  if (var1->field3 != NULL || var1->field4 != NULL) {\n    var4 = (int)bio_call_callback(var1, var9, var2, var3, 0, 0L, 1, NULL);\n    if (var4 <= 0) return var4;\n  }\n  if (!var1->field5) {\n    BIOerr(var6, var10);\n    return -2;\n  }\n  var4 = var1->field1->field2(var1, var2, var3);\n  if (var4 > 0) {\n    var5 = var4;\n    var4 = 1;\n  }\n  if (var1->field3 != NULL || var1->field4 != NULL)\n    var4 = (int)bio_call_callback(var1, var9 | var11, var2, var3, 0, 0L, var4,\n                                  &var5);\n  if (var4 > 0) {\n    if (var5 > (size_t)var3)\n      var4 = -1;\n    else\n      var4 = (int)var5;\n  }\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 9857, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int /*<<< orphan*/ * field4; int /*<<< orphan*/ * field3; TYPE_1__* field1; int /*<<< orphan*/  field5; } ;\ntypedef  TYPE_2__ type1 ;\nstruct TYPE_6__ {int (* field2 ) (TYPE_2__*,char*,int) ;} ;\n\n/* Variables and functions */\n int /*<<< orphan*/  BIOerr (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n scalar_t__ bio_call_callback (TYPE_2__*,int,char*,int,int /*<<< orphan*/ ,long,int,size_t*) ; \n int stub1 (TYPE_2__*,char*,int) ; \n int /*<<< orphan*/  var10 ; \n int var11 ; \n int /*<<< orphan*/  var6 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  var8 ; \n int var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long kvz_get_mvd_coding_cost_cabac(long long a1, uint64_t *a2,\n                                        uint32_t *a3) {\n  int v5;\n  int v6;\n  int v7;\n  int x[2];\n  int v9[2];\n  uint64_t dest[6];\n  dest[5] = __readfsqword(40u);\n  *(uint64_t *)x = *a2;\n  *(uint64_t *)v9 = a2[1];\n  v5 = *a2 != 0LL;\n  v6 = abs(*a2);\n  v7 = abs(v9[0]);\n  memcpy(dest, a3, 32uLL);\n  LODWORD(dest[0]) = 1;\n  dest[3] = dest[2];\n  kvz_cabac_encode_bin(dest, *(uint64_t *)x != 0LL);\n  kvz_cabac_encode_bin(dest, *(uint64_t *)v9 != 0LL);\n  dest[3] = dest[2] + 4LL;\n  if (v5) kvz_cabac_encode_bin(dest, v6 > 1);\n  if (*(uint64_t *)v9) kvz_cabac_encode_bin(dest, v7 > 1);\n  if (v5) {\n    if (v6 > 1)\n      kvz_cabac_write_ep_ex_golomb(a1, dest, (unsigned int)(v6 - 2), 1LL);\n    kvz_cabac_encode_bin_ep(dest, *(uint64_t *)x <= 0LL);\n  }\n  if (*(uint64_t *)v9) {\n    if (v7 > 1)\n      kvz_cabac_write_ep_ex_golomb(a1, dest, (unsigned int)(v7 - 2), 1LL);\n    kvz_cabac_encode_bin_ep(dest, *(uint64_t *)v9 <= 0LL);\n  }\n  return (unsigned int)(8 * LODWORD(dest[1]) - HIDWORD(dest[0]) -\n                        (8 * a3[2] - a3[1]));\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "uint32_t kvz_get_mvd_coding_cost_cabac(type1 *const var1, type2 *var2,\n                                       const type3 *var3) {\n  uint32_t var4 = 0;\n  const int32_t var5 = var2->field1;\n  const int32_t var6 = var2->field2;\n  const int8_t var7 = var5 != 0;\n  const int8_t var8 = var6 != 0;\n  const uint32_t var9 = abs(var5);\n  const uint32_t var10 = abs(var6);\n  type3 var11;\n  memcpy(&var11, var3, sizeof(var12));\n  type3 *var13 = &var11;\n  var13->field3 = 1;\n  var13->field4 = &(var13->field5.field6[0]);\n  kvz_cabac_encode_bin((var13), ((var5 != 0)));\n  ;\n  kvz_cabac_encode_bin((var13), ((var6 != 0)));\n  ;\n  var13->field4 = &(var13->field5.field6[1]);\n  if (var7) {\n    kvz_cabac_encode_bin((var13), ((var9 > 1)));\n    ;\n  }\n  if (var8) {\n    kvz_cabac_encode_bin((var13), ((var10 > 1)));\n    ;\n  }\n  if (var7) {\n    if (var9 > 1) {\n      kvz_cabac_write_ep_ex_golomb(var1, var13, var9 - 2, 1);\n    }\n    kvz_cabac_encode_bin_ep((var13), ((var5 > 0) ? 0 : 1));\n    ;\n  }\n  if (var8) {\n    if (var10 > 1) {\n      kvz_cabac_write_ep_ex_golomb(var1, var13, var10 - 2, 1);\n    }\n    kvz_cabac_encode_bin_ep((var13), ((var6 > 0) ? 0 : 1));\n    ;\n  }\n  var4 = ((23 - var13->field7) + (var13->field8 << 3)) -\n         ((23 - var3->field7) + (var3->field8 << 3));\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 57170, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var12 ;\ntypedef  int uint32_t ;\nstruct TYPE_11__ {int /*<<< orphan*/ * field6; } ;\nstruct TYPE_12__ {int field3; int field7; int field8; TYPE_1__ field5; int /*<<< orphan*/ * field4; } ;\ntypedef  TYPE_2__ type3 ;\nstruct TYPE_13__ {scalar_t__ field1; scalar_t__ field2; } ;\ntypedef  TYPE_3__ type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\ntypedef  int int8_t ;\ntypedef  scalar_t__ int32_t ;\n\n/* Variables and functions */\n int abs (scalar_t__ const) ; \n int /*<<< orphan*/  kvz_cabac_encode_bin (TYPE_2__*,int) ; \n int /*<<< orphan*/  kvz_cabac_encode_bin_ep (TYPE_2__*,int) ; \n int /*<<< orphan*/  kvz_cabac_write_ep_ex_golomb (int /*<<< orphan*/ * const,TYPE_2__*,int const,int) ; \n int /*<<< orphan*/  memcpy (TYPE_2__*,TYPE_2__ const*,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t *doconst(uint64_t **a1, long long a2, long long a3, long long a4,\n                  long long a5, long long a6) {\n  long long v6;\n  long long v7;\n  long long v8;\n  uint64_t *result;\n  result = *a1;\n  if (*a1) assert(*result == 0LL, a2, a3, a4, a5, a6, v6, v7, v8);\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void doconst(type1 var1, void *var2) {\n  if (var1->field1.field2.field3) {\n    assert(var1->field1.field2.field3->field1.field4 == 0);\n    func1(var1->field1.field2.field3, var3);\n    if (func2(var1->field5) && var1->field5->field5 == var4) {\n      unsigned int *var5 = var1->field1.field2.field6.field7;\n      int var6 = var1->field5->field8 / var4->field8;\n      while (var6-- > 0) {\n        type2 var7;\n        var7.field1 = *var5++;\n        (*var8->field9)(var4->field10, var4->field8, var7);\n      }\n    } else if (func2(var1->field5))\n      (*var8->field11)(var1->field5->field8, var1->field1.field2.field6.field7);\n    else\n      (*var8->field9)(var1->field5->field10, var1->field5->field8,\n                      var1->field1.field2.field6);\n    var1->field1.field2.field3 = NULL;\n  }\n}", "style": "rule"}, "extra_info": {"index": 15452, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_21__   TYPE_7__ ;\ntypedef  struct TYPE_20__   TYPE_6__ ;\ntypedef  struct TYPE_19__   TYPE_5__ ;\ntypedef  struct TYPE_18__   TYPE_4__ ;\ntypedef  struct TYPE_17__   TYPE_3__ ;\ntypedef  struct TYPE_16__   TYPE_2__ ;\ntypedef  struct TYPE_15__   TYPE_1__ ;\ntypedef  struct TYPE_14__   TYPE_11__ ;\ntypedef  struct TYPE_13__   TYPE_10__ ;\n\n/* Type definitions */\nstruct TYPE_18__ {unsigned int* field7; int /*<<< orphan*/  field1; } ;\ntypedef  TYPE_4__ type2 ;\ntypedef  TYPE_5__* type1 ;\nstruct TYPE_21__ {int field8; int /*<<< orphan*/  field10; } ;\nstruct TYPE_20__ {int /*<<< orphan*/  (* field9 ) (int /*<<< orphan*/ ,int,TYPE_4__) ;int /*<<< orphan*/  (* field11 ) (int,unsigned int*) ;} ;\nstruct TYPE_16__ {TYPE_11__* field3; TYPE_4__ field6; } ;\nstruct TYPE_17__ {TYPE_2__ field2; } ;\nstruct TYPE_19__ {TYPE_3__ field1; TYPE_10__* field5; } ;\nstruct TYPE_15__ {scalar_t__ field4; } ;\nstruct TYPE_14__ {TYPE_1__ field1; } ;\nstruct TYPE_13__ {int field8; int /*<<< orphan*/  field10; TYPE_7__* field5; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  assert (int) ; \n int /*<<< orphan*/  func1 (TYPE_11__*,int /*<<< orphan*/ ) ; \n scalar_t__ func2 (TYPE_10__*) ; \n int /*<<< orphan*/  stub1 (int /*<<< orphan*/ ,int,TYPE_4__) ; \n int /*<<< orphan*/  stub2 (int,unsigned int*) ; \n int /*<<< orphan*/  stub3 (int /*<<< orphan*/ ,int,TYPE_4__) ; \n int /*<<< orphan*/  var3 ; \n TYPE_7__* var4 ; \n TYPE_6__* var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long nv94_aux(unsigned int *a1, int a2, unsigned int a3, void *a4,\n                   unsigned int a5) {\n  unsigned int v10;\n  int v11;\n  int j;\n  unsigned int v13;\n  int i;\n  int k;\n  unsigned int v16;\n  int v17;\n  long long v18;\n  uint64_t dest[5];\n  dest[3] = __readfsqword(40u);\n  v18 = nouveau_i2c(a1);\n  dest[0] = 0LL;\n  dest[1] = 0LL;\n  v16 = *a1;\n  AUX_DBG(\"%d: 0x%08x %d\\n\", a2, a3, a5);\n  v13 = auxch_init(v18, v16);\n  if (!v13) {\n    if ((nv_rd32(v18, 80 * v16 + 58600) & 268435456) != 0) {\n      if ((a2 & 1) == 0) {\n        memcpy(dest, a4, a5);\n        for (i = 0; i <= 15; i += 4) {\n          AUX_DBG(\"wr 0x%08x\\n\", *((uint32_t *)dest + i / 4));\n          nv_wr32(v18, i + 80 * v16 + 58560, *((unsigned int *)dest + i / 4));\n        }\n      }\n      v10 = (a5 - 1) | (a2 << 12) | nv_rd32(v18, 80 * v16 + 58596) & 4294840064;\n      nv_wr32(v18, 80 * v16 + 58592, a3);\n      v13 = -EREMOTEIO;\n      for (j = 0; j <= 31; ++j) {\n        nv_wr32(v18, 80 * v16 + 58596, v10 | 2147483648);\n        nv_wr32(v18, 80 * v16 + 58596, v10);\n        if (j) udelay(400LL);\n        nv_wr32(v18, 80 * v16 + 58596, v10 | 65536);\n        v11 = 1000;\n        do {\n          v10 = nv_rd32(v18, 80 * v16 + 58596);\n          udelay(1LL);\n          if (!v11--) {\n            AUX_ERR(\"tx req timeout 0x%08x\\n\", v10);\n            goto LABEL_24;\n          }\n        } while ((v10 & 65536) != 0);\n        v17 = nv_mask(v18, 80 * v16 + 58600, 0LL, 0LL);\n        if ((v17 & 986880) == 0) {\n          v13 = 0;\n          break;\n        }\n        AUX_DBG(\"%02d 0x%08x 0x%08x\\n\", j, v10, v17);\n      }\n      if ((a2 & 1) != 0) {\n        for (k = 0; k <= 15; k += 4) {\n          *((uint32_t *)dest + k / 4) = nv_rd32(v18, k + 80 * v16 + 58576);\n          AUX_DBG(\"rd 0x%08x\\n\", *((uint32_t *)dest + k / 4));\n        }\n        memcpy(a4, dest, a5);\n      }\n    } else {\n      AUX_DBG(\"sink not detected\\n\");\n      v13 = -ENXIO;\n    }\n  }\nLABEL_24:\n  auxch_fini(v18, v16);\n  return v13;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int nv94_aux(struct type1 *var1, type2 var2, type3 var3, type2 *var4,\n             type2 var5) {\n  struct type4 *var6 = nouveau_i2c(var1);\n  struct type5 *var7 = (void *)var1;\n  type3 var8, var9, var10, var11;\n  type3 var12[4] = {};\n  int var13 = var7->field1;\n  int var14, var15;\n  AUX_DBG(\"%d: 0x%08x %d\\n\", var2, var3, var5);\n  var14 = auxch_init(var6, var13);\n  if (var14) goto out;\n  var9 = nv_rd32(var6, 0x00e4e8 + (var13 * 0x50));\n  if (!(var9 & 0x10000000)) {\n    AUX_DBG(\"sink not detected\\n\");\n    var14 = -var16;\n    goto out;\n  }\n  if (!(var2 & 1)) {\n    memcpy(var12, var4, var5);\n    for (var15 = 0; var15 < 16; var15 += 4) {\n      AUX_DBG(\"wr 0x%08x\\n\", var12[var15 / 4]);\n      nv_wr32(var6, 0x00e4c0 + (var13 * 0x50) + var15, var12[var15 / 4]);\n    }\n  }\n  var8 = nv_rd32(var6, 0x00e4e4 + (var13 * 0x50));\n  var8 &= ~0x0001f0ff;\n  var8 |= var2 << 12;\n  var8 |= var5 - 1;\n  nv_wr32(var6, 0x00e4e0 + (var13 * 0x50), var3);\n  var14 = -var17;\n  for (var11 = 0; var11 < 32; var11++) {\n    nv_wr32(var6, 0x00e4e4 + (var13 * 0x50), 0x80000000 | var8);\n    nv_wr32(var6, 0x00e4e4 + (var13 * 0x50), 0x00000000 | var8);\n    if (var11) udelay(400);\n    nv_wr32(var6, 0x00e4e4 + (var13 * 0x50), 0x00010000 | var8);\n    var10 = 1000;\n    do {\n      var8 = nv_rd32(var6, 0x00e4e4 + (var13 * 0x50));\n      udelay(1);\n      if (!var10--) {\n        AUX_ERR(\"tx req timeout 0x%08x\\n\", var8);\n        goto out;\n      }\n    } while (var8 & 0x00010000);\n    var9 = nv_mask(var6, 0x00e4e8 + (var13 * 0x50), 0, 0);\n    if (!(var9 & 0x000f0f00)) {\n      var14 = 0;\n      break;\n    }\n    AUX_DBG(\"%02d 0x%08x 0x%08x\\n\", var11, var8, var9);\n  }\n  if (var2 & 1) {\n    for (var15 = 0; var15 < 16; var15 += 4) {\n      var12[var15 / 4] = nv_rd32(var6, 0x00e4d0 + (var13 * 0x50) + var15);\n      AUX_DBG(\"rd 0x%08x\\n\", var12[var15 / 4]);\n    }\n    memcpy(var4, var12, var5);\n  }\nout:\n  auxch_fini(var6, var13);\n  return var14;\n}", "style": "rule"}, "extra_info": {"index": 104428, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int type3 ;\ntypedef  int type2 ;\nstruct type5 {int field1; } ;\nstruct type4 {int dummy; } ;\nstruct type1 {int dummy; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  AUX_DBG (char*,...) ; \n int /*<<< orphan*/  AUX_ERR (char*,int) ; \n int /*<<< orphan*/  auxch_fini (struct type4*,int) ; \n int auxch_init (struct type4*,int) ; \n int /*<<< orphan*/  memcpy (int*,int*,int) ; \n struct type4* nouveau_i2c (struct type1*) ; \n int nv_mask (struct type4*,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int nv_rd32 (struct type4*,int) ; \n int /*<<< orphan*/  nv_wr32 (struct type4*,int,int) ; \n int /*<<< orphan*/  udelay (int) ; \n int var16 ; \n int var17 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long sig_handle(int a1, long long a2) {\n  uint64_t v3[2];\n  uint64_t v4[2];\n  v4[1] = __readfsqword(40u);\n  v3[0] = a2;\n  sigemptyset((sigset_t *)v4);\n  v3[1] = 0LL;\n  if (sigaction(a1, (const struct sigaction *)v3, 0LL) == -1)\n    return 4294967295LL;\n  else\n    return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int sig_handle(int var1, void (*var2)(int)) {\n  struct type1 var3;\n  var3.field1 = var2;\n  sigemptyset(&var3.field2);\n  var3.field3 = 0;\n  if (sigaction(var1, &var3, NULL) == -1) {\n    return -1;\n  }\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 90536, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {void (* field1 ) (int) ;scalar_t__ field3; int /*<<< orphan*/  field2; } ;\n\n/* Variables and functions */\n int sigaction (int,struct type1*,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  sigemptyset (int /*<<< orphan*/ *) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nssize_t _stdio_read(long long a1, char *a2, ssize_t a3) {\n  unsigned int v6;\n  void *v7;\n  int v8;\n  ssize_t result;\n  unsigned int iov_len;\n  char *v11;\n  bool v12;\n  struct iovec v13;\n  void *v14;\n  unsigned int v15;\n  unsigned long long v16;\n  v6 = *(uint64_t *)a1;\n  v16 = __readfsqword(40u);\n  v13.iov_base = a2;\n  v7 = *(void **)(a1 + 8);\n  v15 = v6;\n  v8 = *(uint32_t *)(a1 + 40);\n  v14 = v7;\n  v13.iov_len = (v6 == 0) + a3 - 1;\n  if ((v6 == 0) + a3 != 1) {\n    result = readv(v8, &v13, 2);\n    if (result > 0) goto LABEL_3;\n  LABEL_8:\n    *(uint32_t *)(a1 + 16) |= result == 0 ? 16 : 32;\n    return 0LL;\n  }\n  result = read(v8, v7, v6);\n  if (result <= 0) goto LABEL_8;\nLABEL_3:\n  iov_len = v13.iov_len;\n  if ((long long)v13.iov_len < result) {\n    v11 = *(char **)(a1 + 8);\n    v12 = *(uint64_t *)a1 == 0LL;\n    *(uint64_t *)(a1 + 24) = v11;\n    *(uint64_t *)(a1 + 32) = &v11[result - iov_len];\n    result = a3;\n    if (!v12) {\n      *(uint64_t *)(a1 + 24) = v11 + 1;\n      a2[a3 - 1] = *v11;\n    }\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "size_t func1(type1 *var1, unsigned char *var2, size_t var3) {\n  struct type2 var4[2] = {{.field1 = var2, .field2 = var3 - !!var1->field3},\n                          {.field1 = var1->field4, .field2 = var1->field3}};\n  ssize_t var5;\n  var5 = var4[0].field2 ? readv(var1->field5, var4, 2)\n                        : read(var1->field5, var4[1].field1, var4[1].field2);\n  if (var5 <= 0) {\n    var1->field6 |= var5 ? 32 : 16;\n    return 0;\n  }\n  if (var5 <= var4[0].field2) return var5;\n  var5 -= var4[0].field2;\n  var1->field7 = var1->field4;\n  var1->field8 = var1->field4 + var5;\n  if (var1->field3) var2[var3 - 1] = *var1->field7++;\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 74134, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ field3; unsigned char* field4; int field6; unsigned char* field7; scalar_t__ field8; int /*<<< orphan*/  field5; } ;\ntypedef  TYPE_1__ type1 ;\nstruct type2 {unsigned char* field1; scalar_t__ field2; } ;\ntypedef  scalar_t__ ssize_t ;\n\n/* Variables and functions */\n scalar_t__ read (int /*<<< orphan*/ ,unsigned char*,scalar_t__) ; \n scalar_t__ readv (int /*<<< orphan*/ ,struct type2*,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long instr_shlqby(uint64_t *a1, long long a2, long long a3, long long a4) {\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  int v16;\n  int v17;\n  int v18;\n  int v19;\n  int v20;\n  int v21;\n  bool v22;\n  int v23;\n  uint32_t v25[16];\n  uint32_t v26[16];\n  uint8_t v27[72];\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  reg_to_byte(a1, v25, a2);\n  reg_to_byte(a1, v26, a3);\n  reg_to_byte(a1, v27, a4);\n  v6 = **(uint32_t **)(*a1 + 8 * a4) & 31;\n  if ((**(uint32_t **)(*a1 + 8 * a4) & 16) == 0) {\n    v7 = v6 + 1;\n    v25[0] = v26[v6];\n    v8 = 0;\n    if (v6 + 1 > 15) goto LABEL_4;\n    goto LABEL_3;\n  }\n  v7 = v6 + 1;\n  v25[0] = 0;\n  v8 = 0;\n  if (v6 + 1 <= 15)\n  LABEL_3:\n    v8 = v26[v7];\nLABEL_4:\n  v25[1] = v8;\n  v9 = 0;\n  if (v6 + 2 <= 15) v9 = v26[v6 + 2];\n  v25[2] = v9;\n  v10 = 0;\n  if (v6 + 3 <= 15) v10 = v26[v6 + 3];\n  v25[3] = v10;\n  v11 = 0;\n  if (v6 + 4 <= 15) v11 = v26[v6 + 4];\n  v25[4] = v11;\n  v12 = 0;\n  if (v6 + 5 <= 15) v12 = v26[v6 + 5];\n  v25[5] = v12;\n  v13 = 0;\n  if (v6 + 6 <= 15) v13 = v26[v6 + 6];\n  v25[6] = v13;\n  v14 = 0;\n  if (v6 + 7 <= 15) v14 = v26[v6 + 7];\n  v25[7] = v14;\n  v15 = 0;\n  if (v6 + 8 <= 15) v15 = v26[v6 + 8];\n  v25[8] = v15;\n  v16 = 0;\n  if (v6 + 9 <= 15) v16 = v26[v6 + 9];\n  v25[9] = v16;\n  v17 = 0;\n  if (v6 + 10 <= 15) v17 = v26[v6 + 10];\n  v25[10] = v17;\n  v18 = 0;\n  if (v6 + 11 <= 15) v18 = v26[v6 + 11];\n  v25[11] = v18;\n  v19 = 0;\n  if (v6 + 12 <= 15) v19 = v26[v6 + 12];\n  v25[12] = v19;\n  v20 = 0;\n  if (v6 + 13 <= 15) v20 = v26[v6 + 13];\n  v25[13] = v20;\n  v21 = 0;\n  if (v6 + 14 <= 15) v21 = v26[v6 + 14];\n  v22 = v6 == 0;\n  v23 = 0;\n  if (v22) v23 = v26[15];\n  v25[14] = v21;\n  v25[15] = v23;\n  ((void (*)(uint64_t *, long long, uint32_t *))byte_to_reg)(a1, a2, v25);\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int instr_shlqby(type1 *var1, uint32_t var2, uint32_t var3, uint32_t var4) {\n  uint8_t var5[16];\n  uint8_t var6[16];\n  uint8_t var7[16];\n  int var8 = 0;\n  reg_to_byte(var1, var5, var2);\n  reg_to_byte(var1, var6, var3);\n  reg_to_byte(var1, var7, var4);\n  (void)*var1;\n  (void)var2;\n  (void)var3;\n  (void)var4;\n  ;\n  {\n    int var9;\n    int var10 = var1->field1[var4][0] & 0x1f;\n    for (var9 = 0; var9 < 16; ++var9)\n      var5[var9] = (var9 + var10) < 16 ? var6[var9 + var10] : 0;\n    func1(var1, var2, var5);\n  }\n  return var8;\n}", "style": "rule"}, "extra_info": {"index": 15507, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  size_t uint32_t ;\nstruct TYPE_5__ {int** field1; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  func1 (TYPE_1__*,size_t,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  reg_to_byte (TYPE_1__*,int /*<<< orphan*/ *,size_t) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long test() {\n  int v0;\n  const char *v1;\n  long long v2;\n  int v3;\n  int i;\n  const char *v5;\n  long long v6;\n  int v8;\n  int v9;\n  const char *v10;\n  unsigned int n;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  char s[32];\n  char s2[24];\n  unsigned long long v17;\n  v0 = 0;\n  v17 = __readfsqword(40u);\n  init_db(&v12, \"localhost\", 8020LL, \"/l0/giga_ldb/l0/\");\n  strcpy(s2, \"hello world\");\n  v10 = 0LL;\n  v8 = 0;\n  do {\n    sprintf(s, \"%010d\", v0);\n    v1 = (const char *)leveldb_get(v13, v12, s, 20LL, &n, &v10);\n    if (v10) goto LABEL_2;\n    LODWORD(v2) = strncmp(v1, s2, n);\n    if (v2 || !n) {\n      printf(\"key=%s\\n\", s);\n    LABEL_2:\n      ++v8;\n    }\n    ++v0;\n  } while (v0 != 1000);\n  v3 = 0;\n  printf(\"Error count = %d\\n\", v8);\n  do {\n    sprintf(s, \"%010d\", v3);\n    leveldb_put(v13, v14, s, 20LL, s2, 20LL, &v10);\n    if (v10) printf(\"Error: %s\\n\", v10);\n    ++v3;\n  } while (v3 != 1000);\n  v9 = 0;\n  for (i = 0; i != 1000; ++i) {\n    while (1) {\n      sprintf(s, \"%010d\", i);\n      v5 = (const char *)leveldb_get(v13, v12, s, 20LL, &n, &v10);\n      if (!v10) {\n        LODWORD(v6) = strncmp(v5, s2, n);\n        if (!v6) {\n          if (n) break;\n        }\n      }\n      ++i;\n      ++v9;\n      if (i == 1000) goto LABEL_18;\n    }\n  }\nLABEL_18:\n  printf(\"Error count = %d\\n\", v9);\n  close_db(&v12);\n  return v17 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void test() {\n  struct type1 var1;\n  init_db(&var1, \"localhost\", 8020, \"/l0/giga_ldb/l0/\");\n  char var2[20];\n  char var3[20];\n  sprintf(var3, \"hello world\");\n  char* var4 = NULL;\n  int var5;\n  int var6 = 1000;\n  int var7 = 0;\n  for (var5 = 0; var5 < var6; ++var5) {\n    sprintf(var2, \"%010d\", var5);\n    size_t var8;\n    char* var9 = leveldb_get(var1.field1, var1.field2, var2, 20, &var8, &var4);\n    if (var4 != NULL) {\n      var7++;\n    } else if (strncmp(var9, var3, var8) != 0 || var8 == 0) {\n      printf(\"key=%s\\n\", var2);\n      var7++;\n    }\n  }\n  printf(\"Error count = %d\\n\", var7);\n  for (var5 = 0; var5 < var6; ++var5) {\n    sprintf(var2, \"%010d\", var5);\n    leveldb_put(var1.field1, var1.field3, var2, 20, var3, 20, &var4);\n    if (var4 != NULL) {\n      printf(\"Error: %s\\n\", var4);\n    }\n  }\n  var7 = 0;\n  for (var5 = 0; var5 < var6; ++var5) {\n    sprintf(var2, \"%010d\", var5);\n    size_t var8;\n    char* var9 = leveldb_get(var1.field1, var1.field2, var2, 20, &var8, &var4);\n    if (var4 != NULL) {\n      var7++;\n    } else if (strncmp(var9, var3, var8) != 0 || var8 == 0) {\n      var7++;\n    }\n  }\n  printf(\"Error count = %d\\n\", var7);\n  close_db(&var1);\n}", "style": "rule"}, "extra_info": {"index": 3180, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {int /*<<< orphan*/  field2; int /*<<< orphan*/  field1; int /*<<< orphan*/  field3; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  close_db (struct type1*) ; \n int /*<<< orphan*/  init_db (struct type1*,char*,int,char*) ; \n char* leveldb_get (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int,size_t*,char**) ; \n int /*<<< orphan*/  leveldb_put (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,int,char*,int,char**) ; \n int /*<<< orphan*/  printf (char*,...) ; \n int /*<<< orphan*/  sprintf (char*,char*,...) ; \n scalar_t__ strncmp (char*,char*,size_t) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long lgdt3306a_power(long long a1, unsigned int a2) {\n  unsigned int v3;\n  dbg_info(\"(%d)\\n\", a2);\n  if (a2) {\n    v3 = lgdt3306a_set_reg_bit(a1, 0LL, 7LL, 1LL);\n    if (!lg_chkerr(v3)) {\n      v3 = lgdt3306a_set_reg_bit(a1, 0LL, 0LL, 1LL);\n      lg_chkerr(v3);\n    }\n  } else {\n    v3 = lgdt3306a_set_reg_bit(a1, 0LL, 7LL, 0LL);\n    if (!lg_chkerr(v3)) {\n      v3 = lgdt3306a_set_reg_bit(a1, 0LL, 0LL, 0LL);\n      lg_chkerr(v3);\n    }\n  }\n  return v3;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int lgdt3306a_power(struct type1 *var1, int var2) {\n  int var3;\n  dbg_info(\"(%d)\\n\", var2);\n  if (var2 == 0) {\n    var3 = lgdt3306a_set_reg_bit(var1, 0x0000, 7, 0);\n    if (lg_chkerr(var3)) goto fail;\n    var3 = lgdt3306a_set_reg_bit(var1, 0x0000, 0, 0);\n    if (lg_chkerr(var3)) goto fail;\n  } else {\n    var3 = lgdt3306a_set_reg_bit(var1, 0x0000, 7, 1);\n    if (lg_chkerr(var3)) goto fail;\n    var3 = lgdt3306a_set_reg_bit(var1, 0x0000, 0, 1);\n    if (lg_chkerr(var3)) goto fail;\n  }\n#ifdef var4\n  func1(var1);\n#endif\nfail:\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 60809, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {int dummy; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  dbg_info (char*,int) ; \n int /*<<< orphan*/  func1 (struct type1*) ; \n scalar_t__ lg_chkerr (int) ; \n int lgdt3306a_set_reg_bit (struct type1*,int,int,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long StartTasks(uint64_t *a1, unsigned int *a2) {\n  unsigned int v3;\n  void *v4;\n  unsigned int v5;\n  void *v6;\n  uint64_t *v7;\n  long long v8;\n  long long v9;\n  unsigned int started;\n  long long v11;\n  unsigned int v12;\n  uint64_t v14[7];\n  v3 = *a2;\n  v14[1] = __readfsqword(40u);\n  v4 = calloc(v3, 8uLL);\n  v5 = *a2;\n  v14[0] = v4;\n  v6 = v4;\n  if (v5) {\n    v7 = v4;\n    v8 = 0LL;\n    do {\n      ++v7;\n      v9 = v8 + *a1;\n      v8 += 4LL;\n      *(v7 - 1) = v9;\n    } while (4 * v5 != v8);\n  }\n  started = StartTasksByPointers(v14, a2);\n  v11 = v14[0];\n  v12 = started;\n  if (v14[0]) {\n    if (v14[0] < (unsigned long long)v6 + 8 * v5)\n      v11 = *(uint64_t *)v14[0];\n    else\n      v11 = 0LL;\n  }\n  *a1 = v11;\n  free(v6);\n  return v12;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int func1(type1** var1, size_t* var2) {\n  type1** var3 = (type1**)calloc(*var2, sizeof(type1*));\n  for (size_t var4 = 0; var4 < *var2; ++var4) {\n    var3[var4] = *var1 + var4;\n  }\n  type1** var5 = var3;\n  size_t var6 = *var2;\n  int var7 = func2(&var3, var2);\n  if (!var3 || var3 >= var5 + var6) {\n    *var1 = NULL;\n  } else {\n    *var1 = *var3;\n  }\n  free(var5);\n  return var7;\n}", "style": "rule"}, "extra_info": {"index": 44857, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n scalar_t__ calloc (size_t,int) ; \n int /*<<< orphan*/  free (int /*<<< orphan*/ **) ; \n int func2 (int /*<<< orphan*/ ***,size_t*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  void *v3;\n  int v5;\n  int v6;\n  int i;\n  int j;\n  int fd;\n  int v10;\n  int v11;\n  int v12;\n  void *buf;\n  void *v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  fd = open(\"foo\", O_CREAT | O_TRUNC, 438LL);\n  close(fd);\n  v3 = malloc(16uLL);\n  addStuff(v3);\n  puts(\"Printing my schedule:\");\n  v10 = open(\"foo\", O_RDONLY);\n  buf = malloc(16uLL);\n  for (i = 1; i <= 10; ++i) {\n    read(v10, buf, 16uLL);\n    printf(\"Period %d: %s\", i, *(const char **)buf);\n  }\n  close(v10);\n  putchar(10);\n  printf(\"Period to retrieve: \");\n  scanf(\"%d\", &v5);\n  v11 = open(\"foo\", O_RDONLY);\n  if (v5 > 0 && v5 <= 10) {\n    lseek(v11, (unsigned int)(16 * (v5 - 1)), SEEK_SET);\n    read(v11, buf, 16uLL);\n    printf(\"Period %d: %s\", *((uint32_t *)buf + 2), *(const char **)buf);\n  }\n  putchar(10);\n  printf(\"Period to turn into a free: \");\n  scanf(\"%d\", &v6);\n  v12 = open(\"foo\", O_RDWR);\n  if (v6 > 0 && v6 <= 10) {\n    lseek(v12, (unsigned int)(16 * (v6 - 1)), SEEK_SET);\n    v14 = malloc(16uLL);\n    strcpy(*(char **)v14, \"Free\\n\");\n    *((uint32_t *)v14 + 2) = v6;\n    write(v12, v14, 16uLL);\n  }\n  lseek(v12, 0LL, SEEK_SET);\n  for (j = 1; j <= 10; ++j) {\n    read(v12, buf, 16uLL);\n    printf(\"Period %d: %s\", j, *(const char **)buf);\n  }\n  putchar(10);\n  close(v12);\n  free(buf);\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main() {\n  int var1 = open(\"foo\", var2 | var3, 0666);\n  close(var1);\n  type1* var4 = malloc(sizeof(var5));\n  addStuff(var4);\n  printf(\"Printing my schedule:\\n\");\n  int var6 = open(\"foo\", var7);\n  var4 = malloc(sizeof(var5));\n  int var8 = 1;\n  while (var8 < 11) {\n    read(var6, var4, sizeof(var5));\n    printf(\"Period %d: %s\", var8, var4->field1);\n    var8++;\n  }\n  close(var6);\n  printf(\"\\n\");\n  int var9;\n  printf(\"Period to retrieve: \");\n  scanf(\"%d\", &var9);\n  int var10 = open(\"foo\", var7);\n  if (var9 > 0 && var9 < 11) {\n    lseek(var10, (var9 - 1) * sizeof(var5), var11);\n    read(var10, var4, sizeof(var5));\n    printf(\"Period %d: %s\", var4->field2, var4->field1);\n  }\n  printf(\"\\n\");\n  int var12;\n  printf(\"Period to turn into a free: \");\n  scanf(\"%d\", &var12);\n  int var13 = open(\"foo\", var14);\n  if (var12 > 0 && var12 < 11) {\n    lseek(var13, (var12 - 1) * sizeof(var5), var11);\n    type1* var15 = malloc(sizeof(var5));\n    strcpy(var15->field1, \"Free\\n\");\n    var15->field2 = var12;\n    write(var13, var15, sizeof(var5));\n  }\n  lseek(var13, 0, var11);\n  int var16 = 1;\n  while (var16 < 11) {\n    read(var13, var4, sizeof(var5));\n    printf(\"Period %d: %s\", var16, var4->field1);\n    var16++;\n  }\n  printf(\"\\n\");\n  close(var13);\n  free(var4);\n}", "style": "rule"}, "extra_info": {"index": 40698, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var5 ;\nstruct TYPE_7__ {char* field1; int field2; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  addStuff (TYPE_1__*) ; \n int /*<<< orphan*/  close (int) ; \n int /*<<< orphan*/  free (TYPE_1__*) ; \n int /*<<< orphan*/  lseek (int,int,int /*<<< orphan*/ ) ; \n TYPE_1__* malloc (int) ; \n int open (char*,int,...) ; \n int /*<<< orphan*/  printf (char*,...) ; \n int /*<<< orphan*/  read (int,TYPE_1__*,int) ; \n int /*<<< orphan*/  scanf (char*,int*) ; \n int /*<<< orphan*/  strcpy (char*,char*) ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var14 ; \n int var2 ; \n int var3 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  write (int,TYPE_1__*,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid *ms_copy_int32(int a1, const void *a2) {\n  void *dest;\n  dest = malloc((unsigned int)(4 * a1));\n  memcpy(dest, a2, 4LL * a1);\n  return dest;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int32_t* ms_copy_int32(uint32_t var1, const int32_t* var2) {\n  size_t var3 = var1 * sizeof(int32_t);\n  int32_t* var4 = (int32_t*)malloc(var1 * sizeof(int32_t));\n  memcpy(var4, var2, var3);\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 13865, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint32_t ;\ntypedef  int /*<<< orphan*/  int32_t ;\n\n/* Variables and functions */\n scalar_t__ malloc (int) ; \n int /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,size_t) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid maybe_change_configuration(long long a1) {\n  int v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long *v10;\n  long long v11;\n  if (*(uint64_t *)a1) {\n    v2 = *(uint32_t *)(a1 + 8);\n    v3 = *(uint64_t *)(a1 + 32);\n    if (v2 <= 0) {\n      *(uint32_t *)(a1 + 24) = 0;\n    } else {\n      v4 = *(uint64_t *)(a1 + 16);\n      v5 = 0LL;\n      do {\n        v6 = *(uint64_t *)(v4 + 8 * v5);\n        if (v6 != PMC_NO_INDEX && v6 != **(uint64_t **)(v3 + 8 * v5)) {\n          alpha_perf_event_update(*(uint64_t *)(v3 + 8 * v5),\n                                  *(uint64_t *)(v3 + 8 * v5), v6, 0LL);\n          v4 = *(uint64_t *)(a1 + 16);\n          v2 = *(uint32_t *)(a1 + 8);\n          v3 = *(uint64_t *)(a1 + 32);\n          *(uint64_t *)(v4 + 8 * v5) = PMC_NO_INDEX;\n        }\n        ++v5;\n      } while (v2 > (int)v5);\n      *(uint32_t *)(a1 + 24) = 0;\n      if (v2 > 0) {\n        v7 = v4;\n        v8 = 0LL;\n        do {\n          v9 = *(uint64_t *)(v7 + 8 * v8);\n          v10 = *(long long **)(v3 + 8 * v8);\n          if (v9 == PMC_NO_INDEX) {\n            v11 = *v10;\n            alpha_perf_event_set_period(*(uint64_t *)(v3 + 8 * v8),\n                                        *(uint64_t *)(v3 + 8 * v8),\n                                        (unsigned int)*v10);\n            v7 = *(uint64_t *)(a1 + 16);\n            LOBYTE(v9) = v11;\n            v2 = *(uint32_t *)(a1 + 8);\n            v3 = *(uint64_t *)(a1 + 32);\n            *(uint64_t *)(v7 + 8 * v8) = (int)v11;\n          }\n          if ((PERF_HES_STOPPED & (uint32_t)v10[1]) == 0)\n            *(uint32_t *)(a1 + 24) |= 1 << v9;\n          ++v8;\n        } while (v2 > (int)v8);\n      }\n    }\n    *(uint32_t *)(a1 + 40) = *(uint32_t *)(*(uint64_t *)v3 + 12LL);\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void maybe_change_configuration(struct type1 *var1) {\n  int var2;\n  if (var1->field1 == 0) return;\n  for (var2 = 0; var2 < var1->field2; var2++) {\n    struct type2 *var3 = var1->field3[var2];\n    if (var1->field4[var2] != var4 &&\n        var1->field4[var2] != var3->field5.field6) {\n      alpha_perf_event_update(var3, &var3->field5, var1->field4[var2], 0);\n      var1->field4[var2] = var4;\n    }\n  }\n  var1->field7 = 0;\n  for (var2 = 0; var2 < var1->field2; var2++) {\n    struct type2 *var3 = var1->field3[var2];\n    struct type3 *var5 = &var3->field5;\n    int var6 = var5->field6;\n    if (var1->field4[var2] == var4) {\n      alpha_perf_event_set_period(var3, var5, var6);\n      var1->field4[var2] = var6;\n    }\n    if (!(var5->field8 & var7)) var1->field7 |= (1 << var1->field4[var2]);\n  }\n  var1->field9 = var1->field3[0]->field5.field10;\n}", "style": "rule"}, "extra_info": {"index": 8000, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type3 {scalar_t__ field6; int field8; int /*<<< orphan*/  field10; } ;\nstruct type2 {struct type3 field5; } ;\nstruct type1 {scalar_t__ field1; int field2; scalar_t__* field4; int field7; struct type2** field3; int /*<<< orphan*/  field9; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  alpha_perf_event_set_period (struct type2*,struct type3*,int) ; \n int /*<<< orphan*/  alpha_perf_event_update (struct type2*,struct type3*,scalar_t__,int /*<<< orphan*/ ) ; \n scalar_t__ var4 ; \n int var7 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t *split(char *a1, char *a2) {\n  unsigned long long v2;\n  void *v3;\n  void **v4;\n  uint64_t v6[2];\n  char *delim;\n  char *s;\n  unsigned int n;\n  unsigned int n_4;\n  uint64_t *inited;\n  char *i;\n  long long v13;\n  void *dest;\n  unsigned long long v15;\n  s = a1;\n  delim = a2;\n  v15 = __readfsqword(40u);\n  n = strlen(a1) + 1;\n  v13 = n - 1LL;\n  v6[0] = n;\n  v6[1] = 0LL;\n  v2 = 16 * (((unsigned long long)n + 15) / 16);\n  while (v6 != (uint64_t *)((char *)v6 - (v2 & 18446744073709547520LL)))\n    ;\n  v3 = alloca(v2 & 4095);\n  if ((v2 & 4095) != 0)\n    *(uint64_t *)((char *)&v6[-1] + (v2 & 4095)) =\n        *(uint64_t *)((char *)&v6[-1] + (v2 & 4095));\n  dest = v6;\n  i = 0LL;\n  inited = (uint64_t *)initSplitString(a1, a2);\n  if (!inited) return 0LL;\n  memcpy(dest, s, n);\n  for (i = strtok((char *)dest, delim); i; i = strtok(0LL, delim)) {\n    n_4 = strlen(i) + 1;\n    v4 = (void **)(*inited + 8LL * inited[1]);\n    *v4 = malloc(n_4);\n    if (!*(uint64_t *)(*inited + 8LL * inited[1])) {\n      splitFree(&inited);\n      return 0LL;\n    }\n    memcpy(*(void **)(*inited + 8LL * inited[1]++), i, n_4);\n    adjustSize(inited);\n  }\n  return inited;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "struct type1 *split(const char *var1, const char *var2) {\n  unsigned var3 = strlen(var1) + 1;\n  char var4[var3];\n  char *var5 = NULL;\n  struct type1 *var6 = initSplitString();\n  if (var6 == NULL) {\n    goto error;\n  }\n  memcpy(var4, var1, var3);\n  var5 = strtok(var4, var2);\n  while (var5 != NULL) {\n    int var7 = strlen(var5) + 1;\n    var6->field1[var6->field2] = malloc(var7);\n    if (var6->field1[var6->field2]) {\n      memcpy(var6->field1[var6->field2], var5, var7);\n    } else {\n      splitFree(&var6);\n      goto error;\n    }\n    var6->field2++;\n    adjustSize(var6);\n    var5 = strtok(NULL, var2);\n  }\n  return var6;\nerror:\n  return NULL;\n}", "style": "rule"}, "extra_info": {"index": 36112, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {char** field1; size_t field2; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  adjustSize (struct type1*) ; \n struct type1* initSplitString () ; \n char* malloc (int) ; \n int /*<<< orphan*/  memcpy (char*,char const*,int) ; \n int /*<<< orphan*/  splitFree (struct type1**) ; \n int strlen (char const*) ; \n char* strtok (char*,char const*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  __m128i *i;\n  char *v5;\n  char v6;\n  signed int v7;\n  long long v8;\n  signed int v9;\n  __m128i *v10;\n  __m128i *v11;\n  long long v12;\n  __m128i si128;\n  const __m128i *v14;\n  __m128i v15;\n  __m128i v16;\n  unsigned int v17;\n  long long v18;\n  unsigned int v19;\n  signed int v20;\n  int v21;\n  signed int v22;\n  short *v23;\n  int v24;\n  long long v26;\n  short v27;\n  v3 = 0LL;\n  for (i = (__m128i *)malloc(1uLL);;\n       i = (__m128i *)realloc(i, (unsigned int)(v3 + 1))) {\n    v5 = &i->m128i_i8[v3++];\n    v6 = getchar();\n    *v5 = v6;\n    if (v6 == 10) break;\n  }\n  v7 = strlen(i->m128i_i8);\n  v8 = v7;\n  v9 = v7;\n  v10 = (__m128i *)malloc((unsigned int)(2 * v7));\n  v11 = v10;\n  if ((int)v8 <= 0) {\n    v21 = 0;\n  } else {\n    v12 = (unsigned int)(v8 - 1);\n    if ((v10 >= (__m128i *)&i->m128i_i8[v8] ||\n         i >= (__m128i *)((char *)v10 + 2 * v8)) &&\n        (unsigned int)v12 > 14) {\n      si128 = _mm_load_si128((const __m128i *)&LC0);\n      v14 = i;\n      do {\n        v15 = _mm_loadu_si128(v14++);\n        v10 += 2;\n        v16 = _mm_cmpgt_epi8((__m128i)0LL, v15);\n        v10[-2] = _mm_add_epi16(_mm_unpacklo_epi8(v15, v16), si128);\n        v10[-1] = _mm_add_epi16(_mm_unpackhi_epi8(v15, v16), si128);\n      } while (v14 != &i[(unsigned int)v9 >> 4]);\n      v17 = v9 & 4294967280;\n      if ((v9 & 15) != 0) {\n        v18 = v17;\n        v11->m128i_i16[v18] = i->m128i_i8[v17] - 48;\n        if (v9 > (int)(v17 + 1)) {\n          v11->m128i_i16[v18 + 1] = i->m128i_i8[v17 + 1] - 48;\n          if (v9 > (int)(v17 + 2)) {\n            v11->m128i_i16[v18 + 2] = i->m128i_i8[v17 + 2] - 48;\n            if (v9 > (int)(v17 + 3)) {\n              v11->m128i_i16[v18 + 3] = i->m128i_i8[v17 + 3] - 48;\n              if (v9 > (int)(v17 + 4)) {\n                v11->m128i_i16[v18 + 4] = i->m128i_i8[v17 + 4] - 48;\n                if (v9 > (int)(v17 + 5)) {\n                  v11->m128i_i16[v18 + 5] = i->m128i_i8[v17 + 5] - 48;\n                  if (v9 > (int)(v17 + 6)) {\n                    v11->m128i_i16[v18 + 6] = i->m128i_i8[v17 + 6] - 48;\n                    if (v9 > (int)(v17 + 7)) {\n                      v11->m128i_i16[v18 + 7] = i->m128i_i8[v17 + 7] - 48;\n                      if (v9 > (int)(v17 + 8)) {\n                        v11[1].m128i_i16[v18] = i->m128i_i8[v17 + 8] - 48;\n                        if (v9 > (int)(v17 + 9)) {\n                          v11[1].m128i_i16[v18 + 1] = i->m128i_i8[v17 + 9] - 48;\n                          if (v9 > (int)(v17 + 10)) {\n                            v11[1].m128i_i16[v18 + 2] =\n                                i->m128i_i8[v17 + 10] - 48;\n                            if (v9 > (int)(v17 + 11)) {\n                              v11[1].m128i_i16[v18 + 3] =\n                                  i->m128i_i8[v17 + 11] - 48;\n                              if (v9 > (int)(v17 + 12)) {\n                                v11[1].m128i_i16[v18 + 4] =\n                                    i->m128i_i8[v17 + 12] - 48;\n                                v19 = v17 + 13;\n                                if (v9 > (int)(v17 + 13)) {\n                                  v20 = v17 + 14;\n                                  v11[1].m128i_i16[v18 + 5] =\n                                      i->m128i_i8[v19] - 48;\n                                  if (v9 > v20)\n                                    v11[1].m128i_i16[v18 + 6] =\n                                        i->m128i_i8[v20] - 48;\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      v26 = (long long)v10->m128i_i64 + 2 * v12 + 2;\n      do {\n        v27 = i->m128i_i8[0];\n        v10 = (__m128i *)((char *)v10 + 2);\n        i = (__m128i *)((char *)i + 1);\n        v10[-1].m128i_i16[7] = v27 - 48;\n      } while (v10 != (__m128i *)v26);\n    }\n    v21 = 0;\n    v22 = 0;\n    do {\n      v23 = &v11->m128i_i16[v22];\n      do {\n        v24 = *v23;\n        ++v22;\n        ++v23;\n        v21 = v24 + 10 * v21;\n      } while (v9 > v22 && v21 <= 299);\n      v21 %= 300;\n    } while (v9 > v22);\n  }\n  printf(\"remainder is = %d\\n\", v21);\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(void) {\n  int var1 = 0;\n  char *var2 = (char *)malloc(sizeof(char));\n  while ((var2[var1] = getchar()) != '\\n') {\n    var2 = (char *)realloc(var2, var1 + 2);\n    var1++;\n  }\n  short int *var3;\n  int var4;\n  int var5 = 0;\n  var4 = strlen(var2);\n  var3 = (short int *)malloc(sizeof(short int) * var4);\n  for (var1 = 0; var1 < var4; var1++) {\n    var3[var1] = var2[var1] - '0';\n  }\n  var1 = 0;\n  while (var1 < var4) {\n    while (var1 < var4 && var5 < 300) {\n      var5 = var5 * 10 + var3[var1];\n      var1++;\n    }\n    var5 = var5 % 300;\n  }\n  printf(\"remainder is = %d\\n\", var5);\n}", "style": "rule"}, "extra_info": {"index": 91550, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n char getchar () ; \n scalar_t__ malloc (int) ; \n int /*<<< orphan*/  printf (char*,int) ; \n scalar_t__ realloc (char*,int) ; \n int strlen (char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long pcap_tstamp_type_name_to_val(long long a1) {\n  long long v2;\n  long long v3;\n  v2 = *(uint64_t *)(tstamp_type_choices + 8);\n  if (!v2) return 4294967295LL;\n  v3 = 0LL;\n  while (pcap_strcasecmp(v2, a1)) {\n    v3 += 16LL;\n    v2 = *(uint64_t *)(tstamp_type_choices + v3 + 8);\n    if (!v2) return 4294967295LL;\n  }\n  return *(unsigned int *)(tstamp_type_choices + v3);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int pcap_tstamp_type_name_to_val(const char *var1) {\n  int var2;\n  for (var2 = 0; var3[var2].field1 != NULL; var2++) {\n    if (pcap_strcasecmp(var3[var2].field1, var1) == 0)\n      return (var3[var2].field2);\n  }\n  return (-1);\n}", "style": "rule"}, "extra_info": {"index": 60872, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int field2; int /*<<< orphan*/ * field1; } ;\n\n/* Variables and functions */\n scalar_t__ pcap_strcasecmp (int /*<<< orphan*/ *,char const*) ; \n TYPE_1__* var3 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned int *findrr(const char *a1) {\n  unsigned int *i;\n  for (i = (unsigned int *)rrhead; i; i = *(unsigned int **)i) {\n    if (!strcmp(a1, (const char *)i[4])) return i;\n  }\n  i = (unsigned int *)malloc(24uLL);\n  if (!i) puke(\"malloc failure\");\n  i[4] = (unsigned int)strdup(a1);\n  if (!i[4]) puke(\"malloc failure\");\n  *((uint64_t *)i + 1) = 0LL;\n  *(uint64_t *)i = rrhead;\n  rrhead = (long long)i;\n  return i;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "struct type1 *findrr(char *var1) {\n  struct type1 *var2;\n  var2 = var3;\n  while (var2) {\n    if (!strcmp(var1, var2->field1)) goto foundrr;\n    var2 = var2->field2;\n  }\n  var2 = (struct type1 *)malloc(sizeof(struct type1));\n  if (!var2) puke(\"malloc failure\");\n  var2->field1 = strdup(var1);\n  if (!var2->field1) puke(\"malloc failure\");\n  var2->field3 = 0;\n  var2->field2 = var3;\n  var3 = var2;\nfoundrr:\n  return var2;\n}", "style": "rule"}, "extra_info": {"index": 104430, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {struct type1* field2; scalar_t__ field3; int /*<<< orphan*/  field1; } ;\n\n/* Variables and functions */\n scalar_t__ malloc (int) ; \n int /*<<< orphan*/  puke (char*) ; \n int /*<<< orphan*/  strcmp (char*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  strdup (char*) ; \n struct type1* var3 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long multiplexFileControl(long long *a1, unsigned int a2, long long *a3) {\n  long long v3;\n  long long result;\n  long long v6;\n  uint8_t *v7;\n  const char *v8;\n  long long v9;\n  int v10;\n  long long (***v11)(uint64_t, uint64_t, long long *);\n  unsigned int v12;\n  unsigned long long v13;\n  v3 = *a1;\n  v13 = __readfsqword(40u);\n  result = (unsigned int)SQLITE_ERROR;\n  v12 = SQLITE_ERROR;\n  if (!gMultiplex) return (unsigned int)SQLITE_MISUSE;\n  switch (a2) {\n    case 128u:\n    case 130u:\n    case 131u:\n      goto LABEL_11;\n    case 129u:\n      v6 = a3[1];\n      if (!v6 || (unsigned int)sqlite3_stricmp(v6, \"multiplex_truncate\"))\n        goto LABEL_18;\n      v7 = (uint8_t *)a3[2];\n      if (!v7 || !*v7) goto LABEL_7;\n      if ((unsigned int)sqlite3_stricmp(v7, \"on\") &&\n          (unsigned int)sqlite3_stricmp(a3[2], \"1\")) {\n        if ((unsigned int)sqlite3_stricmp(a3[2], \"off\") &&\n            (unsigned int)sqlite3_stricmp(a3[2], \"0\")) {\n        LABEL_7:\n          v8 = \"on\";\n          if (!*(uint32_t *)(v3 + 8)) v8 = \"off\";\n          v9 = sqlite3_mprintf(v8);\n        } else {\n          *(uint32_t *)(v3 + 8) = 0;\n          v9 = sqlite3_mprintf(\"off\");\n        }\n      } else {\n        *(uint32_t *)(v3 + 8) = 1;\n        v9 = sqlite3_mprintf(\"on\");\n      }\n      *a3 = v9;\n    LABEL_11:\n      result = (unsigned int)SQLITE_OK;\n      break;\n    case 132u:\n      if (!a3) return result;\n      v10 = *(uint32_t *)a3;\n      if (!*(uint32_t *)a3) return (unsigned int)SQLITE_MISUSE;\n      *(uint32_t *)(v3 + 4) = (MAX_PAGE_SIZE + v10 - 1) & -MAX_PAGE_SIZE;\n      result = (unsigned int)SQLITE_OK;\n      break;\n    case 133u:\n      if (a3) {\n        *(uint8_t *)v3 = *(uint32_t *)a3;\n        return (unsigned int)SQLITE_OK;\n      }\n      return result;\n    default:\n    LABEL_18:\n      v11 = (long long (***)(uint64_t, uint64_t, long long *))multiplexSubOpen(\n          v3, 0LL, &v12, 0LL, 0LL);\n      if (!v11) goto LABEL_22;\n      result = (**v11)(v11, a2, a3);\n      v12 = result;\n      if (SQLITE_FCNTL_VFSNAME == a2 && (uint32_t)result == SQLITE_OK) {\n        *a3 = sqlite3_mprintf(\"multiplex/%z\", *a3);\n      LABEL_22:\n        result = v12;\n      }\n      break;\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int multiplexFileControl(type1 *var1, int var2, void *var3) {\n  type2 *var4 = (type2 *)var1;\n  type3 *var5 = var4->field1;\n  int var6 = var7;\n  type1 *var8;\n  if (!var9.field2) return var10;\n  switch (var2) {\n    case var11:\n      if (var3) {\n        int var12 = *(int *)var3;\n        var5->field3 = (unsigned char)var12;\n        var6 = var13;\n      }\n      break;\n    case var14:\n      if (var3) {\n        unsigned int var15 = *(unsigned *)var3;\n        if (var15 < 1) {\n          var6 = var10;\n        } else {\n          var15 = (var15 + (var16 - 1));\n          var15 &= ~(var16 - 1);\n          var5->field4 = var15;\n          var6 = var13;\n        }\n      }\n      break;\n    case var17:\n      var6 = var13;\n      break;\n    case var18:\n    case var19:\n      var6 = var13;\n      break;\n    case var20: {\n      char **var21 = (char **)var3;\n      if (var21[1] && sqlite3_stricmp(var21[1], \"multiplex_truncate\") == 0) {\n        if (var21[2] && var21[2][0]) {\n          if (sqlite3_stricmp(var21[2], \"on\") == 0 ||\n              sqlite3_stricmp(var21[2], \"1\") == 0) {\n            var5->field5 = 1;\n          } else if (sqlite3_stricmp(var21[2], \"off\") == 0 ||\n                     sqlite3_stricmp(var21[2], \"0\") == 0) {\n            var5->field5 = 0;\n          }\n        }\n        var21[0] = sqlite3_mprintf(var5->field5 ? \"on\" : \"off\");\n        var6 = var13;\n        break;\n      }\n    }\n    default:\n      var8 = multiplexSubOpen(var5, 0, &var6, NULL, 0);\n      if (var8) {\n        var6 = var8->field6->field7(var8, var2, var3);\n        if (var2 == var22 && var6 == var13) {\n          *(char **)var3 = sqlite3_mprintf(\"multiplex/%z\", *(char **)var3);\n        }\n      }\n      break;\n  }\n  return var6;\n}", "style": "rule"}, "extra_info": {"index": 76754, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_5__ ;\ntypedef  struct TYPE_13__   TYPE_4__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {unsigned char field3; unsigned int field4; int field5; } ;\ntypedef  TYPE_2__ type3 ;\nstruct TYPE_12__ {TYPE_2__* field1; } ;\ntypedef  TYPE_3__ type2 ;\nstruct TYPE_13__ {TYPE_1__* field6; } ;\ntypedef  TYPE_4__ type1 ;\nstruct TYPE_14__ {int /*<<< orphan*/  field2; } ;\nstruct TYPE_10__ {int (* field7 ) (TYPE_4__*,int,void*) ;} ;\n\n/* Variables and functions */\n TYPE_4__* multiplexSubOpen (TYPE_2__*,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n char* sqlite3_mprintf (char*,...) ; \n int /*<<< orphan*/  sqlite3_stricmp (char*,char*) ; \n int stub1 (TYPE_4__*,int,void*) ; \n int var10 ; \n#define  var11 133 \n int var13 ; \n#define  var14 132 \n int /*<<< orphan*/  var16 ; \n#define  var17 131 \n#define  var18 130 \n#define  var19 129 \n#define  var20 128 \n int var22 ; \n int var7 ; \n TYPE_5__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long php_openssl_dh_pub_from_priv(long long a1, long long a2,\n                                       long long a3) {\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v8;\n  long long v9;\n  long long v10;\n  v4 = BN_new();\n  if (v4) {\n    v5 = BN_new();\n    if (v5) {\n      v6 = BN_CTX_new();\n      if (v6) {\n        BN_with_flags(v5, a1, (unsigned int)BN_FLG_CONSTTIME);\n        if (!(unsigned int)BN_mod_exp_mont(v4, a2, v5, a3, v6, 0LL)) {\n          v8 = v4;\n          v4 = 0LL;\n          BN_free(v8);\n          php_openssl_store_errors();\n        }\n        BN_free(v5);\n        BN_CTX_free(v6);\n      } else {\n        v10 = v4;\n        v4 = 0LL;\n        BN_free(v10);\n        BN_free(v5);\n        php_openssl_store_errors();\n      }\n    } else {\n      v9 = v4;\n      v4 = 0LL;\n      BN_free(v9);\n      php_openssl_store_errors();\n    }\n  } else {\n    php_openssl_store_errors();\n  }\n  return v4;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static type1 *php_openssl_dh_pub_from_priv(type1 *var1, type1 *var2,\n                                           type1 *var3) {\n  type1 *var4, *var5;\n  type2 *var6;\n  var4 = BN_new();\n  if (var4 == NULL) {\n    php_openssl_store_errors();\n    return NULL;\n  }\n  var5 = BN_new();\n  if (var5 == NULL) {\n    BN_free(var4);\n    php_openssl_store_errors();\n    return NULL;\n  }\n  var6 = BN_CTX_new();\n  if (var6 == NULL) {\n    BN_free(var4);\n    BN_free(var5);\n    php_openssl_store_errors();\n    return NULL;\n  }\n  BN_with_flags(var5, var1, var7);\n  if (!BN_mod_exp_mont(var4, var2, var5, var3, var6, NULL)) {\n    BN_free(var4);\n    php_openssl_store_errors();\n    var4 = NULL;\n  }\n  BN_free(var5);\n  BN_CTX_free(var6);\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 18661, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  BN_CTX_free (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * BN_CTX_new () ; \n int /*<<< orphan*/  BN_free (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  BN_mod_exp_mont (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * BN_new () ; \n int /*<<< orphan*/  BN_with_flags (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  php_openssl_store_errors () ; \n int /*<<< orphan*/  var7 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long grep_aliases(const char *a1, int a2, unsigned short a3,\n                       unsigned short a4) {\n  long long v4;\n  unsigned int n;\n  const char *n_4;\n  long long i;\n  long long j;\n  n_4 = a1;\n  n = a2;\n  if (a2 > 2 && *a1 == 91 && a1[a2 - 1] == 93) {\n    n_4 = a1 + 1;\n    n = a2 - 2;\n  }\n  for (i = aliases; i; i = *(uint64_t *)(i + 16)) {\n    if (n == *(uint32_t *)(i + 4) &&\n        (!*(unsigned short *)i || !a3 || a3 == *(unsigned short *)i) &&\n        (!*(unsigned short *)(i + 2) || !a4 ||\n         a4 == *(unsigned short *)(i + 2))) {\n      LODWORD(v4) = strncasecmp((const char *)*(unsigned int *)(i + 8), n_4, n);\n      if (!v4) return 1LL;\n    }\n  }\n  for (j = alias_fcts; j; j = *(uint64_t *)(j + 8)) {\n    if ((*(long long (**)(const char *, uint64_t, uint64_t, uint64_t))j)(\n            n_4, n, a3, a4) > 0)\n      return 1LL;\n  }\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static inline int grep_aliases(char* var1, int var2, unsigned short var3,\n                               unsigned short var4) {\n  struct type1* var5;\n  struct type2* var6;\n  if ((var2 > 2) && ((*var1) == '[') && (var1[var2 - 1] == ']')) {\n    var1++;\n    var2 -= 2;\n  }\n  for (var5 = var7; var5; var5 = var5->field1)\n    if ((var5->field2.field3 == var2) &&\n        ((var5->field4 == 0) || (var3 == 0) || (var5->field4 == var3)) &&\n        ((var5->field5 == 0) || (var4 == 0) || (var5->field5 == var4)) &&\n        (strncasecmp(var5->field2.field6, var1, var2) == 0))\n      return 1;\n  for (var6 = var8; var6; var6 = var6->field1) {\n    if (var6->field7(var1, var2, var3, var4) > 0) return 1;\n  }\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 5364, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct type2 {scalar_t__ (* field7 ) (char*,int,unsigned short,unsigned short) ;struct type2* field1; } ;\nstruct TYPE_2__ {int field3; int /*<<< orphan*/  field6; } ;\nstruct type1 {unsigned short field4; unsigned short field5; TYPE_1__ field2; struct type1* field1; } ;\n\n/* Variables and functions */\n scalar_t__ strncasecmp (int /*<<< orphan*/ ,char*,int) ; \n scalar_t__ stub1 (char*,int,unsigned short,unsigned short) ; \n struct type1* var7 ; \n struct type2* var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long CreateTreeWindow(int a1, long long a2, long long a3, long long a4,\n                           long long a5, long long a6) {\n  unsigned int v6;\n  unsigned int v7;\n  long long v9;\n  long long v10;\n  uint64_t v11[6];\n  int v12;\n  int v13;\n  int v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  if (iNumWindows <= 26) {\n    v14 = szTreeClass;\n    v13 = a1;\n    v12 = hAppInstance;\n    v11[0] = 0LL;\n    v11[5] = a2;\n    v11[4] = a3;\n    v11[3] = a4;\n    v11[2] = a5;\n    v11[1] = a6;\n    v9 = SendMessage((unsigned int)hwndMDIClient, (unsigned int)WM_MDIGETACTIVE,\n                     0LL, 0LL);\n    if (v9) {\n      if ((WS_MAXIMIZE &\n           (unsigned int)GetWindowLongPtr(v9, (unsigned int)GWL_STYLE)) != 0)\n        v11[0] |= WS_MAXIMIZE;\n    }\n    v10 = SendMessage((unsigned int)hwndMDIClient, (unsigned int)WM_MDICREATE,\n                      0LL, v11);\n    SetWindowLongPtr(v10, (unsigned int)GWL_VIEW, (unsigned int)dwNewView);\n    SetWindowLongPtr(v10, (unsigned int)GWL_SORT, (unsigned int)dwNewSort);\n    SetWindowLongPtr(v10, (unsigned int)GWL_ATTRIBS,\n                     (unsigned int)dwNewAttribs);\n    return v10;\n  } else {\n    v6 = COUNTOF((unsigned int)szTitle);\n    LoadString((unsigned int)hAppInstance, (unsigned int)IDS_WINFILE,\n               (unsigned int)szTitle, v6);\n    v7 = COUNTOF((unsigned int)szMessage);\n    LoadString((unsigned int)hAppInstance, (unsigned int)IDS_TOOMANYWINDOWS,\n               (unsigned int)szMessage, v7);\n    MessageBox((unsigned int)hwndFrame, (unsigned int)szMessage,\n               (unsigned int)szTitle, MB_ICONEXCLAMATION | (unsigned int)MB_OK);\n    return 0LL;\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 CreateTreeWindow(type2 var1, type3 var2, type3 var3, type3 var4,\n                       type3 var5, type3 var6) {\n  type4 var7;\n  type1 var8;\n  if (var9 > 26) {\n    LoadString(var10, var11, var12, COUNTOF(var12));\n    LoadString(var10, var13, var14, COUNTOF(var14));\n    MessageBox(var15, var14, var12, var16 | var17);\n    return NULL;\n  }\n  var7.field1 = var18;\n  var7.field2 = var1;\n  var7.field3 = var10;\n  var7.field4 = 0L;\n  var7.field5 = var2;\n  var7.field6 = var3;\n  var7.field7 = var4;\n  var7.field8 = var5;\n  var7.field9 = var6;\n  var8 = (type1)SendMessage(var19, var20, 0, 0L);\n  if (var8 && GetWindowLongPtr(var8, var21) & var22) var7.field4 |= var22;\n  var8 = (type1)SendMessage(var19, var23, 0L, (var24)&var7);\n  SetWindowLongPtr(var8, var25, var26);\n  SetWindowLongPtr(var8, var27, var28);\n  SetWindowLongPtr(var8, var29, var30);\n  return var8;\n}", "style": "rule"}, "extra_info": {"index": 5967, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  long var24 ;\nstruct TYPE_2__ {long field4; void* field9; void* field8; void* field7; void* field6; void* field5; int /*<<< orphan*/  field3; int /*<<< orphan*/  field2; int /*<<< orphan*/  field1; } ;\ntypedef  TYPE_1__ type4 ;\ntypedef  void* type3 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/ * type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  COUNTOF (int /*<<< orphan*/ ) ; \n int GetWindowLongPtr (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  LoadString (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  MessageBox (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; \n scalar_t__ SendMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ ,long,long) ; \n int /*<<< orphan*/  SetWindowLongPtr (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n int /*<<< orphan*/  var13 ; \n int /*<<< orphan*/  var14 ; \n int /*<<< orphan*/  var15 ; \n int var16 ; \n int var17 ; \n int /*<<< orphan*/  var18 ; \n int /*<<< orphan*/  var19 ; \n int /*<<< orphan*/  var20 ; \n int /*<<< orphan*/  var21 ; \n int var22 ; \n int /*<<< orphan*/  var23 ; \n int /*<<< orphan*/  var25 ; \n int /*<<< orphan*/  var26 ; \n int /*<<< orphan*/  var27 ; \n int /*<<< orphan*/  var28 ; \n int /*<<< orphan*/  var29 ; \n int /*<<< orphan*/  var30 ; \n int var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long find_polltbl_idx(long long a1, long long a2) {\n  unsigned int i;\n  for (i = 0; (signed int)i < *(uint32_t *)a1; ++i) {\n    if (a2 == *(uint64_t *)(*(uint64_t *)(a1 + 8) + 8LL * (int)i)) return i;\n  }\n  return 4294967295LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int find_polltbl_idx(struct type1 *var1, uint64_t var2) {\n  int var3;\n  for (var3 = 0; var3 < var1->field1; var3++) {\n    if (var1->field2[var3].field3 != var2) continue;\n    return (var3);\n  }\n  return (-1);\n}", "style": "rule"}, "extra_info": {"index": 60178, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\nstruct type1 {int field1; TYPE_1__* field2; } ;\nstruct TYPE_2__ {scalar_t__ field3; } ;\n\n/* Variables and functions */\n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  FILE *v3;\n  unsigned int v4;\n  int v5;\n  unsigned int v6;\n  int v7;\n  uint64_t *v8;\n  int v9;\n  unsigned int v10;\n  unsigned int v11;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  unsigned int v16;\n  int v17;\n  int fd;\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  v3 = tmpfile();\n  BUG_ON(v3 == 0LL, \"tmpfile()\");\n  v4 = MMAP_SZ;\n  v5 = fileno(v3);\n  v6 = ftruncate(v5, v4);\n  BUG_ON(v6, \"ftruncate()\");\n  v7 = fileno(v3);\n  v8 = mmap(0LL, (unsigned int)MMAP_SZ, PROT_WRITE | (unsigned int)PROT_READ,\n            MAP_SHARED, v7, 0LL);\n  BUG_ON(MAP_FAILED == (uint64_t)v8, \"mmap()\");\n  v9 = MS_SYNC;\n  *v8 = 3735927486LL;\n  v10 = msync(v8, (unsigned int)MMAP_SZ, v9);\n  BUG_ON(v10, \"msync()\");\n  v11 = socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, &v17);\n  BUG_ON(v11, \"socketpair()\");\n  v12 = fork();\n  BUG_ON(v12 == -1, \"fork()\");\n  if (v12) {\n    v16 = close(v17);\n    BUG_ON(v16, \"close()\");\n    return parent_f((unsigned int)fd, v8, v12);\n  } else {\n    v13 = close(fd);\n    BUG_ON(v13, \"close()\");\n    v14 = fileno(v3);\n    return child_f((unsigned int)v17, v8, v14);\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char **var2) {\n  int var3[2], var4, var5;\n  type1 *var6;\n  unsigned long *var7;\n  var6 = tmpfile();\n  BUG_ON(var6 == 0, \"tmpfile()\");\n  var5 = ftruncate(fileno(var6), var8);\n  BUG_ON(var5, \"ftruncate()\");\n  var7 = mmap(0, var8, var9 | var10, var11, fileno(var6), 0);\n  BUG_ON(var7 == var12, \"mmap()\");\n  *var7 = 0xdeadbabe;\n  var5 = msync(var7, var8, var13);\n  BUG_ON(var5, \"msync()\");\n  var5 = socketpair(var14, var15, 0, var3);\n  BUG_ON(var5, \"socketpair()\");\n  var4 = fork();\n  BUG_ON(var4 == -1, \"fork()\");\n  if (var4) {\n    var5 = close(var3[0]);\n    BUG_ON(var5, \"close()\");\n    return parent_f(var3[1], var7, var4);\n  }\n  var5 = close(var3[1]);\n  BUG_ON(var5, \"close()\");\n  return child_f(var3[0], var7, fileno(var6));\n}", "style": "rule"}, "extra_info": {"index": 3940, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  BUG_ON (int,char*) ; \n int child_f (int,unsigned long*,int /*<<< orphan*/ ) ; \n int close (int) ; \n int /*<<< orphan*/  fileno (int /*<<< orphan*/ *) ; \n int fork () ; \n int ftruncate (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n unsigned long* mmap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int msync (unsigned long*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int parent_f (int,unsigned long*,int) ; \n int socketpair (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*) ; \n int /*<<< orphan*/ * tmpfile () ; \n int var10 ; \n int /*<<< orphan*/  var11 ; \n unsigned long* var12 ; \n int /*<<< orphan*/  var13 ; \n int /*<<< orphan*/  var14 ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var8 ; \n int var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long dlr_are_libraries_compatible(long long a1, const char **a2,\n                                       long long a3) {\n  long long v6;\n  long long v7;\n  const char *v8;\n  char *v9;\n  const char *v10;\n  const char *v11;\n  long long v12;\n  unsigned int v13;\n  const char *v14;\n  long long v15;\n  long long v16;\n  long long v18;\n  long long symbol_name;\n  long long v20;\n  long long v21;\n  const char *v22;\n  const char *v23;\n  const char *v24;\n  long long v25;\n  unsigned int v26;\n  int v27;\n  unsigned int v28;\n  const char *v29;\n  const char *v30;\n  unsigned int v31;\n  int v32;\n  const char *v33;\n  char *v34;\n  long long v35;\n  char *v36;\n  char dest[24];\n  unsigned long long v38;\n  v38 = __readfsqword(40u);\n  if (!a3) {\n    symbol_name = dlr_get_symbol_name();\n    v20 = *((unsigned int *)a2 + 6);\n    v21 = *(unsigned int *)(a1 + 24);\n    v34 = (char *)symbol_name;\n    v22 = \"%s (%.*s vs. %.*s): no restrictions symbol (%s) present\";\n    v33 = (const char *)*((unsigned int *)a2 + 4);\n    v23 = (const char *)*(unsigned int *)(a1 + 16);\n  LABEL_22:\n    dlr_debug(1LL, v22, \"ACCEPT\", v21, v23, v20, v33, v34, v35, v36);\n    HIDWORD(v35) = 1;\n    return HIDWORD(v35);\n  }\n  LODWORD(v6) = strncmp(*(const char **)a3, \"DLR_SYMBOL_V1:\", 8uLL);\n  if (v6) {\n    v24 = *(const char **)a3;\n    v25 = dlr_get_symbol_name();\n    dlr_debug(1LL,\n              \"%s (%.*s vs. %.*s): restrictions symbol (%s) magic (%.*s) \"\n              \"unrecognized\",\n              \"ACCEPT\", *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 16),\n              *((unsigned int *)a2 + 6), *((unsigned int *)a2 + 4), v25, 14LL,\n              v24);\n    goto LABEL_17;\n  }\n  v7 = *(unsigned int *)(a3 + 8);\n  if ((unsigned int)v7 > 4096) {\n    dlr_set_error(\n        \"%.*s vs. %.*s: restrictions symbol expression is too long (%u). \"\n        \"Maximum is %u\",\n        *(uint32_t *)(a1 + 24), (const char *)*(unsigned int *)(a1 + 16),\n        *((uint32_t *)a2 + 6), (const char *)*((unsigned int *)a2 + 4), v7,\n        4096);\n    HIDWORD(v35) = -1;\n    return HIDWORD(v35);\n  }\n  v8 = *(const char **)(a3 + 16);\n  if (!(uint32_t)v7 || !v8) {\n    dlr_debug(1LL,\n              \"%s (%.*s vs. %.*s): restrictions symbol expression is empty \"\n              \"(l=%d,exp=%lx)\",\n              \"ACCEPT\", *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 16),\n              *((unsigned int *)a2 + 6), *((unsigned int *)a2 + 4), v7,\n              *(uint64_t *)(a3 + 16));\n  LABEL_17:\n    HIDWORD(v35) = 1;\n    return HIDWORD(v35);\n  }\n  v36 = dest;\n  strncpy(dest, v8, (unsigned int)v7);\n  dest[v7] = 0;\n  v9 = strtok(dest, \",\");\n  if (!v9) {\n    v29 = (const char *)*((unsigned int *)a2 + 4);\n    v20 = *((unsigned int *)a2 + 6);\n    v23 = (const char *)*(unsigned int *)(a1 + 16);\n    v21 = *(unsigned int *)(a1 + 24);\n  LABEL_28:\n    v34 = dest;\n    v22 = \"%s (%.*s vs. %.*s): restriction expression (%s) processed\";\n    v33 = v29;\n    goto LABEL_22;\n  }\n  HIDWORD(v35) = 1;\n  do {\n    v14 = (const char *)skip_spaces(v9);\n    LODWORD(v15) = strncmp(v14, \"ACCEPT:\", 7uLL);\n    if (v15) {\n      LODWORD(v16) = strncmp(v14, \"REJECT:\", 7uLL);\n      if (v16) {\n        v30 = (const char *)*(unsigned int *)(a1 + 16);\n        v31 = *((uint32_t *)a2 + 6);\n        v32 = *(uint32_t *)(a1 + 24);\n        errno = EINVAL;\n        dlr_set_error(\n            \"%.*s vs. %.*s: syntax error in restriction expression (%s):%d: \"\n            \"ACCEPT: or REJECT: expected\",\n            v32, v30, v31, (const char *)*((unsigned int *)a2 + 4), dest,\n            (uint32_t)v14 - (unsigned int)dest + 1);\n        HIDWORD(v35) = -1;\n        return HIDWORD(v35);\n      }\n      LODWORD(v35) = 0;\n      v10 = v14 + 7;\n    } else {\n      LODWORD(v35) = 1;\n      v10 = v14 + 7;\n    }\n    v11 = (const char *)skip_spaces(v10);\n    LODWORD(v12) = strcmp(v11, \"OTHERSOVERSION\");\n    if (v12) {\n      v26 = *((uint32_t *)a2 + 6);\n      v27 = *(uint32_t *)(a1 + 24);\n      v28 = *(uint32_t *)(a1 + 16);\n      errno = ENOTSUP;\n      dlr_set_error(\n          \"%.*s vs. %.*s: unsupported token in restriction expression (%s):%d: \"\n          \"%s\",\n          v27, (const char *)v28, v26, (const char *)*((unsigned int *)a2 + 4),\n          dest, (uint32_t)v11 - (unsigned int)dest + 1, v11);\n      HIDWORD(v35) = -1;\n      return HIDWORD(v35);\n    }\n    v13 = *(unsigned int *)a2;\n    if (*(uint32_t *)a1 != (uint32_t)v13 ||\n        (LODWORD(v18) = strncmp(*(const char **)(a1 + 8), a2[1], v13), v18))\n      HIDWORD(v35) = v35;\n    v9 = strtok(0LL, \",\");\n  } while (v9);\n  v29 = (const char *)*((unsigned int *)a2 + 4);\n  v23 = (const char *)*(unsigned int *)(a1 + 16);\n  v21 = *(unsigned int *)(a1 + 24);\n  v20 = (unsigned int)a2[3];\n  if (HIDWORD(v35)) goto LABEL_28;\n  dlr_debug(1LL, \"%s (%.*s vs. %.*s): restriction expression (%s) processed\",\n            \"REJECT\", v21, v23, v20, v29, dest);\n  dlr_set_error(\"%.*s vs. %.*s: libraries conflict%s\", *(uint32_t *)(a1 + 24),\n                (const char *)*(unsigned int *)(a1 + 16), *((uint32_t *)a2 + 6),\n                (const char *)*((unsigned int *)a2 + 4), (const char *)&LC14);\n  return HIDWORD(v35);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int dlr_are_libraries_compatible(type1 *var1, type1 *var2, type2 *var3) {\n  unsigned int var4;\n  char var5[4096 + 1];\n  int var6;\n  char *var7;\n  unsigned char var8;\n  if (var3 == NULL) {\n    dlr_debug(1,\n              \"%s (%.*s vs. %.*s): \"\n              \"no restrictions symbol (%s) present\",\n              \"ACCEPT\", (int)var1->field1, var1->field2, (int)var2->field1,\n              var2->field2, dlr_get_symbol_name());\n    return 1;\n  }\n  if (strncmp(var3->field3, \"DLR_SYMBOL_V1:\", sizeof(var3->field3))) {\n    dlr_debug(1,\n              \"%s (%.*s vs. %.*s): \"\n              \"restrictions symbol (%s) magic (%.*s) unrecognized\",\n              \"ACCEPT\", (int)var1->field1, var1->field2, (int)var2->field1,\n              var2->field2, dlr_get_symbol_name(),\n              (int)sizeof(\"DLR_SYMBOL_V1:\") - 1, var3->field3);\n    return 1;\n  }\n  var4 = var3->field4;\n  if (var4 > 4096) {\n    dlr_set_error(\n        \"%.*s vs. %.*s: \"\n        \"restrictions symbol expression is too long (%u). Maximum is %u\",\n        (int)var1->field1, var1->field2, (int)var2->field1, var2->field2, var4,\n        4096);\n    ;\n    return -1;\n  }\n  if (var4 == 0 || var3->field5 == NULL) {\n    dlr_debug(1,\n              \"%s (%.*s vs. %.*s): \"\n              \"restrictions symbol expression is empty (l=%d,exp=%lx)\",\n              \"ACCEPT\", (int)var1->field1, var1->field2, (int)var2->field1,\n              var2->field2, var4, var3->field5);\n    return 1;\n  }\n  strncpy(var5, var3->field5, var4);\n  var5[var4] = '\\0';\n  var6 = 1;\n  var7 = strtok(var5, \",\");\n  while (var7 != NULL) {\n    var7 = skip_spaces(var7);\n    if (strncmp(var7, \"ACCEPT:\", 7) == 0) {\n      var8 = 1;\n      var7 += 7;\n    } else if (strncmp(var7, \"REJECT:\", 7) == 0) {\n      var8 = 0;\n      var7 += 7;\n    } else {\n      var9 = var10;\n      dlr_set_error(\n          \"%.*s vs. %.*s: syntax error in restriction expression (%s):%d: \"\n          \"ACCEPT: or REJECT: expected\",\n          (int)var1->field1, var1->field2, (int)var2->field1, var2->field2,\n          var5, (int)(var7 - var5 + 1));\n      return -1;\n    }\n    var7 = skip_spaces(var7);\n    if (strcmp(var7, \"OTHERSOVERSION\") == 0) {\n      if (!(var1->field6 == var2->field6 &&\n            strncmp(var1->field7, var2->field7, var2->field6) == 0)) {\n        var6 = var8;\n      }\n    } else {\n      var9 = var11;\n      dlr_set_error(\n          \"%.*s vs. %.*s: unsupported token in restriction expression (%s):%d: \"\n          \"%s\",\n          (int)var1->field1, var1->field2, (int)var2->field1, var2->field2,\n          var5, (int)(var7 - var5 + 1), var7);\n      return -1;\n    }\n    var7 = strtok(NULL, \",\");\n  }\n  dlr_debug(1,\n            \"%s (%.*s vs. %.*s): \"\n            \"restriction expression (%s) processed\",\n            ((var6) ? \"ACCEPT\" : \"REJECT\"), (int)var1->field1, var1->field2,\n            (int)var2->field1, var2->field2, var5);\n  if (var6 == 0) {\n    dlr_set_error(\n        \"%.*s vs. %.*s: \"\n        \"libraries conflict%s\",\n        (int)var1->field1, var1->field2, (int)var2->field1, var2->field2, \"\");\n    ;\n  }\n  return var6;\n}", "style": "rule"}, "extra_info": {"index": 23378, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {char* field3; unsigned int field4; int /*<<< orphan*/ * field5; } ;\ntypedef  TYPE_1__ type2 ;\nstruct TYPE_7__ {int field6; char* field7; int /*<<< orphan*/  field2; scalar_t__ field1; } ;\ntypedef  TYPE_2__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  dlr_debug (int,char*,char*,int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,...) ; \n char* dlr_get_symbol_name () ; \n int /*<<< orphan*/  dlr_set_error (char*,int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,...) ; \n char* skip_spaces (char*) ; \n scalar_t__ strcmp (char*,char*) ; \n scalar_t__ strncmp (char*,char*,int) ; \n int /*<<< orphan*/  strncpy (char*,int /*<<< orphan*/ *,unsigned int) ; \n char* strtok (char*,char*) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  long long v5;\n  long long v6;\n  int v7;\n  int v8;\n  struct sockaddr s[65];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  v3 = socket(AF_INET, SOCK_STREAM, 0);\n  if (v3 >= 0) {\n    memset(s, 0, 12uLL);\n    *(uint32_t *)&s[0].sa_data[6] = AF_INET;\n    *(uint32_t *)&s[0].sa_data[2] = htonl(INADDR_ANY);\n    LOWORD(v4) = htons(50004u);\n    *(uint32_t *)&s[0].sa_family = v4;\n    LODWORD(v5) = bind(v3, s, 12u);\n    if (v5 >= 0) {\n      LODWORD(v6) = listen(v3, 5);\n      if (v6 >= 0) {\n        if (signal(SIGCHLD, (void (*)(int))(unsigned int)SIG_IGN) !=\n            (void (*)(int))SIG_ERR) {\n          while (1) {\n            v7 = accept(v3, 0LL, 0LL);\n            if (v7 < 0) break;\n            if (fork() == -1) {\n              perror(\"Errorea umea sortzean\");\n              exit(1);\n            }\n            if (!fork()) {\n              close(v3);\n              while (1) {\n                v8 = read(v7, &s[0].sa_data[10], 1024uLL);\n                if (v8 <= 0) break;\n                if ((int)write(v7, &s[0].sa_data[10], (unsigned int)v8) < v8) {\n                  perror(\"Errorea erantzuna bidaltzean\");\n                  close(v7);\n                  exit(1);\n                }\n              }\n              if (v8) perror(\"Errorea mezua irakurtzean\");\n              close(v7);\n              exit(0);\n            }\n            close(v7);\n          }\n          perror(\"Errorea konexioa onartzean\");\n          exit(1);\n        }\n        perror(\"Errorea signalen\");\n        exit(1);\n      }\n      perror(\"Errorea socketa entzute socket bezala ezartzean\");\n      exit(1);\n    }\n    perror(\"Errorea socketari helbidea esleitzean\");\n    exit(1);\n  }\n  perror(\"Errorea socketa sortzean\");\n  exit(1);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main() {\n  int var1, var2;\n  int var3;\n  struct type1 var4;\n  char var5[1024];\n  if ((var1 = socket(var6, var7, 0)) < 0) {\n    perror(\"Errorea socketa sortzean\");\n    exit(1);\n  }\n  memset(&var4, 0, sizeof(var4));\n  var4.field1 = var6;\n  var4.field2.field3 = htonl(var8);\n  var4.field4 = htons(50004);\n  if (bind(var1, (struct type2 *)&var4, sizeof(var4)) < 0) {\n    perror(\"Errorea socketari helbidea esleitzean\");\n    exit(1);\n  }\n  if (listen(var1, 5) < 0) {\n    perror(\"Errorea socketa entzute socket bezala ezartzean\");\n    exit(1);\n  }\n  if (signal(var9, var10) == var11) {\n    perror(\"Errorea signalen\");\n    exit(1);\n  }\n  while (1) {\n    if ((var2 = accept(var1, NULL, NULL)) < 0) {\n      perror(\"Errorea konexioa onartzean\");\n      exit(1);\n    }\n    if (fork() == -1) {\n      perror(\"Errorea umea sortzean\");\n      exit(1);\n    } else {\n      if (fork() != 0) {\n        close(var2);\n      } else {\n        close(var1);\n        while ((var3 = read(var2, var5, 1024)) > 0) {\n          if (write(var2, var5, var3) < var3) {\n            perror(\"Errorea erantzuna bidaltzean\");\n            close(var2);\n            exit(1);\n          }\n        }\n        if (var3 < 0) perror(\"Errorea mezua irakurtzean\");\n        close(var2);\n        exit(0);\n      }\n    }\n  }\n}", "style": "rule"}, "extra_info": {"index": 109131, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var4 ;\nstruct type2 {int dummy; } ;\nstruct TYPE_2__ {int /*<<< orphan*/  field3; } ;\nstruct type1 {int /*<<< orphan*/  field4; TYPE_1__ field2; int /*<<< orphan*/  field1; } ;\n\n/* Variables and functions */\n int accept (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n scalar_t__ bind (int,struct type2*,int) ; \n int /*<<< orphan*/  close (int) ; \n int /*<<< orphan*/  exit (int) ; \n int fork () ; \n int /*<<< orphan*/  htonl (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  htons (int) ; \n scalar_t__ listen (int,int) ; \n int /*<<< orphan*/  memset (struct type1*,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  perror (char*) ; \n int read (int,char*,int) ; \n scalar_t__ signal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var10 ; \n scalar_t__ var11 ; \n int /*<<< orphan*/  var6 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  var8 ; \n int /*<<< orphan*/  var9 ; \n int write (int,char*,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long ufs_mtk_phy_set_active(long long a1) {\n  mphy_set_bit(a1, (unsigned int)MP_GLB_DIG_8C, (unsigned int)PLL_PWR_ON);\n  mphy_clr_bit(a1, (unsigned int)MP_GLB_DIG_8C, (unsigned int)FRC_FRC_PWR_ON);\n  mphy_clr_bit(a1, (unsigned int)MP_GLB_DIG_8C, (unsigned int)PLL_ISO_EN);\n  mphy_clr_bit(a1, (unsigned int)MP_GLB_DIG_8C, (unsigned int)FRC_PLL_ISO_EN);\n  mphy_set_bit(a1, (unsigned int)MP_LN_RX_44, (unsigned int)CDR_PWR_ON);\n  mphy_clr_bit(a1, (unsigned int)MP_LN_RX_44, (unsigned int)FRC_CDR_PWR_ON);\n  mphy_clr_bit(a1, (unsigned int)MP_LN_RX_44, (unsigned int)CDR_ISO_EN);\n  mphy_clr_bit(a1, (unsigned int)MP_LN_RX_44, (unsigned int)FRC_CDR_ISO_EN);\n  mphy_set_bit(a1, (unsigned int)MP_LN_DIG_RX_AC, (unsigned int)RX_SQ_EN);\n  mphy_clr_bit(a1, (unsigned int)MP_LN_DIG_RX_AC, (unsigned int)FRC_RX_SQ_EN);\n  udelay(1LL);\n  return mphy_clr_bit(a1, (unsigned int)MP_LN_DIG_RX_9C,\n                      (unsigned int)FSM_DIFZ_FRC);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void ufs_mtk_phy_set_active(struct type1 *var1) {\n  mphy_set_bit(var1, var2, var3);\n  mphy_clr_bit(var1, var2, var4);\n  mphy_clr_bit(var1, var2, var5);\n  mphy_clr_bit(var1, var2, var6);\n  mphy_set_bit(var1, var7, var8);\n  mphy_clr_bit(var1, var7, var9);\n  mphy_clr_bit(var1, var7, var10);\n  mphy_clr_bit(var1, var7, var11);\n  mphy_set_bit(var1, var12, var13);\n  mphy_clr_bit(var1, var12, var14);\n  udelay(1);\n  mphy_clr_bit(var1, var15, var16);\n}", "style": "rule"}, "extra_info": {"index": 33978, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {int dummy; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  mphy_clr_bit (struct type1*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  mphy_set_bit (struct type1*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  udelay (int) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n int /*<<< orphan*/  var13 ; \n int /*<<< orphan*/  var14 ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var16 ; \n int /*<<< orphan*/  var2 ; \n int /*<<< orphan*/  var3 ; \n int /*<<< orphan*/  var4 ; \n int /*<<< orphan*/  var5 ; \n int /*<<< orphan*/  var6 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  var8 ; \n int /*<<< orphan*/  var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long GetKeyName(unsigned int a1) {\n  long long LastError;\n  unsigned int v2;\n  long long v3;\n  long long v4;\n  unsigned int v5;\n  unsigned int v6;\n  unsigned int ProcessHeap;\n  long long v8;\n  unsigned int v9;\n  unsigned int v10;\n  unsigned int v11;\n  int v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  v14 = TRUE;\n  v13 = 0;\n  v15 = 0LL;\n  v16 = OpenSCManager(0LL, 0LL, (unsigned int)SC_MANAGER_CONNECT);\n  if (!v16) {\n    LastError = GetLastError();\n    v2 = T(\"[SC] OpenSCManager FAILED %lu:\\n\\n\", 0LL);\n    tprintf(v2, LastError);\n    v14 = FALSE;\n    goto LABEL_10;\n  }\n  v3 = a1;\n  if (!(unsigned int)GetServiceKeyName(v16, a1, 0LL, &v13) && !v13)\n    goto LABEL_5;\n  v6 = 4 * (v13 + 1);\n  ProcessHeap = GetProcessHeap();\n  v15 = HeapAlloc(ProcessHeap, 0LL, v6);\n  if (v15) {\n    ++v13;\n    v3 = a1;\n    if (!(unsigned int)GetServiceKeyName(v16, a1, v15, &v13)) {\n    LABEL_5:\n      v4 = GetLastError();\n      v5 = T(\"[SC] GetServiceKeyName FAILED %lu:\\n\\n\", v3);\n      tprintf(v5, v4);\n      v14 = FALSE;\n      goto LABEL_10;\n    }\n    v10 = T(\"[SC] GetServiceKeyName SUCCESS  Name = %s\\n\", (const char *)a1);\n    tprintf(v10, v15);\n  } else {\n    SetLastError((unsigned int)ERROR_OUTOFMEMORY);\n    v8 = GetLastError();\n    v9 = T(\"[SC] HeapAlloc FAILED %lu:\\n\\n\", 0LL);\n    tprintf(v9, v8);\n    v14 = FALSE;\n  }\nLABEL_10:\n  if (v14 == FALSE) ReportLastError();\n  if (v15) {\n    v11 = GetProcessHeap();\n    HeapFree(v11, 0LL, v15);\n  }\n  if (v16) CloseServiceHandle(v16);\n  return v14;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 GetKeyName(type2 var1) {\n  type3 var2 = NULL;\n  type1 var3 = TRUE;\n  type4 var4 = 0;\n  type5 var5 = NULL;\n  var2 = OpenSCManager(NULL, NULL, var6);\n  if (var2 == NULL) {\n    func1(func2(\"[SC] OpenSCManager FAILED %lu:\\n\\n\"), GetLastError());\n    var3 = FALSE;\n    goto done;\n  }\n  if (!GetServiceKeyName(var2, var1, NULL, &var4)) {\n    if (var4 == 0) {\n      func1(func2(\"[SC] GetServiceKeyName FAILED %lu:\\n\\n\"), GetLastError());\n      var3 = FALSE;\n      goto done;\n    }\n  }\n  var5 = HeapAlloc(GetProcessHeap(), 0, (var4 + 1) * sizeof(var7));\n  if (var5 == NULL) {\n    SetLastError(var8);\n    func1(func2(\"[SC] HeapAlloc FAILED %lu:\\n\\n\"), GetLastError());\n    var3 = FALSE;\n    goto done;\n  }\n  var4++;\n  if (!GetServiceKeyName(var2, var1, var5, &var4)) {\n    func1(func2(\"[SC] GetServiceKeyName FAILED %lu:\\n\\n\"), GetLastError());\n    var3 = FALSE;\n    goto done;\n  }\n  func1(func2(\"[SC] GetServiceKeyName SUCCESS  Name = %s\\n\"), var5);\ndone:\n  if (var3 == FALSE) ReportLastError();\n  if (var5 != NULL) HeapFree(GetProcessHeap(), 0, var5);\n  if (var2) CloseServiceHandle(var2);\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 73571, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var7 ;\ntypedef  int /*<<< orphan*/ * type5 ;\ntypedef  int type4 ;\ntypedef  int /*<<< orphan*/ * type3 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  scalar_t__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  CloseServiceHandle (int /*<<< orphan*/ *) ; \n scalar_t__ FALSE ; \n int /*<<< orphan*/ * GetLastError () ; \n int /*<<< orphan*/  GetProcessHeap () ; \n int /*<<< orphan*/  GetServiceKeyName (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int*) ; \n int /*<<< orphan*/ * HeapAlloc (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  HeapFree (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * OpenSCManager (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  ReportLastError () ; \n int /*<<< orphan*/  SetLastError (int /*<<< orphan*/ ) ; \n scalar_t__ TRUE ; \n int /*<<< orphan*/  func1 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  func2 (char*) ; \n int /*<<< orphan*/  var6 ; \n int /*<<< orphan*/  var8 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long reduceset(unsigned int *a1) {\n  int v1;\n  int v2;\n  uint64_t *v3;\n  unsigned int v4;\n  signed int v5;\n  uint64_t *v6;\n  uint64_t *v7;\n  long long v8;\n  unsigned int v9;\n  signed int v10;\n  uint64_t *v11;\n  uint64_t *v12;\n  long long v13;\n  int v15;\n  int v16;\n  uint64_t *v17;\n  long long v18;\n  uint64_t *v19;\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  if (a1[8]) {\n    v18 = *((uint64_t *)a1 + 5);\n    v19 = (uint64_t *)*((uint64_t *)a1 + 6);\n    v17 = (uint64_t *)findvect(*a1, v18, v19);\n    if (v17) {\n      if (*v17 > *((uint64_t *)a1 + 1)) improvesol(a1, v17);\n    } else {\n      v17 = (uint64_t *)(v18 - 16);\n    }\n    expandcore(a1, &v15, &v16);\n    v1 = *a1;\n    v2 = *((uint64_t *)a1 + 1) + 1;\n    v3 = (uint64_t *)*((uint64_t *)a1 + 7);\n    if (!v15) {\n      v4 = a1[4];\n      v5 = a1[5];\n      v6 = v19;\n      v7 = v17;\n      while (v6 != v7) {\n        if ((*v6 - v2) * v5 - (int)(v4 * (*((uint32_t *)v6 + 2) - v1)) >= 0LL) {\n          v3 -= 2;\n          v8 = v6[1];\n          *v3 = *v6;\n          v3[1] = v8;\n        }\n        v6 -= 2;\n      }\n    }\n    if (!v16) {\n      v9 = a1[6];\n      v10 = a1[7];\n      v11 = v17;\n      v12 = (uint64_t *)(v18 - 16);\n      while (v11 != v12) {\n        if ((*v11 - v2) * v10 - (int)(v9 * (*((uint32_t *)v11 + 2) - v1)) >=\n            0LL) {\n          v3 -= 2;\n          v13 = v11[1];\n          *v3 = *v11;\n          v3[1] = v13;\n        }\n        v11 -= 2;\n      }\n    }\n    *((uint64_t *)a1 + 5) = v3;\n    *((uint64_t *)a1 + 6) = *((uint64_t *)a1 + 7) - 16LL;\n    a1[8] = (*((uint64_t *)a1 + 6) + 16LL - *((uint64_t *)a1 + 5)) >> 4;\n  }\n  return v20 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void reduceset(type1 *var1) {\n  register type2 *var2, *var3, *var4;\n  register type3 var5, var6;\n  register type4 var7, var8;\n  type2 *var9, *var10, *var11;\n  type5 var12, var13;\n  if (var1->field1.field2 == 0) return;\n  var10 = var1->field1.field3;\n  var11 = var1->field1.field4;\n  var9 = findvect(var1->field5, var10, var11);\n  if (var9 == NULL)\n    var9 = var10 - 1;\n  else if (var9->field6 > var1->field7)\n    improvesol(var1, var9);\n  expandcore(var1, &var12, &var13);\n  var5 = var1->field5;\n  var6 = var1->field7 + 1;\n  var4 = var1->field1.field8;\n  if (!var12) {\n    var7 = var1->field9;\n    var8 = var1->field10;\n    for (var2 = var11, var3 = var9; var2 != var3; var2--) {\n      if (((var2->field6 - var6) * (type4)(type6) -\n           (var2->field11 - var5) * (var14)(var7)) >= 0) {\n        var4--;\n        *var4 = *var2;\n      }\n    }\n  }\n  if (!var13) {\n    var7 = var1->field12;\n    var8 = var1->field13;\n    for (var2 = var9, var3 = var10 - 1; var2 != var3; var2--) {\n      if (((var2->field6 - var6) * (type4)(type6) -\n           (var2->field11 - var5) * (var14)(var7)) >= 0) {\n        var4--;\n        *var4 = *var2;\n      }\n    }\n  }\n  var1->field1.field3 = var4;\n  var1->field1.field4 = var1->field1.field8 - 1;\n  var1->field1.field2 =\n      ((int)(((var1->field1.field4) + 1) - (var1->field1.field3)));\n}", "style": "rule"}, "extra_info": {"index": 49853, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int var14 ;\ntypedef  scalar_t__ type6 ;\ntypedef  int /*<<< orphan*/  type5 ;\ntypedef  int type4 ;\ntypedef  int type3 ;\nstruct TYPE_12__ {scalar_t__ field6; int field11; } ;\ntypedef  TYPE_2__ type2 ;\nstruct TYPE_11__ {int field2; TYPE_2__* field3; TYPE_2__* field4; TYPE_2__* field8; } ;\nstruct TYPE_13__ {int field5; scalar_t__ field7; int field9; int field10; int field12; int field13; TYPE_1__ field1; } ;\ntypedef  TYPE_3__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  expandcore (TYPE_3__*,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n TYPE_2__* findvect (int,TYPE_2__*,TYPE_2__*) ; \n int /*<<< orphan*/  improvesol (TYPE_3__*,TYPE_2__*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  struct sockaddr s[3];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  memset(s, 0, 12uLL);\n  *(uint32_t *)&s[0].sa_data[6] = AF_INET;\n  *(uint32_t *)&s[0].sa_data[2] = htonl(INADDR_ANY);\n  LOWORD(v3) = htons(6970u);\n  *(uint32_t *)&s[0].sa_family = v3;\n  v4 = socket(AF_INET, SOCK_STREAM, 0);\n  bind(v4, s, 12u);\n  listen(v4, 10);\n  v5 = accept(v4, 0LL, 0LL);\n  while (1) {\n    recv(v5, &s[0].sa_data[10], 30uLL, 0);\n    parse_gesture(&s[0].sa_data[10]);\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main() {\n  unsigned char var1[30];\n  struct type1 var2;\n  memset(&var2, 0, sizeof(struct type1));\n  var2.field1 = var3;\n  var2.field2.field3 = htonl(var4);\n  var2.field4 = htons(6970);\n  int var5 = socket(var3, var6, 0);\n  bind(var5, (struct type2 *)&var2, sizeof(var2));\n  listen(var5, 10);\n  int var7 = accept(var5, (struct type2 *)NULL, NULL);\n  while (1) {\n    recv(var7, var1, 30, 0);\n    parse_gesture(var1);\n  }\n  func1(var7);\n  func1(var5);\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 70608, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var2 ;\nstruct type2 {int dummy; } ;\nstruct TYPE_2__ {int /*<<< orphan*/  field3; } ;\nstruct type1 {int /*<<< orphan*/  field4; TYPE_1__ field2; int /*<<< orphan*/  field1; } ;\n\n/* Variables and functions */\n int accept (int,struct type2*,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  bind (int,struct type2*,int) ; \n int /*<<< orphan*/  func1 (int) ; \n int /*<<< orphan*/  htonl (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  htons (int) ; \n int /*<<< orphan*/  listen (int,int) ; \n int /*<<< orphan*/  memset (struct type1*,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  parse_gesture (unsigned char*) ; \n int /*<<< orphan*/  recv (int,unsigned char*,int,int /*<<< orphan*/ ) ; \n int socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var3 ; \n int /*<<< orphan*/  var4 ; \n int /*<<< orphan*/  var6 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long buffer_path_simplify(char **a1, char **a2) {\n  long long v3;\n  char *v4;\n  char *v5;\n  char i;\n  char *v7;\n  char *v8;\n  char v9;\n  unsigned long long v10;\n  char v11;\n  long long v12;\n  int v14;\n  if (a1 && a2) {\n    if (!buffer_string_is_empty(a2)) goto LABEL_4;\n    return buffer_string_prepare_copy(a1, 0LL);\n  }\n  log_failed_assert(\n      \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/\"\n      \"2022-01-22/02-19-57/repos/PatchyFog/lighttpd1.4-mbed\"\n      \"tls/refs/heads/master/src/buffer.c\",\n      889LL, \"assertion failed: NULL != dest && NULL != src\");\n  if (buffer_string_is_empty(a2)) return buffer_string_prepare_copy(a1, 0LL);\nLABEL_4:\n  if ((*a2)[*((int *)a2 + 2) - 1]) {\n    log_failed_assert(\n        \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/\"\n        \"2022-01-22/02-19-57/repos/PatchyFog/lighttpd1.4-mb\"\n        \"edtls/refs/heads/master/src/buffer.c\",\n        896LL, \"assertion failed: '\\\\0' == src->ptr[src->used-1]\");\n    if (a1 != a2) goto LABEL_6;\n  LABEL_36:\n    buffer_string_prepare_append(a1, 1LL);\n    goto LABEL_7;\n  }\n  if (a1 == a2) goto LABEL_36;\nLABEL_6:\n  v3 = buffer_string_length(a2);\n  buffer_string_prepare_copy(a1, v3 + 1);\nLABEL_7:\n  v4 = *a2;\n  v5 = *a1;\n  for (i = **a2; i == 32; ++v4) i = v4[1];\n  v7 = v4 + 1;\n  if (i == 47) {\n    v8 = *a1;\n    v9 = 0;\n  } else {\n    *v5 = 47;\n    v8 = v5 + 1;\n    if (!i) {\n      v12 = 1LL;\n      return buffer_string_set_length(a1, v12);\n    }\n    v9 = 47;\n  }\n  v10 = (unsigned long long)v5;\n  while (1) {\n    v11 = *v7;\n    *v8++ = i;\n    ++v7;\n    if (v11 != 47 && v11) goto LABEL_13;\n    if (&v8[-v10] != (uint8_t *)buffer_path_simplify + 3 || v9 != 46) break;\n    if (i == 46) {\n      LODWORD(v8) = v10 + 1;\n      if ((unsigned long long)v5 < v10) {\n        v8 = (char *)(v10 - 1);\n        if ((unsigned long long)v5 < v10 - 1) {\n          while (1) {\n            if (*v8 == 47) {\n              v10 = (unsigned long long)v8;\n              LODWORD(v8) = (uint32_t)v8 + 1;\n              goto LABEL_27;\n            }\n            if (v5 == v8 - 1) break;\n            --v8;\n          }\n          v10 = (unsigned long long)v5;\n        } else {\n          v14 = v10--;\n          LODWORD(v8) = v14;\n        }\n      }\n    LABEL_27:\n      if (!v11) goto LABEL_24;\n      goto LABEL_28;\n    }\n  LABEL_19:\n    if (!v11) goto LABEL_24;\n    v10 = (unsigned long long)v8;\n  LABEL_13:\n    v9 = i;\n    i = v11;\n  }\n  if (&v8[-v10] != (uint8_t *)buffer_path_simplify + 1 && (v9 != 47 || i != 46))\n    goto LABEL_19;\n  if (v11) {\n  LABEL_28:\n    v8 = (char *)v10;\n    goto LABEL_13;\n  }\n  LODWORD(v8) = v10 + 1;\nLABEL_24:\n  v12 = (unsigned int)((uint32_t)v8 - (uint32_t)v5);\n  return buffer_string_set_length(a1, v12);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void buffer_path_simplify(type1 *var1, type1 *var2) {\n  char var3, var4, var5;\n  char *var6, *var7, *var8, *var9;\n  do {\n    if (!(NULL != var1 && NULL != var2))\n      log_failed_assert(\n          \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/\"\n          \"2022-01-22/02-19-57/repos/PatchyFog/lighttpd1.4-mbedtls/refs/heads/\"\n          \"master/src/buffer.c\",\n          889,\n          \"assertion failed: \"\n          \"NULL != dest && NULL != src\");\n  } while (0);\n  if (buffer_string_is_empty(var2)) {\n    buffer_string_prepare_copy(var1, 0);\n    return;\n  }\n  do {\n    if (!('\\0' == var2->field1[var2->field2 - 1]))\n      log_failed_assert(\n          \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/\"\n          \"2022-01-22/02-19-57/repos/PatchyFog/lighttpd1.4-mbedtls/refs/heads/\"\n          \"master/src/buffer.c\",\n          896,\n          \"assertion failed: \"\n          \"'\\\\0' == src->ptr[src->used-1]\");\n  } while (0);\n  if (var2 == var1) {\n    buffer_string_prepare_append(var1, 1);\n  } else {\n    buffer_string_prepare_copy(var1, buffer_string_length(var2) + 1);\n  }\n# 915 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/PatchyFog/lighttpd1.4-mbedtls/refs/heads/master/src/buffer.c\"\n  var8 = var2->field1;\n  var6 = var1->field1;\n  var9 = var1->field1;\n  var7 = var1->field1;\n  while (*var8 == ' ') {\n    var8++;\n  }\n  var4 = 0;\n  var3 = *(var8++);\n  if (var3 != '/') {\n    var4 = '/';\n    *(var9++) = '/';\n  }\n  while (var3 != '\\0') {\n    var5 = var4;\n    var4 = var3;\n    var3 = *var8;\n    *var9 = var4;\n    var9++;\n    var8++;\n    if (var3 == '/' || var3 == '\\0') {\n      const size_t var10 = var9 - var7;\n      if (var10 == 3 && var5 == '.' && var4 == '.') {\n        var9 = var7;\n        if (var9 > var6) {\n          var9--;\n          while (var9 > var6 && *var9 != '/') var9--;\n        }\n        if (var3 == '\\0') var9++;\n      } else if (var10 == 1 || (var5 == '/' && var4 == '.')) {\n        var9 = var7;\n        if (var3 == '\\0') var9++;\n      }\n      var7 = var9;\n    }\n  }\n  buffer_string_set_length(var1, var9 - var6);\n}", "style": "rule"}, "extra_info": {"index": 36943, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {char* field1; int field2; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n scalar_t__ buffer_string_is_empty (TYPE_1__*) ; \n scalar_t__ buffer_string_length (TYPE_1__*) ; \n int /*<<< orphan*/  buffer_string_prepare_append (TYPE_1__*,int) ; \n int /*<<< orphan*/  buffer_string_prepare_copy (TYPE_1__*,scalar_t__) ; \n int /*<<< orphan*/  buffer_string_set_length (TYPE_1__*,int) ; \n int /*<<< orphan*/  log_failed_assert (char*,int,char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long bta_ag_sdp_find_attr(long long a1, int a2) {\n  int v3;\n  uint64_t *v4;\n  long long ServiceInDb;\n  long long v6;\n  long long v7;\n  long long AttributeInRec;\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  ServiceInDb = 0LL;\n  v7 = FALSE;\n  if ((a2 & BTA_HFP_SERVICE_MASK) != 0) {\n    v6 = UUID_SERVCLASS_HF_HANDSFREE;\n    *(uint32_t *)a1 = HFP_VERSION_1_1;\n  LABEL_23:\n    while (TRUE) {\n      ServiceInDb =\n          SDP_FindServiceInDb(*(unsigned int *)(a1 + 32), v6, ServiceInDb);\n      if (!ServiceInDb) {\n        if (v6 != UUID_SERVCLASS_HEADSET_HS) break;\n        v6 = UUID_SERVCLASS_HEADSET;\n        ServiceInDb = SDP_FindServiceInDb(*(unsigned int *)(a1 + 32),\n                                          UUID_SERVCLASS_HEADSET, ServiceInDb);\n        if (!ServiceInDb) break;\n      }\n      if (*(uint64_t *)(a1 + 8) != BTA_AG_INT) goto LABEL_13;\n      if (SDP_FindProtocolListElemInRec(\n              ServiceInDb, (unsigned int)UUID_PROTOCOL_RFCOMM, &v4)) {\n        *(uint64_t *)(a1 + 24) = *v4;\n      LABEL_13:\n        SDP_FindProfileVersionInRec(ServiceInDb, v6, a1);\n        if ((a2 & BTA_HFP_SERVICE_MASK) != 0) {\n          AttributeInRec = SDP_FindAttributeInRec(\n              ServiceInDb, (unsigned int)ATTR_ID_SUPPORTED_FEATURES);\n          if (AttributeInRec) {\n            if (!*(uint32_t *)(a1 + 16))\n              *(uint32_t *)(a1 + 16) = *(uint32_t *)(AttributeInRec + 8);\n          }\n        } else {\n          AttributeInRec = SDP_FindAttributeInRec(\n              ServiceInDb, (unsigned int)ATTR_ID_REMOTE_AUDIO_VOLUME_CONTROL);\n          if (AttributeInRec) {\n            if (*(uint64_t *)AttributeInRec)\n              v3 = BTA_AG_PEER_FEAT_VOL | *(uint32_t *)(a1 + 16);\n            else\n              v3 = ~BTA_AG_PEER_FEAT_VOL & *(uint32_t *)(a1 + 16);\n            *(uint32_t *)(a1 + 16) = v3;\n          }\n        }\n        return TRUE;\n      }\n    }\n    return v7;\n  } else {\n    if ((a2 & BTA_HSP_SERVICE_MASK) != 0 &&\n        *(uint64_t *)(a1 + 8) == BTA_AG_INT) {\n      v6 = UUID_SERVCLASS_HEADSET_HS;\n      *(uint32_t *)a1 = 256;\n      goto LABEL_23;\n    }\n    return v7;\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 bta_ag_sdp_find_attr(type2 *var1, type3 var2) {\n  type4 *var3 = NULL;\n  type5 *var4;\n  type6 var5;\n  type7 var6;\n  type1 var7 = FALSE;\n  if (var2 & var8) {\n    var6 = var9;\n    var1->field1 = var10;\n  } else if (var2 & var11 && var1->field2 == var12) {\n    var6 = var13;\n    var1->field1 = 0x0100;\n  } else {\n    return var7;\n  }\n  while (TRUE) {\n    if ((var3 = SDP_FindServiceInDb(var1->field3, var6, var3)) == NULL) {\n      if (var6 == var13) {\n        var6 = var14;\n        if ((var3 = SDP_FindServiceInDb(var1->field3, var6, var3)) == NULL) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (var1->field2 == var12) {\n      if (SDP_FindProtocolListElemInRec(var3, var15, &var5)) {\n        var1->field4 = (type8)var5.field5[0];\n      } else {\n        continue;\n      }\n    }\n    SDP_FindProfileVersionInRec(var3, var6, &var1->field1);\n    if (var2 & var8) {\n      if ((var4 = SDP_FindAttributeInRec(var3, var16)) != NULL) {\n        if (var1->field6 == 0) var1->field6 = var4->field7.field8.field9;\n      }\n    } else {\n      if ((var4 = SDP_FindAttributeInRec(var3, var17)) != NULL) {\n        if (var4->field7.field8.field10) {\n          var1->field6 |= var18;\n        } else {\n          var1->field6 &= ~var18;\n        }\n      }\n    }\n    var7 = TRUE;\n    break;\n  }\n  return var7;\n}", "style": "rule"}, "extra_info": {"index": 50289, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_5__ ;\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ type8 ;\ntypedef  scalar_t__ type7 ;\nstruct TYPE_11__ {scalar_t__* field5; } ;\ntypedef  TYPE_3__ type6 ;\nstruct TYPE_9__ {scalar_t__ field10; int /*<<< orphan*/  field9; } ;\nstruct TYPE_10__ {TYPE_1__ field8; } ;\nstruct TYPE_12__ {TYPE_2__ field7; } ;\ntypedef  TYPE_4__ type5 ;\ntypedef  int /*<<< orphan*/  type4 ;\ntypedef  int type3 ;\nstruct TYPE_13__ {int field1; scalar_t__ field2; int /*<<< orphan*/  field6; scalar_t__ field4; int /*<<< orphan*/  field3; } ;\ntypedef  TYPE_5__ type2 ;\ntypedef  scalar_t__ type1 ;\n\n/* Variables and functions */\n scalar_t__ FALSE ; \n TYPE_4__* SDP_FindAttributeInRec (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  SDP_FindProfileVersionInRec (int /*<<< orphan*/ *,scalar_t__,int*) ; \n scalar_t__ SDP_FindProtocolListElemInRec (int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_3__*) ; \n int /*<<< orphan*/ * SDP_FindServiceInDb (int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ *) ; \n scalar_t__ TRUE ; \n int var10 ; \n int var11 ; \n scalar_t__ var12 ; \n scalar_t__ var13 ; \n scalar_t__ var14 ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var16 ; \n int /*<<< orphan*/  var17 ; \n int /*<<< orphan*/  var18 ; \n int var8 ; \n scalar_t__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nchar *cin_com_set_string(const char *a1, const char *a2) {\n  unsigned int v2;\n  const char *size_4;\n  char *dest;\n  if (a1) {\n    size_4 = a1;\n    v2 = strlen(a1);\n  } else {\n    size_4 = a2;\n    v2 = strlen(a2);\n  }\n  dest = (char *)malloc(v2);\n  if (!dest) return 0LL;\n  strcpy(dest, size_4);\n  return dest;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "char *cin_com_set_string(char *var1, char *var2) {\n  char *var3, *var4;\n  if (var1 != NULL) {\n    var3 = var1;\n  } else {\n    var3 = var2;\n  }\n  int var5;\n  var5 = strlen(var3);\n  var4 = malloc(sizeof(char) * var5);\n  if (var4 == NULL) {\n    return NULL;\n  }\n  strcpy(var4, var3);\n  return var4;\n}", "style": "rule"}, "extra_info": {"index": 30681, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n char* malloc (int) ; \n int /*<<< orphan*/  strcpy (char*,char*) ; \n int strlen (char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long b43legacy_pio_free(uint64_t *a1) {\n  long long result;\n  result = b43legacy_using_pio();\n  if ((uint32_t)result) {\n    b43legacy_destroy_pioqueue(a1[3]);\n    a1[3] = 0LL;\n    b43legacy_destroy_pioqueue(a1[2]);\n    a1[2] = 0LL;\n    b43legacy_destroy_pioqueue(a1[1]);\n    a1[1] = 0LL;\n    result = b43legacy_destroy_pioqueue(*a1);\n    *a1 = 0LL;\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void b43legacy_pio_free(struct type1 *var1) {\n  struct type2 *var2;\n  if (!b43legacy_using_pio(var1)) return;\n  var2 = &var1->field1;\n  b43legacy_destroy_pioqueue(var2->field2);\n  var2->field2 = NULL;\n  b43legacy_destroy_pioqueue(var2->field3);\n  var2->field3 = NULL;\n  b43legacy_destroy_pioqueue(var2->field4);\n  var2->field4 = NULL;\n  b43legacy_destroy_pioqueue(var2->field5);\n  var2->field5 = NULL;\n}", "style": "rule"}, "extra_info": {"index": 82390, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type2 {int /*<<< orphan*/ * field5; int /*<<< orphan*/ * field4; int /*<<< orphan*/ * field3; int /*<<< orphan*/ * field2; } ;\nstruct type1 {struct type2 field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  b43legacy_destroy_pioqueue (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  b43legacy_using_pio (struct type1*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long test_uncovered_buffer(long long a1) {\n  long long top;\n  uint64_t v3[5];\n  v3[1] = __readfsqword(40u);\n  duk_push_dynamic_buffer(a1, 64LL);\n  duk_eval_string(\n      a1,\n      \"(function (plain_buffer) {\\n    var b = plain_buffer.buffer;\\n    \"\n      \"return new Uint32Array(b).subarray(1,5);\\n})\");\n  duk_dup(a1, 0LL);\n  duk_call(a1, 1LL);\n  v3[0] = 3735928559LL;\n  if (duk_get_buffer_data_default(a1, 4294967295LL, v3, 305419896LL,\n                                  2271560481LL))\n    printf(\"p is not NULL, sz=%lu\\n\", v3[0]);\n  else\n    puts(\"p is NULL\");\n  duk_resize_buffer(a1, 0LL, 20LL);\n  v3[0] = 3735928559LL;\n  if (duk_get_buffer_data_default(a1, 4294967295LL, v3, 305419896LL,\n                                  2271560481LL))\n    printf(\"p is not NULL, sz=%lu\\n\", v3[0]);\n  else\n    puts(\"p is NULL\");\n  duk_resize_buffer(a1, 0LL, 19LL);\n  v3[0] = 3735928559LL;\n  if (duk_get_buffer_data_default(a1, 4294967295LL, v3, 305419896LL,\n                                  2271560481LL))\n    printf(\"p is not NULL, sz=%lu\\n\", v3[0]);\n  else\n    puts(\"p is NULL\");\n  top = duk_get_top(a1);\n  printf(\"final top: %ld\\n\", top);\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static type1 test_uncovered_buffer(type2 *var1, void *var2) {\n  unsigned char *var3;\n  type3 var4;\n  (void)var2;\n  duk_push_dynamic_buffer(var1, 64);\n  duk_eval_string(var1,\n                  \"(function (plain_buffer) {\\n\"\n                  \"    var b = plain_buffer.buffer;\\n\"\n                  \"    return new Uint32Array(b).subarray(1,5);\\n\"\n                  \"})\");\n  duk_dup(var1, 0);\n  duk_call(var1, 1);\n  var4 = (type3)0xdeadbeefUL;\n  var3 = duk_get_buffer_data_default(var1, -1, &var4, (void *)0x12345678UL,\n                                     (type3)0x87654321UL);\n  if (var3) {\n    printf(\"p is not NULL, sz=%lu\\n\", (unsigned long)var4);\n  } else {\n    printf(\"p is NULL\\n\");\n  }\n  duk_resize_buffer(var1, 0, 20);\n  var4 = (type3)0xdeadbeefUL;\n  var3 = duk_get_buffer_data_default(var1, -1, &var4, (void *)0x12345678UL,\n                                     (type3)0x87654321UL);\n  if (var3) {\n    printf(\"p is not NULL, sz=%lu\\n\", (unsigned long)var4);\n  } else {\n    printf(\"p is NULL\\n\");\n  }\n  duk_resize_buffer(var1, 0, 19);\n  var4 = (type3)0xdeadbeefUL;\n  var3 = duk_get_buffer_data_default(var1, -1, &var4, (void *)0x12345678UL,\n                                     (type3)0x87654321UL);\n  if (var3) {\n    printf(\"p is not NULL, sz=%lu\\n\", (unsigned long)var4);\n  } else {\n    printf(\"p is NULL\\n\");\n  }\n  printf(\"final top: %ld\\n\", (long)duk_get_top(var1));\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 18697, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ type3 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  duk_call (int /*<<< orphan*/ *,int) ; \n int /*<<< orphan*/  duk_dup (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  duk_eval_string (int /*<<< orphan*/ *,char*) ; \n unsigned char* duk_get_buffer_data_default (int /*<<< orphan*/ *,int,scalar_t__*,void*,scalar_t__) ; \n scalar_t__ duk_get_top (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  duk_push_dynamic_buffer (int /*<<< orphan*/ *,int) ; \n int /*<<< orphan*/  duk_resize_buffer (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long match_string(long long a1, unsigned long long a2, const char *a3) {\n  unsigned int i;\n  char *s1;\n  for (i = 0; a2 > (int)i; ++i) {\n    s1 = *(char **)(8LL * (int)i + a1);\n    if (!s1) break;\n    if (!strcmp(s1, a3)) return i;\n  }\n  return (unsigned int)-EINVAL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int match_string(const char *const *var1, size_t var2, const char *var3) {\n  int var4;\n  const char *var5;\n  for (var4 = 0; var4 < var2; var4++) {\n    var5 = var1[var4];\n    if (!var5) break;\n    if (!strcmp(var5, var3)) return var4;\n  }\n  return -var6;\n}", "style": "rule"}, "extra_info": {"index": 93423, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  strcmp (char const*,char const*) ; \n int var6 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid __noreturn set_lookup_docids(uint64_t *a1, long long a2, long long a3,\n                                  long long a4, double a5) {\n  double v5;\n  int v6;\n  int v7;\n  long long v8;\n  double v9;\n  long long v10;\n  double v11;\n  double v12;\n  int v13;\n  double v14;\n  char v15;\n  char v16;\n  long long v17;\n  double v18;\n  long long v19;\n  double v20;\n  char v21;\n  char v22;\n  double v23;\n  double v24;\n  long long v25;\n  long long v26;\n  long long v27;\n  char v30;\n  *a1 = a3;\n  a1[1] = a4;\n  v5 = log2(a5);\n  ceil(v5);\n  v7 = v6;\n  v8 = a1[1];\n  if (v8 < 0) {\n    v10 = a1[1] & 1LL | ((unsigned long long)v8 >> 1);\n    v9 = (double)(int)v10 + (double)(int)v10;\n  } else {\n    v9 = (double)(int)v8;\n  }\n  v11 = log2(v9);\n  v12 = ceil(v11);\n  if (v7 - v13 <= 0) {\n    v22 = 1;\n  } else {\n    v14 = log2(v12);\n    ceil(v14);\n    v16 = v15;\n    v17 = a1[1];\n    if (v17 < 0) {\n      v19 = a1[1] & 1LL | ((unsigned long long)v17 >> 1);\n      v18 = (double)(int)v19 + (double)(int)v19;\n    } else {\n      v18 = (double)(int)v17;\n    }\n    v20 = log2(v18);\n    v12 = ceil(v20);\n    v22 = v16 - v21;\n  }\n  v30 = v22;\n  v23 = log2(v12);\n  v24 = ceil(v23);\n  a1[2] = malloc(4 * ((unsigned int)(1LL << v30) + 1));\n  assert(a1[2], a2, a1, v25, v26, v27, v24, a4, a3, a2);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void set_lookup_docids(type1 *var1, type2 *var2, uint32_t *var3, size_t var4) {\n  int var5;\n  int var6;\n  size_t var7;\n  size_t var8;\n  size_t var9;\n  uint32_t var10 = var2->field1;\n  var1->field2 = var3;\n  var1->field3 = var4;\n  unsigned int var11 =\n      (((1 > ((int)ceil(log2(((1 > var10) ? 1 : var10)))) -\n                 (int)ceil(log2(var10 * (double)16 / var1->field3)))\n            ? 1\n            : ((int)ceil(log2(((1 > var10) ? 1 : var10)))) -\n                  (int)ceil(log2(var10 * (double)16 / var1->field3))));\n  var6 = (((int)ceil(log2(((1 > var10) ? 1 : var10)))) - var11);\n  var7 = (1L << var11);\n  var1->field4 = malloc(sizeof(uint32_t) * (var7 + 1));\n  assert(var1->field4);\n  var8 = 0;\n  var9 = 0;\n  for (var5 = 0; var5 < var7; var5++) {\n    while (var8 < var1->field3 && var1->field2[var8] >> var6 == var5) {\n      var8++;\n    }\n    var1->field4[var5] = var9;\n    var9 = var8;\n  }\n  var1->field4[var7] = var4;\n}", "style": "rule"}, "extra_info": {"index": 80846, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint32_t ;\nstruct TYPE_5__ {int field1; } ;\ntypedef  TYPE_1__ type2 ;\nstruct TYPE_6__ {int* field2; size_t field3; size_t* field4; } ;\ntypedef  TYPE_2__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  assert (size_t*) ; \n scalar_t__ ceil (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  log2 (int) ; \n size_t* malloc (int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint print_array(int *a1, int a2) {\n  int *v3;\n  int v4;\n  v3 = a1;\n  printf(\"Array : \");\n  if (a2 > 0) {\n    do {\n      v4 = *v3++;\n      printf(\"%d\\t\", v4);\n    } while (v3 != &a1[a2 - 1 + 1]);\n  }\n  return putchar(10);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void print_array(int var1[], int var2) {\n  int var3;\n  printf(\"Array : \");\n  for (var3 = 0; var3 < var2; var3++) printf(\"%d\\t\", var1[var3]);\n  printf(\"\\n\");\n}", "style": "rule"}, "extra_info": {"index": 43596, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long TapeRewind() {\n  *((uint64_t *)&tape + 13) = 0LL;\n  *((uint64_t *)&tape + 12) = 0LL;\n  *((uint64_t *)&tape + 11) = 0LL;\n  *((uint64_t *)&tape + 10) = 0LL;\n  *((uint64_t *)&tape + 9) = 0LL;\n  *((uint64_t *)&tape + 8) = 0LL;\n  *((uint64_t *)&tape + 7) = 0LL;\n  *((uint64_t *)&tape + 6) = 0LL;\n  *(&tape + 10) = global != 0;\n  *((uint64_t *)&tape + 4) = 0LL;\n  *((uint64_t *)&tape + 3) = 0LL;\n  *((uint64_t *)&tape + 2) = 0LL;\n  tape = -1;\n  *((uint64_t *)&tape + 1) = 0LL;\n  return InitRND((unsigned int)*(&tape + 1));\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void TapeRewind() {\n  var1.field1 = 0;\n  var1.field2 = 0;\n  var1.field3 = 0;\n  var1.field4 = 0;\n  var1.field5 = 0;\n  var1.field6 = 0;\n  var1.field7 = 0;\n  var1.field8 = 0;\n  var1.field9 = (var2.field10 != NULL);\n  var1.field11 = 0;\n  var1.field12 = 0;\n  var1.field13 = 0;\n  var1.field14 = -1;\n  var1.field15 = 0;\n  InitRND(var1.field16);\n}", "style": "rule"}, "extra_info": {"index": 48597, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int field14; int /*<<< orphan*/  field16; scalar_t__ field15; scalar_t__ field13; scalar_t__ field12; scalar_t__ field11; int /*<<< orphan*/  field9; scalar_t__ field8; scalar_t__ field7; scalar_t__ field6; scalar_t__ field5; scalar_t__ field4; scalar_t__ field3; scalar_t__ field2; scalar_t__ field1; } ;\nstruct TYPE_3__ {int /*<<< orphan*/ * field10; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  InitRND (int /*<<< orphan*/ ) ; \n TYPE_2__ var1 ; \n TYPE_1__ var2 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long from_oct(int a1, unsigned char *a2) {\n  long long v4;\n  unsigned int v5;\n  unsigned char *v6;\n  unsigned char v7;\n  unsigned char v8;\n  long long v10;\n  while (1) {\n    LODWORD(v4) = isspace(*a2);\n    if (!v4) break;\n    --a1;\n    ++a2;\n    if (a1 <= 0) return 4294967295LL;\n  }\n  if (a1 <= 0) return 0;\n  v5 = 0;\n  v6 = &a2[a1];\n  while (1) {\n    v7 = *a2;\n    v8 = *a2 - 48;\n    if (v8 > 7u) break;\n    ++a2;\n    v5 = (char)v8 | (8 * v5);\n    if (v6 == a2) return v5;\n  }\n  if (!v7) return v5;\n  LODWORD(v10) = isspace(v7);\n  if (v10) return v5;\n  return 4294967295LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int from_oct(int var1, const char *var2) {\n  int var3;\n  while (isspace((unsigned char)*var2)) {\n    var2++;\n    if (--var1 <= 0) return -1;\n  }\n  var3 = 0;\n  while (var1 > 0 && (((*var2) >= '0') && ((*var2) <= '7'))) {\n    var3 = (var3 << 3) | (*var2++ - '0');\n    --var1;\n  }\n  if (var1 > 0 && *var2 && !isspace((unsigned char)*var2)) return -1;\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 104800, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n scalar_t__ isspace (unsigned char) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long read_data_ascii_mmap(char *a1, uint8_t *a2, unsigned long long a3,\n                               unsigned long long a4, uint64_t *a5) {\n  int i;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  uint8_t *v14;\n  int *v16;\n  v11 = 0;\n  v16 = (int *)pthread_getspecific(thread_key);\n  v12 = *v16;\n  v13 = v16[1];\n  v14 = a2;\n  memset(a2, 0, (unsigned int)a3);\n  for (i = 0; a3 > i; ++i) {\n    if (v12) {\n      if (v13 == 10)\n        LOBYTE(v10) = 10;\n      else\n        LOBYTE(v10) = 0;\n      v12 = 0;\n    } else {\n      if (a4 <= v11) break;\n      v10 = *a1++;\n      if (v10 == 10 || v10 == 13) {\n        v13 = v10;\n        LOBYTE(v10) = 13;\n        v12 = 1;\n      }\n      ++v11;\n    }\n    *v14++ = v10;\n  }\n  *v16 = v12;\n  v16[1] = v13;\n  *a5 = v11;\n  return i;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "size_t read_data_ascii_mmap(char *var1, char *var2, size_t var3, size_t var4,\n                            size_t *var5) {\n  char *var6;\n  char *var7;\n  int var8, var9, var10 = 0;\n  type1 *var11;\n  var11 = pthread_getspecific(var12);\n  int var13 = var11->field1;\n  int var14 = var11->field2;\n  var6 = var2;\n  var7 = var1;\n  memset(var2, '\\0', sizeof(char) * var3);\n  for (var8 = 0; var8 < var3; var8++) {\n    if (var13) {\n      if (var14 == '\\n')\n        var9 = '\\n';\n      else\n        var9 = '\\0';\n      var13 = 0;\n    } else {\n      if (var10 >= var4) {\n        break;\n      }\n      var9 = *var7;\n      var7++;\n      if (var9 == '\\n' || var9 == '\\r') {\n        var14 = var9;\n        var9 = '\\r';\n        var13 = 1;\n      }\n      var10++;\n    }\n    *var6 = var9;\n    var6++;\n  }\n  var11->field1 = var13;\n  var11->field2 = var14;\n  *var5 = var10;\n  return var8;\n}", "style": "rule"}, "extra_info": {"index": 46356, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int field1; int field2; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  memset (char*,char,int) ; \n TYPE_1__* pthread_getspecific (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  var12 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long flying_rc_track_flat_to_right_bank(long long a1, long long a2, int a3,\n                                             long long a4, long long a5) {\n  unsigned int v7;\n  unsigned int v9;\n  if (!(unsigned int)track_element_is_inverted(a5)) {\n    if (a3 == 2) {\n      sub_98197C_rotated(\n          2LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17162u, 0LL,\n          0LL, 32LL, 20LL, 3LL, a4, 0LL, 6LL, a4);\n      sub_98197C_rotated(\n          2LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17166u, 0LL,\n          0LL, 32LL, 1LL, 26LL, a4, 0LL, 27LL, a4);\n    } else if (a3 > 2) {\n      if (a3 == 3) {\n        sub_98197C_rotated(\n            3LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17163u, 0LL,\n            0LL, 32LL, 20LL, 3LL, a4, 0LL, 6LL, a4);\n        sub_98197C_rotated(\n            3LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17167u, 0LL,\n            0LL, 32LL, 1LL, 26LL, a4, 0LL, 27LL, a4);\n        if (!track_paint_util_should_paint_supports(\n                (unsigned int)gPaintMapPosition))\n          goto LABEL_8;\n        goto LABEL_12;\n      }\n    } else if (a3) {\n      if (a3 == 1)\n        sub_98197C_rotated(\n            1LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17161u, 0LL,\n            0LL, 32LL, 20LL, 3LL, a4, 0LL, 6LL, a4);\n    } else {\n      sub_98197C_rotated(\n          0LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 17160u, 0LL,\n          0LL, 32LL, 20LL, 3LL, a4, 0LL, 6LL, a4);\n    }\n    if (!track_paint_util_should_paint_supports(\n            (unsigned int)gPaintMapPosition)) {\n    LABEL_8:\n      paint_util_push_tunnel_rotated((unsigned int)a3, a4,\n                                     (unsigned int)TUNNEL_6);\n      v7 = paint_util_rotate_segments(\n          SEGMENT_D0 | SEGMENT_CC | (unsigned int)SEGMENT_C4, (unsigned int)a3);\n      paint_util_set_segment_support_height(v7, 65535LL, 0LL);\n      return paint_util_set_general_support_height(a4 + 32, 32LL);\n    }\n  LABEL_12:\n    metal_a_supports_paint_setup(\n        (unsigned int)METAL_SUPPORTS_TUBES_INVERTED, 4LL, 0LL, a4,\n        *(unsigned int *)(gTrackColours + 4 * SCHEME_SUPPORTS));\n    goto LABEL_8;\n  }\n  if (a3 == 2) {\n    sub_98197C_rotated(2LL,\n                       *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 27275u,\n                       0LL, 0LL, 32LL, 20LL, 3LL, a4 + 24, 0LL, 6LL, a4 + 22);\n  } else if (a3 > 2) {\n    if (a3 == 3)\n      sub_98197C_rotated(\n          3LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 27276u, 0LL,\n          0LL, 32LL, 20LL, 3LL, a4 + 24, 0LL, 6LL, a4 + 22);\n  } else if (a3) {\n    if (a3 == 1)\n      sub_98197C_rotated(\n          1LL, *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 27274u, 0LL,\n          0LL, 32LL, 20LL, 3LL, a4 + 24, 0LL, 6LL, a4 + 22);\n  } else {\n    sub_98197C_rotated(0LL,\n                       *(uint32_t *)(gTrackColours + 4 * SCHEME_TRACK) | 27273u,\n                       0LL, 0LL, 32LL, 20LL, 3LL, a4 + 24, 0LL, 6LL, a4 + 22);\n  }\n  v9 = paint_util_rotate_segments(SEGMENT_D0 | SEGMENT_CC | SEGMENT_C8 |\n                                      SEGMENT_C4 | SEGMENT_B8 |\n                                      (unsigned int)SEGMENT_B4,\n                                  (unsigned int)a3);\n  paint_util_set_segment_support_height(v9, 65535LL, 0LL);\n  if (track_paint_util_should_paint_supports((unsigned int)gPaintMapPosition))\n    metal_a_supports_paint_setup(\n        (unsigned int)METAL_SUPPORTS_TUBES_INVERTED, 4LL, 0LL, a4 + 39,\n        *(unsigned int *)(gTrackColours + 4 * SCHEME_SUPPORTS));\n  paint_util_push_tunnel_rotated((unsigned int)a3, a4, (unsigned int)TUNNEL_6);\n  return paint_util_set_general_support_height(a4 + 32, 32LL);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void flying_rc_track_flat_to_right_bank(type1 var1, type1 var2,\n                                               type1 var3, type2 var4,\n                                               type3* var5) {\n  if (!track_element_is_inverted(var5)) {\n    switch (var3) {\n      case 0:\n        sub_98197C_rotated(var3, var6[var7] | 17160, 0, 0, 32, 20, 3, var4, 0,\n                           6, var4);\n        break;\n      case 1:\n        sub_98197C_rotated(var3, var6[var7] | 17161, 0, 0, 32, 20, 3, var4, 0,\n                           6, var4);\n        break;\n      case 2:\n        sub_98197C_rotated(var3, var6[var7] | 17162, 0, 0, 32, 20, 3, var4, 0,\n                           6, var4);\n        sub_98197C_rotated(var3, var6[var7] | 17166, 0, 0, 32, 1, 26, var4, 0,\n                           27, var4);\n        break;\n      case 3:\n        sub_98197C_rotated(var3, var6[var7] | 17163, 0, 0, 32, 20, 3, var4, 0,\n                           6, var4);\n        sub_98197C_rotated(var3, var6[var7] | 17167, 0, 0, 32, 1, 26, var4, 0,\n                           27, var4);\n        break;\n    }\n    if (track_paint_util_should_paint_supports(var8)) {\n      metal_a_supports_paint_setup(var9, 4, 0, var4, var6[var10]);\n    }\n    paint_util_push_tunnel_rotated(var3, var4, var11);\n    paint_util_set_segment_support_height(\n        paint_util_rotate_segments(var12 | var13 | var14, var3), 0xFFFF, 0);\n    paint_util_set_general_support_height(var4 + 32, 0x20);\n  } else {\n    switch (var3) {\n      case 0:\n        sub_98197C_rotated(var3, var6[var7] | 27273, 0, 0, 32, 20, 3, var4 + 24,\n                           0, 6, var4 + 22);\n        break;\n      case 1:\n        sub_98197C_rotated(var3, var6[var7] | 27274, 0, 0, 32, 20, 3, var4 + 24,\n                           0, 6, var4 + 22);\n        break;\n      case 2:\n        sub_98197C_rotated(var3, var6[var7] | 27275, 0, 0, 32, 20, 3, var4 + 24,\n                           0, 6, var4 + 22);\n        break;\n      case 3:\n        sub_98197C_rotated(var3, var6[var7] | 27276, 0, 0, 32, 20, 3, var4 + 24,\n                           0, 6, var4 + 22);\n        break;\n    }\n    paint_util_set_segment_support_height(\n        paint_util_rotate_segments(\n            var15 | var16 | var12 | var17 | var13 | var14, var3),\n        0xFFFF, 0);\n    if (track_paint_util_should_paint_supports(var8)) {\n      metal_a_supports_paint_setup(var9, 4, 0, var4 + 39, var6[var10]);\n    }\n    paint_util_push_tunnel_rotated(var3, var4, var11);\n    paint_util_set_general_support_height(var4 + 32, 0x20);\n  }\n}", "style": "rule"}, "extra_info": {"index": 58067, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type3 ;\ntypedef  scalar_t__ type2 ;\ntypedef  int type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  metal_a_supports_paint_setup (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,scalar_t__,int) ; \n int /*<<< orphan*/  paint_util_push_tunnel_rotated (int,scalar_t__,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  paint_util_rotate_segments (int,int) ; \n int /*<<< orphan*/  paint_util_set_general_support_height (scalar_t__,int) ; \n int /*<<< orphan*/  paint_util_set_segment_support_height (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  sub_98197C_rotated (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,scalar_t__,int /*<<< orphan*/ ,int,scalar_t__) ; \n int /*<<< orphan*/  track_element_is_inverted (int /*<<< orphan*/ *) ; \n scalar_t__ track_paint_util_should_paint_supports (int /*<<< orphan*/ ) ; \n size_t var10 ; \n int /*<<< orphan*/  var11 ; \n int var12 ; \n int var13 ; \n int var14 ; \n int var15 ; \n int var16 ; \n int var17 ; \n int* var6 ; \n size_t var7 ; \n int /*<<< orphan*/  var8 ; \n int /*<<< orphan*/  var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long call_funcdef(long long *a1, unsigned int *a2, unsigned int *a3,\n                       long long a4, uint32_t *a5) {\n  int v7;\n  long long scope;\n  long long item;\n  long long v11;\n  long long v12;\n  long long v13;\n  int item_count;\n  unsigned int v15;\n  uint64_t *v16;\n  long long variable;\n  long long v18;\n  long long v19;\n  uint32_t *v20;\n  long long v21;\n  uint32_t *v22;\n  long long v23;\n  bool v24;\n  long long v25;\n  long long v27;\n  v7 = 0;\n  scope = create_scope();\n  if (a4) {\n    while ((int)list_get_item_count(*(unsigned int *)(a4 + 8)) > v7) {\n      item = list_get_item(*(unsigned int *)(a4 + 8), (unsigned int)v7);\n      LODWORD(v11) = strcmp((const char *)*(unsigned int *)(item + 4), \"this\");\n      if (v11) list_insert(*(unsigned int *)(scope + 8), item);\n      ++v7;\n    }\n  }\n  stack_push(*((unsigned int *)a1 + 2), scope);\n  v12 = *a1;\n  v13 = a3[1];\n  *a1 = scope;\n  v27 = v12;\n  item_count = list_get_item_count(v13);\n  if (item_count != (unsigned int)list_get_item_count(*a2)) {\n    fprintf((FILE *)(unsigned int)stderr, \"argument count mismatch\\n\");\n    exit(EXIT_FAILURE);\n  }\n  v15 = 0;\n  while ((int)list_get_item_count(a3[1]) > (int)v15) {\n    v16 = (uint64_t *)list_get_item(a3[1], v15);\n    variable = create_variable(a1, *v16);\n    v18 = *a1;\n    v19 = v15++;\n    v20 = (uint32_t *)variable;\n    *a1 = v27;\n    v21 = list_get_item(*a2, v19);\n    v22 = (uint32_t *)int_expression(a1, v21);\n    *a1 = v18;\n    *v20 = *v22;\n  }\n  if (a5) *(uint32_t *)create_variable(a1, \"this\") = *a5;\n  v23 = int_block(a1, *a3);\n  v24 = (*(uint64_t *)scope)-- == 1LL;\n  v25 = v23;\n  if (v24) destroy_scope(scope);\n  stack_pop(*((unsigned int *)a1 + 2));\n  *a1 = v27;\n  return v25;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static type1* call_funcdef(type2* var1, type3* var2, type4* var3, type5* var4,\n                           type1* var5) {\n  type1* var6 = 0;\n  type5* var7 = create_scope(var1);\n  if (0 != var4) {\n    for (int var8 = 0; var8 < list_get_item_count(var4->field1); var8++) {\n      type1* var9 = list_get_item(var4->field1, var8);\n      if (strcmp(var9->field2, \"this\") != 0) {\n        list_insert(var7->field1, var9);\n      }\n    }\n  }\n  stack_push(var1->field3, var7);\n  type5* var10 = var1->field4;\n  var1->field4 = var7;\n  if (list_get_item_count(var3->field5) != list_get_item_count(var2->field6)) {\n    fprintf(var11, \"argument count mismatch\\n\");\n    exit(var12);\n  }\n  for (int var13 = 0; var13 < list_get_item_count(var3->field5); var13++) {\n    type6* var14 = list_get_item(var3->field5, var13);\n    type1* var15 = create_variable(var1, var14->field2);\n    type5* var16;\n    var16 = var1->field4;\n    var1->field4 = var10;\n    type1* var17 = int_expression(var1, list_get_item(var2->field6, var13));\n    var1->field4 = var16;\n    var15->field7 = var17->field7;\n  }\n  if (var5 != 0) {\n    type1* var18 = create_variable(var1, \"this\");\n    var18->field7 = var5->field7;\n  }\n  var6 = int_block(var1, var3->field8);\n  var7->field9 -= 1;\n  if (var7->field9 == 0) {\n    destroy_scope(var7);\n  }\n  stack_pop(var1->field3);\n  var1->field4 = var10;\n  return var6;\n}", "style": "rule"}, "extra_info": {"index": 29888, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_29__   TYPE_6__ ;\ntypedef  struct TYPE_28__   TYPE_5__ ;\ntypedef  struct TYPE_27__   TYPE_4__ ;\ntypedef  struct TYPE_26__   TYPE_3__ ;\ntypedef  struct TYPE_25__   TYPE_2__ ;\ntypedef  struct TYPE_24__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_24__ {char* field2; } ;\ntypedef  TYPE_1__ type6 ;\nstruct TYPE_25__ {scalar_t__ field9; int /*<<< orphan*/  field1; } ;\ntypedef  TYPE_2__ type5 ;\nstruct TYPE_26__ {int /*<<< orphan*/  field8; int /*<<< orphan*/  field5; } ;\ntypedef  TYPE_3__ type4 ;\nstruct TYPE_27__ {int /*<<< orphan*/  field6; } ;\ntypedef  TYPE_4__ type3 ;\nstruct TYPE_28__ {TYPE_2__* field4; int /*<<< orphan*/  field3; } ;\ntypedef  TYPE_5__ type2 ;\nstruct TYPE_29__ {int /*<<< orphan*/  field7; int /*<<< orphan*/  field2; } ;\ntypedef  TYPE_6__ type1 ;\n\n/* Variables and functions */\n TYPE_2__* create_scope (TYPE_5__*) ; \n TYPE_6__* create_variable (TYPE_5__*,char*) ; \n int /*<<< orphan*/  destroy_scope (TYPE_2__*) ; \n int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; \n TYPE_6__* int_block (TYPE_5__*,int /*<<< orphan*/ ) ; \n TYPE_6__* int_expression (TYPE_5__*,void*) ; \n void* list_get_item (int /*<<< orphan*/ ,int) ; \n int list_get_item_count (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  list_insert (int /*<<< orphan*/ ,TYPE_6__*) ; \n int /*<<< orphan*/  stack_pop (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stack_push (int /*<<< orphan*/ ,TYPE_2__*) ; \n scalar_t__ strcmp (int /*<<< orphan*/ ,char*) ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  FILE *v4;\n  char v5;\n  char *v6;\n  char *v7;\n  char *v8;\n  char v9;\n  uint8_t v10[1024];\n  char v11[1024];\n  char s[1032];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  program_name = (long long)*argv;\n  while (1) {\n    v3 = getopt_long(argc, (char *const *)argv, \"gr:s:v\", &long_options_0, 0LL);\n    if (EOF == v3) break;\n    if (v3 == 115) {\n      sscanf((const char *)(unsigned int)optarg, \"%u\", &point_size);\n    } else if (v3 > 115) {\n      if (v3 == 118) {\n        printf(\"xtotroff (groff) version %s\\n\", (const char *)Version_string);\n        exit(0);\n      }\n      if (v3 == 130) {\n        usage((unsigned int)stdout);\n        exit(0);\n      }\n    } else {\n      if (v3 == 63) {\n        usage((unsigned int)stderr);\n        exit(1);\n      }\n      if (v3 == 114)\n        sscanf((const char *)(unsigned int)optarg, \"%u\", &resolution);\n    }\n  }\n  if (argc - optind != 1) {\n    usage((unsigned int)stderr);\n    exit(1);\n  }\n  dpy = (unsigned int)XOpenDisplay(0LL);\n  if (!dpy) {\n    fprintf((FILE *)(unsigned int)stderr, \"Can't connect to the X server.\\n\");\n    fprintf((FILE *)(unsigned int)stderr,\n            \"Make sure the DISPLAY environment variable is set correctly.\\n\");\n    exit(1);\n  }\n  v4 = fopen(argv[optind], \"r\");\n  if (!v4) {\n    perror(argv[optind]);\n    exit(1);\n  }\n  while (1) {\n    if (!fgets(s, 1024, v4)) exit(0);\n    v5 = s[0];\n    v6 = v10;\n    v7 = s;\n    if (!s[0]) break;\n    while (1) {\n      *v6 = v5;\n      if (v5 == 32 || v5 == 9) break;\n      v5 = *++v7;\n      ++v6;\n      if (!v5) {\n        *v6 = 0;\n        goto LABEL_24;\n      }\n    }\n    *v6 = 0;\n    while (v5 == 32 || v5 == 9) {\n      v5 = *++v7;\n      if (!v5) goto LABEL_24;\n    }\n    v9 = *v7;\n    if (*v7) {\n      v8 = v11;\n      while (1) {\n        *v8 = v9;\n        if (v9 == 10) break;\n        v9 = *++v7;\n        ++v8;\n        if (!v9) goto LABEL_25;\n      }\n      *v8 = 0;\n      if (!(unsigned int)MapFont(v11, v10))\n      LABEL_26:\n        exit(1);\n    } else {\n    LABEL_24:\n      v8 = v11;\n    LABEL_25:\n      *v8 = 0;\n      if (!(unsigned int)MapFont(v11, v10)) goto LABEL_26;\n    }\n  }\n  v10[0] = 0;\n  v8 = v11;\n  goto LABEL_25;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char **var2) {\n  char var3[1024];\n  char var4[1024];\n  char var5[1024];\n  char *var6, *var7, var8;\n  type1 *var9;\n  int var10;\n  static const struct type2 var11[] = {{\"help\", var12, 0, var13 + 1},\n                                       {\"version\", var12, 0, 'v'},\n                                       {NULL, 0, 0, 0}};\n  var14 = var2[0];\n  while ((var10 = getopt_long(var1, var2, \"gr:s:v\", var11, NULL)) != var15) {\n    switch (var10) {\n      case 'g':\n        break;\n      case 'r':\n        sscanf(var16, \"%u\", &var17);\n        break;\n      case 's':\n        sscanf(var16, \"%u\", &var18);\n        break;\n      case 'v':\n        printf(\"xtotroff (groff) version %s\\n\", var19);\n        exit(0);\n        break;\n      case var13 + 1:\n        usage(var20);\n        exit(0);\n        break;\n      case '?':\n        usage(var21);\n        exit(1);\n        break;\n    }\n  }\n  if (var1 - var22 != 1) {\n    usage(var21);\n    exit(1);\n  }\n  var23 = XOpenDisplay(0);\n  if (!var23) {\n    fprintf(var21, \"Can't connect to the X server.\\n\");\n    fprintf(var21,\n            \"Make sure the DISPLAY environment variable is set correctly.\\n\");\n    exit(1);\n  }\n  var9 = fopen(var2[var22], \"r\");\n  if (var9 == NULL) {\n    perror(var2[var22]);\n    exit(1);\n  }\n  while (fgets(var5, sizeof(var5), var9)) {\n    for (var6 = var5, var7 = var3; *var6; var6++, var7++) {\n      var8 = (*var7 = *var6);\n      if (var8 == ' ' || var8 == '\\t') break;\n    }\n    *var7 = '\\0';\n    while (*var6 && (*var6 == ' ' || *var6 == '\\t')) ++var6;\n    for (var7 = var4; *var6; var6++, var7++)\n      if ((*var7 = *var6) == '\\n') break;\n    *var7 = '\\0';\n    if (!MapFont(var4, var3)) exit(1);\n  }\n  exit(0);\n}", "style": "rule"}, "extra_info": {"index": 16085, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var5 ;\ntypedef  int /*<<< orphan*/  type1 ;\nstruct type2 {char* member_0; char member_3; int /*<<< orphan*/  member_2; int /*<<< orphan*/  const member_1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  MapFont (char*,char*) ; \n int /*<<< orphan*/  XOpenDisplay (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  exit (int) ; \n scalar_t__ fgets (char*,int,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * fopen (char*,char*) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; \n int getopt_long (int,char**,char*,struct type2 const*,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  perror (char*) ; \n int /*<<< orphan*/  printf (char*,char*) ; \n int /*<<< orphan*/  sscanf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  usage (int /*<<< orphan*/ ) ; \n#define  var12 129 \n#define  var13 128 \n char* var14 ; \n int var15 ; \n int /*<<< orphan*/  var16 ; \n int /*<<< orphan*/  var17 ; \n int /*<<< orphan*/  var18 ; \n char* var19 ; \n int /*<<< orphan*/  var20 ; \n int /*<<< orphan*/  var21 ; \n int var22 ; \n int /*<<< orphan*/  var23 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  const char *v4;\n  const char *v5;\n  const char *v6;\n  const char *v7;\n  const char *v8;\n  unsigned int v10;\n  uint8_t v11[4];\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  int v15;\n  int v16;\n  unsigned int size;\n  unsigned int size_4;\n  void *s;\n  void *ptr;\n  long long info;\n  char v22[16];\n  char v23[88];\n  unsigned long long v24;\n  v24 = __readfsqword(40u);\n  v13 = 0;\n  v14 = -1;\n  v15 = 0;\n  v16 = 0;\n  size = 0;\n  s = 0LL;\n  ptr = 0LL;\n  while (2) {\n    size_4 = getopt(argc, (char *const *)argv, \"e:b:l:sSh\");\n    if (size_4 != -1) {\n      switch (size_4) {\n        case 'S':\n          v15 = 1;\n          continue;\n        case 'b':\n          v13 = atoi((const char *)(unsigned int)optarg);\n          continue;\n        case 'e':\n          v14 = atoi((const char *)(unsigned int)optarg);\n          continue;\n        case 'h':\n          goto LABEL_9;\n        case 'l':\n          size = atoi((const char *)(unsigned int)optarg);\n          continue;\n        case 's':\n          v16 = 1;\n          continue;\n        default:\n          fprintf((FILE *)(unsigned int)stderr, \"Unknown option -%c\\n\", size_4);\n        LABEL_9:\n          usage((unsigned int)argc, argv);\n          exit(-1);\n      }\n    }\n    break;\n  }\n  if (!v15 && !(unsigned int)getenv(\"OMX_DISABLE_SELF\"))\n    putenv(\"OMX_DISABLE_SELF=1\");\n  if (!v16 && !(unsigned int)getenv(\"OMX_DISABLE_SHARED\"))\n    putenv(\"OMX_DISABLE_SHARED=1\");\n  if (size) {\n    s = malloc(size);\n    ptr = malloc(size);\n    if (!s || !ptr) return -1;\n    memset(s, 97, size);\n    memset(ptr, 98, size);\n  }\n  info = omx_init();\n  if (info == OMX_SUCCESS) {\n    info = omx_board_number_to_nic_id(v13, v11);\n    if (info == OMX_SUCCESS) {\n      info = omx_open_endpoint(v13, v14, 305419896LL, 0LL, 0LL, &v10);\n      if (info == OMX_SUCCESS) {\n        info = omx_get_info(v10, (unsigned int)OMX_INFO_BOARD_HOSTNAME, 0LL,\n                            0LL, v23, 80LL);\n        if (info == OMX_SUCCESS) {\n          info = omx_get_info(v10, (unsigned int)OMX_INFO_BOARD_IFACENAME, 0LL,\n                              0LL, v22, 16LL);\n          if (info == OMX_SUCCESS) {\n            printf(\"Using board #%d name '%s' hostname '%s'\\n\", v13, v22, v23);\n            info = omx_get_endpoint_addr(v10, &v12);\n            if (info == OMX_SUCCESS) {\n              info = omx_isend(v10, s, size, v12, 1LL, 0LL, 0LL);\n              assert(info == OMX_SUCCESS);\n            }\n            v8 = (const char *)omx_strerror(info);\n            fprintf((FILE *)(unsigned int)stderr,\n                    \"Failed to get local endpoint address (%s)\\n\", v8);\n          } else {\n            v7 = (const char *)omx_strerror(info);\n            fprintf((FILE *)(unsigned int)stderr,\n                    \"Failed to find board iface name (%s)\\n\", v7);\n          }\n        } else {\n          v6 = (const char *)omx_strerror(info);\n          fprintf((FILE *)(unsigned int)stderr,\n                  \"Failed to find board hostname (%s)\\n\", v6);\n        }\n        omx_close_endpoint(v10);\n      } else {\n        v5 = (const char *)omx_strerror(info);\n        fprintf((FILE *)(unsigned int)stderr, \"Failed to open endpoint (%s)\\n\",\n                v5);\n      }\n    } else {\n      v4 = (const char *)omx_strerror(info);\n      fprintf((FILE *)(unsigned int)stderr,\n              \"Failed to find board %d nic id (%s)\\n\", v13, v4);\n    }\n  } else {\n    v3 = (const char *)omx_strerror(info);\n    fprintf((FILE *)(unsigned int)stderr, \"Failed to initialize (%s)\\n\", v3);\n  }\n  return -1;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char *var2[]) {\n  type1 var3;\n  uint64_t var4;\n  int var5 = 0;\n  int var6 = 0xffffffffU;\n  char var7[80];\n  char var8[16];\n  type2 var9;\n  int var10 = 0;\n  int var11 = 0;\n  int var12;\n  type3 var13;\n  type4 var14;\n  uint32_t var15;\n  int var16 = 0;\n  char *var17 = NULL, *var18 = NULL;\n  while ((var12 = getopt(var1, var2, \"e:b:l:sSh\")) != -1) switch (var12) {\n      case 'b':\n        var5 = atoi(var19);\n        break;\n      case 'e':\n        var6 = atoi(var19);\n        break;\n      case 'l':\n        var16 = atoi(var19);\n        break;\n      case 's':\n        var11 = 1;\n        break;\n      case 'S':\n        var10 = 1;\n        break;\n      default:\n        fprintf(var20, \"Unknown option -%c\\n\", var12);\n      case 'h':\n        usage(var1, var2);\n        exit(-1);\n        break;\n    }\n  if (!var10 && !getenv(\"OMX_DISABLE_SELF\")) putenv(\"OMX_DISABLE_SELF=1\");\n  if (!var11 && !getenv(\"OMX_DISABLE_SHARED\")) putenv(\"OMX_DISABLE_SHARED=1\");\n  if (var16) {\n    var17 = malloc(var16);\n    var18 = malloc(var16);\n    if (!var17 || !var18) goto out;\n    memset(var17, 'a', var16);\n    memset(var18, 'b', var16);\n  }\n  var13 = omx_init();\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to initialize (%s)\\n\", omx_strerror(var13));\n    goto out;\n  }\n  var13 = omx_board_number_to_nic_id(var5, &var4);\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to find board %d nic id (%s)\\n\", var5,\n            omx_strerror(var13));\n    goto out;\n  }\n  var13 = omx_open_endpoint(var5, var6, 0x12345678, NULL, 0, &var3);\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to open endpoint (%s)\\n\", omx_strerror(var13));\n    goto out;\n  }\n  var13 = omx_get_info(var3, var22, NULL, 0, var7, sizeof(var7));\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to find board hostname (%s)\\n\", omx_strerror(var13));\n    goto out_with_ep;\n  }\n  var13 = omx_get_info(var3, var23, NULL, 0, var8, sizeof(var8));\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to find board iface name (%s)\\n\",\n            omx_strerror(var13));\n    goto out_with_ep;\n  }\n  printf(\"Using board #%d name '%s' hostname '%s'\\n\", var5, var8, var7);\n  var13 = omx_get_endpoint_addr(var3, &var9);\n  if (var13 != var21) {\n    fprintf(var20, \"Failed to get local endpoint address (%s)\\n\",\n            omx_strerror(var13));\n    goto out_with_ep;\n  }\n  var13 = omx_isend(var3, var17, var16, var9, 0x1, NULL, NULL);\n  assert(var13 == var21);\n  printf(\"posted send\\n\");\n  var13 = func1(var3, 0x1, -1ULL, &var14, &var15, ((uint32_t)-1));\n  assert(var13 == var21);\n  assert(var15);\n  assert(var14.field1 == 0x01);\n  printf(\"probe found exact match\\n\");\n  var13 = func2(var3, 0x2, -1ULL, &var14, &var15);\n  assert(var13 == var21);\n  assert(!var15);\n  printf(\"iprobe did not found match with wrong bits\\n\");\n  var13 = func2(var3, 0, -2ULL, &var14, &var15);\n  assert(var13 == var21);\n  assert(var15);\n  assert(var14.field1 == 0x01);\n  printf(\"iprobe found match with mask\\n\");\n  var13 = func3(var3, var18, var16, 0, -2ULL, NULL, NULL);\n  assert(var13 == var21);\n  printf(\"posted recv with mask\\n\");\n  var13 = func2(var3, 0, -2ULL, &var14, &var15);\n  assert(var13 == var21);\n  assert(!var15);\n  printf(\"iprobe cannot found match with mask anymore\\n\");\n  free(var17);\n  free(var18);\n  omx_close_endpoint(var3);\n  return 0;\nout_with_ep:\n  omx_close_endpoint(var3);\nout:\n  return -1;\n}", "style": "rule"}, "extra_info": {"index": 4131, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var8 ;\ntypedef  int /*<<< orphan*/  var7 ;\ntypedef  int /*<<< orphan*/  uint64_t ;\ntypedef  int uint32_t ;\nstruct TYPE_4__ {int field1; } ;\ntypedef  TYPE_1__ type4 ;\ntypedef  scalar_t__ type3 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  assert (int) ; \n int atoi (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  exit (int) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; \n int /*<<< orphan*/  free (char*) ; \n scalar_t__ func1 (int /*<<< orphan*/ ,int,unsigned long long,TYPE_1__*,int*,int) ; \n scalar_t__ func2 (int /*<<< orphan*/ ,int,unsigned long long,TYPE_1__*,int*) ; \n scalar_t__ func3 (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ,unsigned long long,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  getenv (char*) ; \n int getopt (int,char**,char*) ; \n char* malloc (int) ; \n int /*<<< orphan*/  memset (char*,char,int) ; \n scalar_t__ omx_board_number_to_nic_id (int,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  omx_close_endpoint (int /*<<< orphan*/ ) ; \n scalar_t__ omx_get_endpoint_addr (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n scalar_t__ omx_get_info (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*,int) ; \n scalar_t__ omx_init () ; \n scalar_t__ omx_isend (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n scalar_t__ omx_open_endpoint (int,int,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n char* omx_strerror (scalar_t__) ; \n int /*<<< orphan*/  printf (char*,...) ; \n int /*<<< orphan*/  putenv (char*) ; \n int /*<<< orphan*/  usage (int,char**) ; \n int /*<<< orphan*/  var19 ; \n int /*<<< orphan*/  var20 ; \n scalar_t__ var21 ; \n int /*<<< orphan*/  var22 ; \n int /*<<< orphan*/  var23 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  int i;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  FILE *stream;\n  char *s1;\n  char *filename;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  uint8_t v16[520];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  filename = 0LL;\n  v12 = 0LL;\n  v13 = 0LL;\n  v14 = 0LL;\n  v15 = 0LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  if (!(unsigned int)parse_args(&filename, (unsigned int)argc, argv))\n    return EXIT_FAILURE;\n  if (argc == optind) {\n    usage();\n    return EXIT_FAILURE;\n  } else {\n    if (!filename) {\n      make_file_name(v16, 512LL, argv[optind], \".nes\");\n      filename = v16;\n    }\n    for (i = optind; i < argc; ++i) {\n      s1 = (char *)file_extension(argv[i]);\n      if (s1 && !strcasecmp(s1, \".chr\")) {\n        if (!(unsigned int)file_append(argv[i], &v8, &v6)) goto LABEL_11;\n      } else {\n        if (!s1 || strcasecmp(s1, \".prg\")) {\n          fprintf((FILE *)(unsigned int)stderr, \"%s: unknown file extension.\\n\",\n                  argv[i]);\n          usage();\n          return EXIT_FAILURE;\n        }\n        if (!(unsigned int)file_append(argv[i], &v7, &v5)) {\n        LABEL_11:\n          usage();\n          return EXIT_FAILURE;\n        }\n      }\n    }\n    stream = fopen(filename, \"wb\");\n    if (stream) {\n      if ((unsigned int)write_ines(stream, filename, v7, v5, v8, v6,\n                                   (unsigned int)v13, HIDWORD(v12),\n                                   (unsigned int)v12)) {\n        fclose(stream);\n        return 0;\n      } else {\n        return EXIT_FAILURE;\n      }\n    } else {\n      perror(argv[i]);\n      return EXIT_FAILURE;\n    }\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(int var1, char **var2) {\n  int var3;\n  type1 *var4;\n  char var5[512];\n  struct type2 var6 = {0, NULL};\n  unsigned char *var7 = NULL, *var8 = NULL;\n  size_t var9 = 0, var10 = 0;\n  if (!parse_args(&var6, var1, var2)) {\n    return var11;\n  }\n  if (var1 == var12) {\n    usage();\n    return var11;\n  }\n  if (!var6.field1) {\n    make_file_name(var5, sizeof var5, var2[var12], \".nes\");\n    var6.field1 = var5;\n  }\n  for (var3 = var12; var3 < var1; var3++) {\n    const char *var13;\n    var13 = file_extension(var2[var3]);\n    if (var13 && !strcasecmp(var13, \".chr\")) {\n      if (!file_append(var2[var3], &var10, &var8)) {\n        usage();\n        return var11;\n      }\n    } else if (var13 && !strcasecmp(var13, \".prg\")) {\n      if (!file_append(var2[var3], &var9, &var7)) {\n        usage();\n        return var11;\n      }\n    } else {\n      fprintf(var14, \"%s: unknown file extension.\\n\", var2[var3]);\n      usage();\n      return var11;\n    }\n  }\n  var4 = fopen(var6.field1, \"wb\");\n  if (!var4) {\n    perror(var2[var3]);\n    return var11;\n  }\n  if (!write_ines(var4, var6.field1, var9, var7, var10, var8, var6.field2,\n                  var6.field3, var6.field4)) {\n    return var11;\n  }\n  fclose(var4);\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 14516, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type1 ;\nstruct type2 {char* field1; int /*<<< orphan*/  field4; int /*<<< orphan*/  field3; int /*<<< orphan*/  field2; int /*<<< orphan*/ * member_1; int /*<<< orphan*/  member_0; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  file_append (char*,size_t*,unsigned char**) ; \n char* file_extension (char*) ; \n int /*<<< orphan*/ * fopen (char*,char*) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ; \n int /*<<< orphan*/  make_file_name (char*,int,char*,char*) ; \n int /*<<< orphan*/  parse_args (struct type2*,int,char**) ; \n int /*<<< orphan*/  perror (char*) ; \n int /*<<< orphan*/  strcasecmp (char const*,char*) ; \n int /*<<< orphan*/  usage () ; \n int var11 ; \n int var12 ; \n int /*<<< orphan*/  var14 ; \n int /*<<< orphan*/  write_ines (int /*<<< orphan*/ *,char*,size_t,unsigned char*,size_t,unsigned char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long serial_out_sync(long long a1, unsigned int a2, unsigned int a3) {\n  if ((unsigned int)(*(uint32_t *)a1 - 128) > 2)\n    return (*(long long (**)(long long, uint64_t, uint64_t))(a1 + 8))(a1, a2,\n                                                                      a3);\n  (*(void (**)(long long, uint64_t, uint64_t))(a1 + 8))(a1, a2, a3);\n  return (*(long long (**)(long long, uint64_t))(a1 + 16))(\n      a1, (unsigned int)UART_LCR);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void serial_out_sync(struct type1 *var1, int var2, int var3) {\n  struct type2 *var4 = &var1->field1;\n  switch (var4->field2) {\n    case var5:\n    case var6:\n#ifdef var7\n    case var8:\n#endif\n    case var9:\n      var4->field3(var4, var2, var3);\n      var4->field4(var4, var10);\n      break;\n    default:\n      var4->field3(var4, var2, var3);\n  }\n}", "style": "rule"}, "extra_info": {"index": 58003, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type2 {int field2; int /*<<< orphan*/  (* field3 ) (struct type2*,int,int) ;int /*<<< orphan*/  (* field4 ) (struct type2*,int /*<<< orphan*/ ) ;} ;\nstruct type1 {struct type2 field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  stub1 (struct type2*,int,int) ; \n int /*<<< orphan*/  stub2 (struct type2*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stub3 (struct type2*,int,int) ; \n int /*<<< orphan*/  var10 ; \n#define  var5 131 \n#define  var6 130 \n#define  var8 129 \n#define  var9 128 \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long extcss3_consume_bad_url_remnants(char **a1, long long a2) {\n  char v2;\n  while (1) {\n    if ((unsigned int)extcss3_next_char(a1, a2) != 1) return 0LL;\n    v2 = **a1;\n    if (v2 == 41 || !v2) break;\n    if ((unsigned int)extcss3_check_start_valid_escape() == 1 &&\n        (unsigned int)extcss3_consume_escaped(a1, a2) != 1)\n      return 0LL;\n  }\n  return extcss3_next_char(a1, a2);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static inline bool func1(type1 *var1, unsigned int *var2) {\n  while (true) {\n    do {\n      bool var3 = func2(var1, var2);\n      if ((true) != var3) {\n        return (false);\n      }\n    } while (0);\n    if ((*var1->field1.field2 == ')') || (*var1->field1.field2 == '\\0')) {\n      return func2(var1, var2);\n    } else if ((true) == func3(var1->field1.field2)) {\n      if ((true) != func4(var1, var2)) {\n        return (false);\n      }\n    }\n  }\n  return (true);\n}", "style": "rule"}, "extra_info": {"index": 28864, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {char* field2; } ;\nstruct TYPE_7__ {TYPE_1__ field1; } ;\ntypedef  TYPE_2__ type1 ;\n\n/* Variables and functions */\n int func2 (TYPE_2__*,unsigned int*) ; \n int func3 (char*) ; \n int func4 (TYPE_2__*,unsigned int*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long halbtc8723b2ant_CoexTable(unsigned int a1, int a2, long long a3,\n                                    long long a4, long long a5, long long a6) {\n  long long result;\n  BTC_PRINT((unsigned int)BTC_MSG_ALGORITHM, (unsigned int)ALGO_TRACE_SW, a6);\n  *(uint64_t *)pCoexDm = a3;\n  *(uint64_t *)(pCoexDm + 8) = a4;\n  *(uint64_t *)(pCoexDm + 16) = a5;\n  *(uint64_t *)(pCoexDm + 24) = a6;\n  if (a2 ||\n      (BTC_PRINT((unsigned int)BTC_MSG_ALGORITHM,\n                 (unsigned int)ALGO_TRACE_SW_DETAIL,\n                 *(uint64_t *)(pCoexDm + 56)),\n       BTC_PRINT((unsigned int)BTC_MSG_ALGORITHM,\n                 (unsigned int)ALGO_TRACE_SW_DETAIL,\n                 *(uint64_t *)(pCoexDm + 24)),\n       *(uint64_t *)(pCoexDm + 32) != *(uint64_t *)pCoexDm) ||\n      *(uint64_t *)(pCoexDm + 40) != *(uint64_t *)(pCoexDm + 8) ||\n      *(uint64_t *)(pCoexDm + 48) != *(uint64_t *)(pCoexDm + 16) ||\n      (result = *(uint64_t *)(pCoexDm + 24),\n       *(uint64_t *)(pCoexDm + 56) != result)) {\n    halbtc8723b2ant_SetCoexTable(a1, a3, a4, a5, a6);\n    *(uint64_t *)(pCoexDm + 32) = *(uint64_t *)pCoexDm;\n    *(uint64_t *)(pCoexDm + 40) = *(uint64_t *)(pCoexDm + 8);\n    *(uint64_t *)(pCoexDm + 48) = *(uint64_t *)(pCoexDm + 16);\n    result = pCoexDm;\n    *(uint64_t *)(pCoexDm + 56) = *(uint64_t *)(pCoexDm + 24);\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void halbtc8723b2ant_CoexTable(type1 var1, bool var2, type2 var3,\n                                      type2 var4, type2 var5, type3 var6) {\n  BTC_PRINT(\n      var7, var8,\n      (\"[BTCoex], %s write Coex Table 0x6c0 = 0x%x, 0x6c4 = 0x%x, 0x6c8 = \"\n       \"0x%x, 0x6cc = 0x%x\\n\",\n       (var2 ? \"force to\" : \"\"), var3, var4, var5, var6));\n  var9->field1 = var3;\n  var9->field2 = var4;\n  var9->field3 = var5;\n  var9->field4 = var6;\n  if (!var2) {\n    BTC_PRINT(var7, var10,\n              (\"[BTCoex], preVal0x6c0 = 0x%x, preVal0x6c4 = 0x%x, preVal0x6c8 \"\n               \"= 0x%x, preVal0x6cc = 0x%x !!\\n\",\n               var9->field5, var9->field6, var9->field7, var9->field8));\n    BTC_PRINT(var7, var10,\n              (\"[BTCoex], curVal0x6c0 = 0x%x, curVal0x6c4 = 0x%x, curVal0x6c8 \"\n               \"= 0x%x, curVal0x6cc = 0x%x !!\\n\",\n               var9->field1, var9->field2, var9->field3, var9->field4));\n    if ((var9->field5 == var9->field1) && (var9->field6 == var9->field2) &&\n        (var9->field7 == var9->field3) && (var9->field8 == var9->field4))\n      return;\n  }\n  halbtc8723b2ant_SetCoexTable(var1, var3, var4, var5, var6);\n  var9->field5 = var9->field1;\n  var9->field6 = var9->field2;\n  var9->field7 = var9->field3;\n  var9->field8 = var9->field4;\n}", "style": "rule"}, "extra_info": {"index": 44199, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ type3 ;\ntypedef  void* type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\nstruct TYPE_2__ {scalar_t__ field1; scalar_t__ field2; scalar_t__ field3; scalar_t__ field4; scalar_t__ field5; scalar_t__ field6; scalar_t__ field7; scalar_t__ field8; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  BTC_PRINT (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ; \n int /*<<< orphan*/  halbtc8723b2ant_SetCoexTable (int /*<<< orphan*/ ,void*,void*,void*,scalar_t__) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  var8 ; \n TYPE_1__* var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid laguer(long long a1, int a2, long long *a3, int *a4) {\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  float v10;\n  long long v11;\n  long long v12;\n  float v13;\n  long long *v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  long long v22;\n  long long v23;\n  long long v24;\n  long long v25;\n  float v26;\n  float v27;\n  long long v28;\n  long long v29;\n  long long v30;\n  long long v31;\n  long long v32;\n  long long v33;\n  long long v34;\n  long long v35;\n  long long v36;\n  long long v37;\n  long long v38;\n  long long v39;\n  long long v40;\n  long long v41;\n  long long v42;\n  long long v43;\n  long long v44;\n  long long v45;\n  long long v46;\n  long long v47;\n  long long v48;\n  long long v49;\n  long long v50;\n  long long v51;\n  long long v52;\n  long long v53;\n  long long v54;\n  long long v55;\n  float v56;\n  double v57;\n  double v58;\n  double v59;\n  long long v60;\n  long long v61;\n  long long v62;\n  long long v63;\n  long long v64;\n  long long v65;\n  long long v66;\n  double v67;\n  long long v68;\n  long long v69;\n  long long v70;\n  long long v71;\n  long long v72;\n  long long v73;\n  long long v74;\n  long long v75;\n  float v76;\n  double v77;\n  long long xa;\n  long long x;\n  float v80;\n  long long v81;\n  float v82;\n  float v83;\n  int v84;\n  long long v85;\n  long long *v86;\n  int v88;\n  v88 = a2 - 1;\n  v86 = (long long *)(a1 + 16LL * a2);\n  v84 = 1;\n  while (1) {\n    *a4 = v84;\n    v5 = *v86;\n    v6 = v86[1];\n    v80 = Cabs(*v86, v6);\n    v7 = Complex(0.0, 0.0);\n    v9 = v8;\n    v73 = v8;\n    v10 = Cabs(*a3, a3[1]);\n    v11 = v73;\n    v12 = v7;\n    v13 = v80;\n    v83 = v10;\n    if (v88 >= 0) {\n      v14 = (long long *)(a1 + 16LL * (a2 - 1));\n      do {\n        v14 -= 2;\n        v15 = Cmul(*a3, a3[1], v12, v11);\n        v17 = Cadd(v15, v16, v7, v9);\n        v74 = v18;\n        xa = v17;\n        v19 = Cmul(*a3, a3[1], v7, v9);\n        v21 = Cadd(v19, v20, v5, v6);\n        v9 = v22;\n        v7 = v21;\n        v23 = Cmul(*a3, a3[1], v5, v6);\n        v5 = Cadd(v23, v24, v14[2], v14[3]);\n        v6 = v25;\n        v26 = Cabs(v5, v25);\n        v11 = v74;\n        v12 = xa;\n        v13 = (float)(v13 * v83) + v26;\n      } while (v14 != &v86[-2 * (unsigned int)(a2 - 1) - 4]);\n    }\n    v81 = v11;\n    x = v12;\n    v27 = v13 * 0.0000001;\n    if (v27 >= Cabs(v5, v6)) break;\n    v85 = Cdiv(v7, v9, v5, v6);\n    v75 = v28;\n    v29 = Cmul(v85, v75, v85, v75);\n    v31 = v30;\n    v32 = v29;\n    v33 = Cdiv(x, v81, v5, v6);\n    v35 = RCmul(v33, v34, 2.0);\n    v37 = Csub(v32, v31, v35, v36);\n    v82 = (float)a2;\n    v39 = RCmul(v37, v38, (float)a2);\n    v41 = Csub(v39, v40, v32, v31);\n    v43 = RCmul(v41, v42, (float)v88);\n    v45 = Csqrt(v43, v44);\n    v47 = v46;\n    v48 = v45;\n    v49 = Cadd(v85, v75, v45, v46);\n    v51 = v50;\n    v52 = v49;\n    v53 = Csub(v85, v75, v48, v47);\n    v55 = v54;\n    v76 = Cabs(v52, v51);\n    v56 = Cabs(v53, v55);\n    *(uint64_t *)&v57 = COERCE_UNSIGNED_INT((float)a2);\n    if (v56 > v76) {\n      v52 = v53;\n      v51 = v55;\n    }\n    *(double *)&maxarg1 = v76;\n    *(double *)&maxarg2 = v56;\n    if (v76 <= v56) {\n      if (v56 > 0.0) {\n      LABEL_10:\n        v58 = 0.0;\n        *(uint64_t *)&v59 = LODWORD(v82);\n        v60 = Complex(COERCE_DOUBLE((unsigned long long)LODWORD(v82)), 0.0);\n        v62 = Cdiv(v60, v61, v52, v51);\n        v64 = v63;\n        goto LABEL_11;\n      }\n    } else if (v76 > 0.0) {\n      goto LABEL_10;\n    }\n    *(uint64_t *)&v57 = COERCE_UNSIGNED_INT((float)v84);\n    v77 = sin(v57);\n    v67 = cos(v57);\n    v58 = v77;\n    v68 = Complex(v67, v77);\n    *(uint64_t *)&v59 = (unsigned int)LC4;\n    *(float *)&v59 = v83 + 1.0;\n    v62 = RCmul(v68, v69, v83 + 1.0);\n    v64 = v70;\n  LABEL_11:\n    v65 = Csub(*a3, a3[1], v62, v64);\n    if (*a3 == v65 && a3[1] == v66) return;\n    if (__ROR4__(-858993459 * v84, 1) <= 429496729u) {\n      *(uint64_t *)&v59 = frac_0[(unsigned int)v84 / 10uLL];\n      v71 = RCmul(v62, v64, *(float *)&v59);\n      v65 = Csub(*a3, a3[1], v71, v72);\n    }\n    ++v84;\n    *a3 = v65;\n    a3[1] = v66;\n    if (v84 == 81) {\n      nrerror(\"too many iterations in laguer\", v59, v58, v57);\n      return;\n    }\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void laguer(type1 var1[], int var2, type1 *var3, int *var4) {\n  int var5, var6;\n  float var7, var8, var9, var10;\n  type1 var11, var12, var13, var14, var15, var16, var17, var18, var19, var20,\n      var21;\n  static float var22[8 + 1] = {0.0,  0.5,  0.25, 0.75, 0.13,\n                               0.38, 0.62, 0.88, 1.0};\n  for (var5 = 1; var5 <= (10 * 8); var5++) {\n    *var4 = var5;\n    var13 = var1[var2];\n    var10 = Cabs(var13);\n    var14 = var15 = Complex(0.0, 0.0);\n    var7 = Cabs(*var3);\n    for (var6 = var2 - 1; var6 >= 0; var6--) {\n      var15 = Cadd(Cmul(*var3, var15), var14);\n      var14 = Cadd(Cmul(*var3, var14), var13);\n      var13 = Cadd(Cmul(*var3, var13), var1[var6]);\n      var10 = Cabs(var13) + var7 * var10;\n    }\n    var10 *= 1.0e-7;\n    if (Cabs(var13) <= var10) return;\n    var16 = Cdiv(var14, var13);\n    var21 = Cmul(var16, var16);\n    var17 = Csub(var21, RCmul(2.0, Cdiv(var15, var13)));\n    var18 =\n        Csqrt(RCmul((float)(var2 - 1), Csub(RCmul((float)var2, var17), var21)));\n    var19 = Cadd(var16, var18);\n    var20 = Csub(var16, var18);\n    var8 = Cabs(var19);\n    var9 = Cabs(var20);\n    if (var8 < var9) var19 = var20;\n    var11 =\n        (((var23 = (var8), var24 = (var9),\n           (var23) > (var24) ? (var23) : (var24)) > 0.0\n              ? Cdiv(Complex((float)var2, 0.0), var19)\n              : RCmul(1 + var7, Complex(cos((float)var5), sin((float)var5)))));\n    var12 = Csub(*var3, var11);\n    if (var3->field1 == var12.field1 && var3->field2 == var12.field2) return;\n    if (var5 % 10)\n      *var3 = var12;\n    else\n      *var3 = Csub(*var3, RCmul(var22[var5 / 10], var11));\n  }\n  nrerror(\"too many iterations in laguer\");\n  return;\n}", "style": "rule"}, "extra_info": {"index": 27526, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_22__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_22__ {scalar_t__ field1; scalar_t__ field2; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n float Cabs (TYPE_1__) ; \n TYPE_1__ Cadd (TYPE_1__,TYPE_1__) ; \n TYPE_1__ Cdiv (TYPE_1__,TYPE_1__) ; \n TYPE_1__ Cmul (TYPE_1__,TYPE_1__) ; \n TYPE_1__ Complex (float,double) ; \n TYPE_1__ Csqrt (TYPE_1__) ; \n TYPE_1__ Csub (TYPE_1__,TYPE_1__) ; \n TYPE_1__ RCmul (float,TYPE_1__) ; \n float cos (float) ; \n int /*<<< orphan*/  nrerror (char*) ; \n double sin (float) ; \n double var23 ; \n double var24 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long *ev7_collect_logout_frame_subpackets(uint64_t *a1, long long *a2) {\n  long long v3;\n  long long v4;\n  uint64_t *v5;\n  int v6;\n  uint64_t *v7;\n  if (*a1 != EL_CLASS__HEADER || a1[1] != EL_TYPE__HEADER__LOGOUT_FRAME)\n    return 0LL;\n  v5 = (uint64_t *)((char *)a1 + a1[3]);\n  if (*v5 != EL_CLASS__PAL || v5[1] != EL_TYPE__PAL__LOGOUT_FRAME) return 0LL;\n  a2[5] = v5[2];\n  v7 = (uint64_t *)((char *)v5 + v5[3]);\n  v6 = 0;\n  while (2) {\n    if (!v7 || v6 >= *(uint32_t *)a2[5]) return a2;\n    if (*v7 == EL_CLASS__PAL) {\n      switch (v7[1]) {\n        case 128LL:\n          a2[2] = v7[2];\n          goto LABEL_17;\n        case 129LL:\n          a2[3] = v7[2];\n          goto LABEL_17;\n        case 130LL:\n          a2[4] = v7[2];\n          goto LABEL_17;\n        case 131LL:\n          a2[1] = v7[2];\n          goto LABEL_17;\n        case 132LL:\n        case 133LL:\n        case 134LL:\n        case 135LL:\n        case 136LL:\n        case 137LL:\n        case 138LL:\n          v3 = v7[2];\n          v4 = *a2;\n          *(uint64_t *)(v4 + 8 * ev7_lf_env_index((unsigned int)v7[1])) = v3;\n        LABEL_17:\n          v7 = (uint64_t *)((char *)v7 + v7[3]);\n          ++v6;\n          continue;\n        default:\n          return 0LL;\n      }\n    }\n    break;\n  }\n  printk(\"%s**UNEXPECTED SUBPACKET CLASS %d IN LOGOUT FRAME (packet %d\\n\",\n         (const char *)(unsigned int)err_print_prefix, *v7, v6);\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "struct type1 *ev7_collect_logout_frame_subpackets(struct type2 *var1,\n                                                  struct type1 *var2) {\n  struct type2 *var3;\n  int var4;\n  if (var1->field1 != var5 || var1->field2 != var6) return NULL;\n  var1 = (struct type2 *)((unsigned long)var1 + var1->field3);\n  if (var1->field1 != var7 || var1->field2 != var8) return NULL;\n  var2->field4 = (struct type3 *)var1->field5.field6.field7;\n  var3 = (struct type2 *)((unsigned long)var1 + var1->field3);\n  for (var4 = 0; var3 && var4 < var2->field4->field8;\n       var3 = (struct type2 *)((unsigned long)var3 + var3->field3), var4++) {\n    if (var3->field1 != var7) {\n      printk(\n          \"%s**UNEXPECTED SUBPACKET CLASS %d \"\n          \"IN LOGOUT FRAME (packet %d\\n\",\n          var9, var3->field1, var4);\n      return NULL;\n    }\n    switch (var3->field2) {\n      case var10:\n        var2->field9 = (struct type4 *)var3->field5.field6.field7;\n        break;\n      case var11:\n        var2->field10 = (struct type5 *)var3->field5.field6.field7;\n        break;\n      case var12:\n        var2->field11 = (struct type6 *)var3->field5.field6.field7;\n        break;\n      case var13:\n        var2->field12 = (struct type7 *)var3->field5.field6.field7;\n        break;\n      case var14:\n      case var15:\n      case var16:\n      case var17:\n      case var18:\n      case var19:\n      case var20:\n        var2->field13[ev7_lf_env_index(var3->field2)] =\n            (struct type8 *)var3->field5.field6.field7;\n        break;\n      default:\n        return NULL;\n    }\n  }\n  return var2;\n}", "style": "rule"}, "extra_info": {"index": 38738, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct type8 {int dummy; } ;\nstruct type7 {int dummy; } ;\nstruct type6 {int dummy; } ;\nstruct type5 {int dummy; } ;\nstruct type4 {int dummy; } ;\nstruct type3 {int field8; } ;\nstruct TYPE_3__ {scalar_t__ field7; } ;\nstruct TYPE_4__ {TYPE_1__ field6; } ;\nstruct type2 {scalar_t__ field1; scalar_t__ field2; TYPE_2__ field5; scalar_t__ field3; } ;\nstruct type1 {struct type8** field13; struct type7* field12; struct type6* field11; struct type5* field10; struct type4* field9; struct type3* field4; } ;\n\n/* Variables and functions */\n size_t ev7_lf_env_index (int) ; \n int /*<<< orphan*/  printk (char*,int /*<<< orphan*/ ,scalar_t__,int) ; \n#define  var10 138 \n#define  var11 137 \n#define  var12 136 \n#define  var13 135 \n#define  var14 134 \n#define  var15 133 \n#define  var16 132 \n#define  var17 131 \n#define  var18 130 \n#define  var19 129 \n#define  var20 128 \n scalar_t__ var5 ; \n scalar_t__ var6 ; \n scalar_t__ var7 ; \n scalar_t__ var8 ; \n int /*<<< orphan*/  var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long mptsas_sas_phy_pg0(unsigned int *a1, uint64_t *a2, long long a3,\n                             long long a4) {\n  unsigned int v5;\n  unsigned int *v7;\n  long long v8;\n  long long v9;\n  unsigned int v10;\n  uint64_t v11[2];\n  int v12;\n  long long v13;\n  uint32_t *v14;\n  uint32_t v15[4];\n  __int128 v16;\n  long long v17;\n  int v18;\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  v11[1] = a4 + a3;\n  v16 = 0LL;\n  v15[0] = 0;\n  v17 = 0LL;\n  v13 = 0LL;\n  LODWORD(v11[0]) = -1;\n  v18 = MPI_SASPHY0_PAGEVERSION;\n  v15[2] = MPI_CONFIG_PAGETYPE_EXTENDED;\n  v15[1] = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;\n  v14 = v15;\n  v12 = SAS_CONFIG_PAGE_TIMEOUT;\n  HIDWORD(v11[0]) = MPI_CONFIG_ACTION_PAGE_HEADER;\n  v5 = mpt_config(a1, v11);\n  if (!v5) {\n    if (v15[0]) {\n      v7 = (unsigned int *)pci_alloc_consistent(*a1, (unsigned int)(4 * v15[0]),\n                                                &v10);\n      v5 = -ENOMEM;\n      if (v7) {\n        v11[0] = _mm_unpacklo_epi32(\n                     _mm_cvtsi32_si128(v10),\n                     _mm_cvtsi32_si128(MPI_CONFIG_ACTION_PAGE_READ_CURRENT))\n                     .m128i_u64[0];\n        v5 = mpt_config(a1, v11);\n        if (!v5) {\n          mptsas_print_phy_pg0(a1, v7);\n          a2[2] = *((uint64_t *)v7 + 1);\n          v8 = le16_to_cpu(v7[1]);\n          v9 = *v7;\n          a2[1] = v8;\n          *a2 = le16_to_cpu(v9);\n        }\n        pci_free_consistent(*a1, (unsigned int)(4 * v15[0]), v7, v10);\n      }\n    } else {\n      return (unsigned int)-ENXIO;\n    }\n  }\n  return v5;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int mptsas_sas_phy_pg0(type1 *var1, struct type2 *var2, type3 var3,\n                              type3 var4) {\n  type4 var5;\n  type5 var6;\n  type6 *var7;\n  type7 var8;\n  int var9;\n  var5.field1 = var10;\n  var5.field2 = 0;\n  var5.field3 = 0;\n  var5.field4 = 0;\n  var5.field5 = 0;\n  var5.field6 = var11;\n  var5.field7 = var12;\n  var6.field8.field9 = &var5;\n  var6.field10 = 0;\n  var6.field11 = var13;\n  var6.field12 = -1;\n  var6.field13 = var3 + var4;\n  var6.field14 = var14;\n  var9 = mpt_config(var1, &var6);\n  if (var9) goto out;\n  if (!var5.field2) {\n    var9 = -var15;\n    goto out;\n  }\n  var7 = pci_alloc_consistent(var1->field15, var5.field2 * 4, &var8);\n  if (!var7) {\n    var9 = -var16;\n    goto out;\n  }\n  var6.field12 = var8;\n  var6.field14 = var17;\n  var9 = mpt_config(var1, &var6);\n  if (var9) goto out_free_consistent;\n  mptsas_print_phy_pg0(var1, var7);\n  var2->field16 = var7->field17;\n  var2->field18 = var7->field19;\n  var2->field20.field21 = le16_to_cpu(var7->field22);\n  var2->field23.field21 = le16_to_cpu(var7->field24);\nout_free_consistent:\n  pci_free_consistent(var1->field15, var5.field2 * 4, var7, var8);\nout:\n  return var9;\n}", "style": "rule"}, "extra_info": {"index": 102516, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_21__   TYPE_7__ ;\ntypedef  struct TYPE_20__   TYPE_6__ ;\ntypedef  struct TYPE_19__   TYPE_5__ ;\ntypedef  struct TYPE_18__   TYPE_4__ ;\ntypedef  struct TYPE_17__   TYPE_3__ ;\ntypedef  struct TYPE_16__   TYPE_2__ ;\ntypedef  struct TYPE_15__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int type7 ;\nstruct TYPE_18__ {int /*<<< orphan*/  field24; int /*<<< orphan*/  field22; int /*<<< orphan*/  field19; int /*<<< orphan*/  field17; } ;\ntypedef  TYPE_4__ type6 ;\nstruct TYPE_15__ {TYPE_6__* field9; } ;\nstruct TYPE_19__ {int field12; int /*<<< orphan*/  field14; scalar_t__ field13; int /*<<< orphan*/  field11; scalar_t__ field10; TYPE_1__ field8; } ;\ntypedef  TYPE_5__ type5 ;\nstruct TYPE_20__ {int field2; int /*<<< orphan*/  field7; int /*<<< orphan*/  field6; scalar_t__ field5; scalar_t__ field4; scalar_t__ field3; int /*<<< orphan*/  field1; } ;\ntypedef  TYPE_6__ type4 ;\ntypedef  scalar_t__ type3 ;\nstruct TYPE_21__ {int /*<<< orphan*/  field15; } ;\ntypedef  TYPE_7__ type1 ;\nstruct TYPE_17__ {void* field21; } ;\nstruct TYPE_16__ {void* field21; } ;\nstruct type2 {TYPE_3__ field23; TYPE_2__ field20; int /*<<< orphan*/  field18; int /*<<< orphan*/  field16; } ;\n\n/* Variables and functions */\n void* le16_to_cpu (int /*<<< orphan*/ ) ; \n int mpt_config (TYPE_7__*,TYPE_5__*) ; \n int /*<<< orphan*/  mptsas_print_phy_pg0 (TYPE_7__*,TYPE_4__*) ; \n TYPE_4__* pci_alloc_consistent (int /*<<< orphan*/ ,int,int*) ; \n int /*<<< orphan*/  pci_free_consistent (int /*<<< orphan*/ ,int,TYPE_4__*,int) ; \n int /*<<< orphan*/  var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n int /*<<< orphan*/  var13 ; \n int /*<<< orphan*/  var14 ; \n int var15 ; \n int var16 ; \n int /*<<< orphan*/  var17 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long rc_init(long long a1, long long a2) {\n  long long result;\n  *(uint64_t *)(a1 + 32) = a2;\n  *(uint64_t *)(a1 + 24) = 0LL;\n  *(uint32_t *)a1 = -1;\n  *(uint64_t *)(a1 + 16) = 0LL;\n  result = a1;\n  *(uint64_t *)(a1 + 8) = 0LL;\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void rc_init(struct type1 *var1, type2 *var2) {\n  var1->field1 = var2;\n  var1->field2 = 0;\n  var1->field3 = 0xffffffff;\n  var1->field4 = 0;\n  var1->field5 = 0;\n}", "style": "rule"}, "extra_info": {"index": 91761, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type2 ;\nstruct type1 {int field3; scalar_t__ field5; scalar_t__ field4; scalar_t__ field2; int /*<<< orphan*/ * field1; } ;\n\n/* Variables and functions */\n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long readcharsetfile(char *filename, char *s1, long long a3) {\n  FILE *v4;\n  char *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  char *v10;\n  const char *v11;\n  unsigned int v12;\n  void *v13;\n  int v14;\n  long long v15;\n  int v16;\n  long long v17;\n  char *v18;\n  int v19;\n  char *v20;\n  char v21[520];\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  errno = 0;\n  memset(v21, 0, 512uLL);\n  v4 = fopen(filename, \"r\");\n  if (!v4) {\n    fprintf((FILE *)(unsigned int)stderr,\n            \"readcharset: File %s could not be opened\\n\", filename);\n    v20 = strerror(errno);\n    fprintf((FILE *)(unsigned int)stderr, \"The problem is = %s\\n\", v20);\n    exit(EXIT_FAILURE);\n  }\n  do {\n    if (!fgets(v21, 512, v4)) goto LABEL_5;\n    v5 = strtok(v21, \" \");\n    LODWORD(v6) = strcmp(s1, v5);\n  } while (v6);\n  strtok(0LL, \"[\");\n  v10 = strtok(0LL, \"\\n\");\n  v11 = v10;\n  if (v10) {\n    v12 = strlen(v10);\n    v13 = calloc(v12, 1uLL);\n    if (!v13) {\n      fprintf((FILE *)(unsigned int)stderr,\n              \"readcharset: can't allocate memory for charset\\n\");\n      exit(EXIT_FAILURE);\n    }\n    v14 = strlen(v11);\n    LODWORD(v15) = strncmp(&v11[v14 - 1], \"]\", 1uLL);\n    if (v15) {\n      v16 = strlen(v11);\n      memcpy(v13, v11, (unsigned int)(v16 - 2));\n    } else {\n      v19 = strlen(v11);\n      memcpy(v13, v11, (unsigned int)(v19 - 1));\n    }\n    v7 = alloc_wide_string(v13, a3);\n    free(v13);\n    LODWORD(v17) = fclose(v4);\n    if (v17) {\n    LABEL_12:\n      fprintf((FILE *)(unsigned int)stderr,\n              \"readcharset: fclose returned error number = %d\\n\", errno);\n      v18 = strerror(errno);\n      fprintf((FILE *)(unsigned int)stderr, \"The problem is = %s\\n\", v18);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n  LABEL_5:\n    v7 = 0LL;\n    LODWORD(v8) = fclose(v4);\n    if (v8) goto LABEL_12;\n  }\n  return v7;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static type1 *readcharsetfile(const char *var1, const char *var2, int *var3) {\n  type2 *var4;\n  char *var5;\n  char *var6;\n  char *var7 = NULL;\n  type1 *var8 = NULL;\n  char var9[512];\n  var10 = 0;\n  memset(var9, 0, sizeof(var9));\n  if ((var4 = fopen(var1, \"r\")) == NULL) {\n    fprintf(var11, \"readcharset: File %s could not be opened\\n\", var1);\n    fprintf(var11, \"The problem is = %s\\n\", strerror(var10));\n    exit(var12);\n  } else {\n    while (fgets(var9, (int)sizeof(var9), var4) != NULL) {\n      var5 = strtok(var9, \" \");\n      if (strcmp(var2, var5) == 0) {\n        var6 = strtok(NULL, \"[\");\n        if ((var6 = strtok(NULL, \"\\n\")) != NULL) {\n          var7 = calloc(strlen(var6), sizeof(char));\n          if (var7 == NULL) {\n            fprintf(var11, \"readcharset: can't allocate memory for charset\\n\");\n            exit(var12);\n          }\n          if (strncmp(&var6[(strlen(var6) - 1)], \"]\", 1) == 0)\n            memcpy(var7, var6, strlen(var6) - 1);\n          else\n            memcpy(var7, var6, strlen(var6) - 2);\n          var8 = alloc_wide_string(var7, var3);\n          free(var7);\n        }\n        break;\n      }\n    }\n    if (fclose(var4) != 0) {\n      fprintf(var11, \"readcharset: fclose returned error number = %d\\n\", var10);\n      fprintf(var11, \"The problem is = %s\\n\", strerror(var10));\n      exit(var12);\n    }\n  }\n  return var8;\n}", "style": "rule"}, "extra_info": {"index": 36369, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var9 ;\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int /*<<< orphan*/  type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/ * alloc_wide_string (char*,int*) ; \n char* calloc (int,int) ; \n int /*<<< orphan*/  exit (int /*<<< orphan*/ ) ; \n scalar_t__ fclose (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * fgets (char*,int,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/ * fopen (char const*,char*) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ; \n int /*<<< orphan*/  free (char*) ; \n int /*<<< orphan*/  memcpy (char*,char*,int) ; \n int /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ; \n scalar_t__ strcmp (char const*,char*) ; \n char* strerror (int) ; \n int strlen (char*) ; \n scalar_t__ strncmp (char*,char*,int) ; \n char* strtok (char*,char*) ; \n int var10 ; \n int /*<<< orphan*/  var11 ; \n int /*<<< orphan*/  var12 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long setup() {\n  long long v0;\n  long long v1;\n  uint64_t *v2;\n  uint64_t *v3;\n  uint64_t *v4;\n  uint64_t *v5;\n  uint64_t *v6;\n  uint64_t *v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  unsigned int v13;\n  int v14;\n  int v15;\n  unsigned long long v16;\n  Visual *v17;\n  unsigned int v18;\n  int v19;\n  unsigned int v20;\n  unsigned int v21;\n  int i;\n  int j;\n  int v25;\n  XModifierKeymap *v26;\n  XClassHint *v27;\n  uint32_t v28[3];\n  unsigned long long v29;\n  v29 = __readfsqword(40u);\n  v26 = XGetModifierMapping((Display *)(unsigned int)dpy);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j < v26->max_keypermod; ++j) {\n      v0 = *(uint64_t *)&v26->modifiermap[8 * i * v26->max_keypermod + 8 * j];\n      LOBYTE(v1) = XKeysymToKeycode((Display *)(unsigned int)dpy,\n                                    (unsigned int)XK_Num_Lock);\n      if (v0 == v1) numlockmask = 1 << i;\n    }\n  }\n  XFreeModifiermap(v26);\n  initfont((unsigned int)font);\n  v2 = (uint64_t *)(*((uint64_t *)&dc + 6) + 8 * ColBG);\n  *v2 = getcolor((unsigned int)normbgcolor);\n  v3 = (uint64_t *)(*((uint64_t *)&dc + 6) + 8 * ColFG);\n  *v3 = getcolor((unsigned int)normfgcolor);\n  v4 = (uint64_t *)(*((uint64_t *)&dc + 5) + 8 * ColBG);\n  *v4 = getcolor((unsigned int)selbgcolor);\n  v5 = (uint64_t *)(*((uint64_t *)&dc + 5) + 8 * ColFG);\n  *v5 = getcolor((unsigned int)selfgcolor);\n  v6 = (uint64_t *)(*((uint64_t *)&dc + 4) + 8 * ColBG);\n  *v6 = getcolor((unsigned int)lastbgcolor);\n  v7 = (uint64_t *)(*((uint64_t *)&dc + 4) + 8 * ColFG);\n  *v7 = getcolor((unsigned int)lastfgcolor);\n  v28[2] = True;\n  v28[1] = ParentRelative;\n  v28[0] = ButtonPressMask | ExposureMask | KeyPressMask;\n  mh = dc + 2;\n  if (dc + 2 < dword_6D0) mh = dword_6D0;\n  x = 0;\n  if (topbar)\n    v8 = 0;\n  else\n    v8 = DisplayHeight((unsigned int)dpy, (unsigned int)screen) - mh;\n  y = v8;\n  mw = DisplayWidth((unsigned int)dpy, (unsigned int)screen);\n  if (lines) {\n    v9 = lines;\n  } else {\n    lines = height / (dc + 2);\n    v9 = height / (dc + 2);\n  }\n  if (indicators)\n    v10 = 3;\n  else\n    v10 = 1;\n  if (vlist)\n    v11 = (v10 + v9) * (dc + 2);\n  else\n    v11 = mh;\n  mh = v11;\n  if (topbar)\n    v12 = y + yoffset;\n  else\n    v12 = y - mh + dc + 2 - yoffset;\n  v25 = v12;\n  if (alignright) {\n    if (width)\n      v13 = mw - width;\n    else\n      v13 = 0;\n    v14 = v13 - xoffset;\n  } else {\n    v14 = xoffset;\n  }\n  x = v14;\n  if (width)\n    v15 = width;\n  else\n    v15 = mw;\n  mw = v15;\n  v16 = CWEventMask | CWBackPixmap | (unsigned int)CWOverrideRedirect;\n  v17 = (Visual *)(unsigned int)DefaultVisual((unsigned int)dpy,\n                                              (unsigned int)screen);\n  v18 = CopyFromParent;\n  v19 = DefaultDepth((unsigned int)dpy, (unsigned int)screen);\n  LODWORD(win) =\n      XCreateWindow((Display *)(unsigned int)dpy, (unsigned int)root, x, v25,\n                    mw, mh, 0, v19, v18, v17, v16, (XSetWindowAttributes *)v28);\n  v20 = DefaultDepth((unsigned int)dpy, (unsigned int)screen);\n  *(&dc + 7) = XCreatePixmap((Display *)(unsigned int)dpy, (unsigned int)root,\n                             mw, mh, v20);\n  *(&dc + 6) = (unsigned int)XCreateGC((Display *)(unsigned int)dpy,\n                                       (unsigned int)root, 0LL, 0LL);\n  XSetLineAttributes((Display *)(unsigned int)dpy, (GC)(unsigned int)*(&dc + 6),\n                     1u, LineSolid, CapButt, JoinMiter);\n  if (!*(&dc + 4))\n    XSetFont((Display *)(unsigned int)dpy, (GC)(unsigned int)*(&dc + 6),\n             **((unsigned int **)&dc + 1));\n  if (maxname) cmdw = textw(maxname);\n  if ((int)mw / 3 < cmdw) cmdw = (int)mw / 3;\n  if (prompt) promptw = textw(prompt);\n  if ((int)mw / 5 < promptw) promptw = (int)mw / 5;\n  *(uint64_t *)text = 0LL;\n  if (xmms)\n    v21 = 8 * maxtokens;\n  else\n    v21 = 8;\n  tokens = (unsigned int)malloc(v21);\n  match(text);\n  XMapRaised((Display *)(unsigned int)dpy, (unsigned int)win);\n  v27 = XAllocClassHint();\n  v27->res_name = \"dmenu\";\n  v27->res_class = \"DockApp\";\n  XSetClassHint((Display *)(unsigned int)dpy, (unsigned int)win, v27);\n  XFree(v27);\n  return v29 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void setup(void) {\n  int var1, var2, var3, var4;\n  type1 *var5;\n  type2 var6;\n  var5 = XGetModifierMapping(var7);\n  for (var1 = 0; var1 < 8; var1++)\n    for (var2 = 0; var2 < var5->field1; var2++) {\n      if (var5->field2[var1 * var5->field1 + var2] ==\n          XKeysymToKeycode(var7, var8))\n        var9 = (1 << var1);\n    }\n  XFreeModifiermap(var5);\n  initfont(var10);\n# 930 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/hakt0r/dmenu-fly/refs/heads/master/dmenu.c\"\n  var11.field3.field4[var12] = getcolor(var13);\n  var11.field3.field4[var14] = getcolor(var15);\n  var11.field5.field4[var12] = getcolor(var16);\n  var11.field5.field4[var14] = getcolor(var17);\n  var11.field6.field4[var12] = getcolor(var18);\n  var11.field6.field4[var14] = getcolor(var19);\n  var6.field7 = var20;\n  var6.field8 = var21;\n  var6.field9 = var22 | var23 | var24;\n  var25 = var11.field10.field11 + 2;\n  if (var25 < var26) var25 = var26;\n# 968 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/hakt0r/dmenu-fly/refs/heads/master/dmenu.c\"\n  {\n    var27 = 0;\n    var28 = var29 ? 0 : DisplayHeight(var7, var30) - var25;\n    var31 = DisplayWidth(var7, var30);\n  }\n  var4 = (var32 ? var32 : (var32 = var33 / (var11.field10.field11 + 2))) +\n         (var34 ? 3 : 1);\n  var25 = var35 ? (var11.field10.field11 + 2) * var4 : var25;\n  var3 = var29 ? var28 + var36\n               : var28 - var25 + (var11.field10.field11 + 2) - var36;\n  var27 = var37 ? var31 - (var38 ? var38 : var31) - var39 : var39;\n  var31 = var38 ? var38 : var31;\n  var40 = XCreateWindow(\n      var7, var41, var27, var3, var31, var25, 0, DefaultDepth(var7, var30),\n      var42, DefaultVisual(var7, var30), var43 | var44 | var45, &var6);\n  var11.field12 =\n      XCreatePixmap(var7, var41, var31, var25, DefaultDepth(var7, var30));\n  var11.field13 = XCreateGC(var7, var41, 0, NULL);\n  XSetLineAttributes(var7, var11.field13, 1, var46, var47, var48);\n# 999 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/hakt0r/dmenu-fly/refs/heads/master/dmenu.c\"\n  if (!var11.field10.field14)\n    XSetFont(var7, var11.field13, var11.field10.field15->field16);\n  if (var49) var50 = textw(var49);\n  if (var50 > var31 / 3) var50 = var31 / 3;\n  if (var51) var52 = textw(var51);\n  if (var52 > var31 / 5) var52 = var31 / 5;\n  var53[0] = 0;\n  var54 = malloc((var55 ? var56 : 1) * sizeof(char *));\n  match(var53);\n  XMapRaised(var7, var40);\n  type3 *var57 = XAllocClassHint();\n  var57->field17 = \"dmenu\";\n  var57->field18 = \"DockApp\";\n  XSetClassHint(var7, var40, var57);\n  XFree(var57);\n}", "style": "rule"}, "extra_info": {"index": 93828, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_24__   TYPE_9__ ;\ntypedef  struct TYPE_23__   TYPE_8__ ;\ntypedef  struct TYPE_22__   TYPE_7__ ;\ntypedef  struct TYPE_21__   TYPE_6__ ;\ntypedef  struct TYPE_20__   TYPE_5__ ;\ntypedef  struct TYPE_19__   TYPE_4__ ;\ntypedef  struct TYPE_18__   TYPE_3__ ;\ntypedef  struct TYPE_17__   TYPE_2__ ;\ntypedef  struct TYPE_16__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_21__ {char* field17; char* field18; } ;\ntypedef  TYPE_6__ type3 ;\nstruct TYPE_22__ {int field9; int /*<<< orphan*/  field8; int /*<<< orphan*/  field7; } ;\ntypedef  TYPE_7__ type2 ;\nstruct TYPE_23__ {int field1; scalar_t__* field2; } ;\ntypedef  TYPE_8__ type1 ;\nstruct TYPE_20__ {int field11; TYPE_4__* field15; int /*<<< orphan*/  field14; } ;\nstruct TYPE_18__ {void** field4; } ;\nstruct TYPE_17__ {void** field4; } ;\nstruct TYPE_16__ {void** field4; } ;\nstruct TYPE_24__ {TYPE_5__ field10; int /*<<< orphan*/  field13; int /*<<< orphan*/  field12; TYPE_3__ field6; TYPE_2__ field5; TYPE_1__ field3; } ;\nstruct TYPE_19__ {int /*<<< orphan*/  field16; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  DefaultDepth (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  DefaultVisual (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int DisplayHeight (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int DisplayWidth (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n TYPE_6__* XAllocClassHint () ; \n int /*<<< orphan*/  XCreateGC (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  XCreatePixmap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  XCreateWindow (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,TYPE_7__*) ; \n int /*<<< orphan*/  XFree (TYPE_6__*) ; \n int /*<<< orphan*/  XFreeModifiermap (TYPE_8__*) ; \n TYPE_8__* XGetModifierMapping (int /*<<< orphan*/ ) ; \n scalar_t__ XKeysymToKeycode (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  XMapRaised (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  XSetClassHint (int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_6__*) ; \n int /*<<< orphan*/  XSetFont (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  XSetLineAttributes (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n void* getcolor (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  initfont (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  malloc (int) ; \n int /*<<< orphan*/  match (scalar_t__*) ; \n int textw (scalar_t__) ; \n int /*<<< orphan*/  var10 ; \n TYPE_9__ var11 ; \n size_t var12 ; \n int /*<<< orphan*/  var13 ; \n size_t var14 ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var16 ; \n int /*<<< orphan*/  var17 ; \n int /*<<< orphan*/  var18 ; \n int /*<<< orphan*/  var19 ; \n int /*<<< orphan*/  var20 ; \n int /*<<< orphan*/  var21 ; \n int var22 ; \n int var23 ; \n int var24 ; \n int var25 ; \n int var26 ; \n int var27 ; \n int var28 ; \n scalar_t__ var29 ; \n int /*<<< orphan*/  var30 ; \n int var31 ; \n int var32 ; \n int var33 ; \n scalar_t__ var34 ; \n scalar_t__ var35 ; \n int var36 ; \n scalar_t__ var37 ; \n int var38 ; \n int var39 ; \n int /*<<< orphan*/  var40 ; \n int /*<<< orphan*/  var41 ; \n int /*<<< orphan*/  var42 ; \n int var43 ; \n int var44 ; \n int var45 ; \n int /*<<< orphan*/  var46 ; \n int /*<<< orphan*/  var47 ; \n int /*<<< orphan*/  var48 ; \n scalar_t__ var49 ; \n int var50 ; \n scalar_t__ var51 ; \n int var52 ; \n scalar_t__* var53 ; \n int /*<<< orphan*/  var54 ; \n scalar_t__ var55 ; \n int var56 ; \n int /*<<< orphan*/  var7 ; \n int /*<<< orphan*/  var8 ; \n int var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  uint64_t *v3;\n  int result;\n  int v5;\n  int v6;\n  uint64_t v7[5];\n  v7[1] = __readfsqword(40u);\n  v3 = malloc(16uLL);\n  v7[0] = v3;\n  result = 1;\n  if (v3) {\n    v3[1] = 0LL;\n    *v3 = 0LL;\n    insert_tail(v3, 10LL);\n    insert_tail(v7[0], 20LL);\n    insert_tail(v7[0], 30LL);\n    insert_head(v7, 10LL);\n    insert_head(v7, 20LL);\n    insert_head(v7, 30LL);\n    print_list(v7[0]);\n    v5 = remove_head(v7);\n    printf(\"%d\\n\", v5);\n    v6 = remove_tail(v7[0]);\n    printf(\"%d\\n\", v6);\n    remove_value(v7, 0LL);\n    print_list(v7[0]);\n    delete_list(v7[0]);\n    return 0;\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int main(void) {\n  type1 *var1 = NULL;\n  var1 = malloc(sizeof(var2));\n  if (var1 == NULL) return 1;\n  var1->field1 = 0;\n  var1->field2 = NULL;\n  insert_tail(var1, 10);\n  insert_tail(var1, 20);\n  insert_tail(var1, 30);\n  insert_head(&var1, 10);\n  insert_head(&var1, 20);\n  insert_head(&var1, 30);\n  print_list(var1);\n  printf(\"%d\\n\", remove_head(&var1));\n  printf(\"%d\\n\", remove_tail(var1));\n  remove_value(&var1, 0);\n  print_list(var1);\n  delete_list(var1);\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 94349, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var2 ;\nstruct TYPE_10__ {int /*<<< orphan*/ * field2; scalar_t__ field1; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  delete_list (TYPE_1__*) ; \n int /*<<< orphan*/  insert_head (TYPE_1__**,int) ; \n int /*<<< orphan*/  insert_tail (TYPE_1__*,int) ; \n TYPE_1__* malloc (int) ; \n int /*<<< orphan*/  print_list (TYPE_1__*) ; \n int /*<<< orphan*/  printf (char*,int) ; \n int remove_head (TYPE_1__**) ; \n int remove_tail (TYPE_1__*) ; \n int /*<<< orphan*/  remove_value (TYPE_1__**,int /*<<< orphan*/ ) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long message_decode(uint8_t *a1, unsigned int *a2) {\n  long long v2;\n  uint8_t *v3;\n  unsigned int v4;\n  char v5;\n  long long v6;\n  char v7;\n  unsigned int v8;\n  int v9;\n  __m128i *v10;\n  char *v11;\n  char *v12;\n  __m128i *v13;\n  uint8_t *v14;\n  long long v15;\n  __m128i *v16;\n  __m128i v17;\n  int v18;\n  long long v19;\n  char *v20;\n  unsigned int v21;\n  unsigned int v22;\n  int v23;\n  int v24;\n  long long v25;\n  char *v27;\n  long long v28;\n  char v29;\n  __m128i *v30;\n  v2 = 0LL;\n  v3 = a1;\n  v4 = 0;\n  if (*a1 != 255) {\n    *a2 = -1;\n    return v2;\n  }\n  do {\n    v5 = v3[1];\n    if (v5 != -86 && v5 != -2) {\n      v6 = 0LL;\n      do {\n        v7 = v3[v6 + 2];\n        v8 = v6;\n        v9 = v6++;\n      } while (v7 != -86 && v7 != -2);\n      v10 = (__m128i *)malloc(v8 + 2);\n      bzero(v10, (unsigned int)(v9 + 2));\n      v13 = v10;\n      v14 = v3 + 1;\n      if ((unsigned long long)((char *)v10 - (v3 + 2)) <= 14 || v8 <= 6) {\n        v27 = (char *)v10;\n        v28 = v3 - (uint8_t *)v10;\n        v15 = v8 + 1;\n        v11 = &v10->m128i_i8[v15];\n        do {\n          v29 = v27[v28 + 1];\n          *v27++ = v29;\n        } while (v27 != v11);\n        goto LABEL_22;\n      }\n      LODWORD(v15) = v8 + 1;\n      if (v8 <= 14) {\n        v22 = v8 + 1;\n        v12 = (char *)v10;\n        v20 = v3 + 1;\n        v18 = 0;\n        v19 = 0LL;\n      } else {\n        v16 = v10;\n        do {\n          v17 = _mm_loadu_si128(\n              (const __m128i *)&v16->m128i_i8[v3 - (uint8_t *)v10 + 1]);\n          ++v16;\n          v16[-1] = v17;\n        } while (&v10[(unsigned int)v15 >> 4] != v16);\n        v18 = v15 & 4294967280;\n        v19 = (unsigned int)v15 & 4294967280;\n        v20 = &v14[v19];\n        v12 = &v10->m128i_i8[v19];\n        if ((uint32_t)v15 == (v15 & 4294967280)) goto LABEL_22;\n        v21 = v8 - v18;\n        v22 = v21 + 1;\n        if (v21 <= 6) {\n        LABEL_15:\n          *v12 = *v20;\n          if (v9 > v18) {\n            v12[1] = v20[1];\n            if (v9 > v18 + 1) {\n              v12[2] = v20[2];\n              if (v9 > v18 + 2) {\n                v12[3] = v20[3];\n                v23 = v18 + 4;\n                if (v9 > v18 + 3) {\n                  v24 = v18 + 5;\n                  v12[4] = v20[4];\n                  if (v9 > v23) {\n                    v12[5] = v20[5];\n                    if (v9 > v24) v12[6] = v20[6];\n                  }\n                }\n              }\n            }\n          }\n          goto LABEL_22;\n        }\n      }\n      *(long long *)((char *)v10->m128i_i64 + v19) = *(uint64_t *)&v3[v19 + 1];\n      v18 += v22 & 4294967288;\n      v20 += v22 & 4294967288;\n      v12 += v22 & 4294967288;\n      if (v22 != (v22 & 4294967288)) goto LABEL_15;\n    LABEL_22:\n      v3 = &v14[(unsigned int)v15];\n      goto LABEL_23;\n    }\n    v30 = (__m128i *)malloc(1uLL);\n    bzero(v30, 1uLL);\n    ++v3;\n    v13 = v30;\n  LABEL_23:\n    v25 = v4++;\n    v2 = matrix_append(v2, v25, v13, v14, v11, v12);\n  } while (*v3 != 254);\n  if (a2) *a2 = v4;\n  return v2;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "char **message_decode(char *var1, int *var2) {\n  char **var3 = NULL;\n  int var4 = 0;\n  unsigned char *var5 = var1;\n  if (*var5 != 0xFF) {\n    *var2 = -1;\n    return NULL;\n  } else {\n    do {\n      var5++;\n      int var6 = 0;\n      unsigned char *var7 = var5;\n      while (*var7 != 0xAA && *var7 != 0xFE) {\n        var6++;\n        var7++;\n      }\n      int var8;\n      char *var9 = (char *)malloc(sizeof(char) * var6 + 1);\n      bzero(var9, var6 + 1);\n      char *var10 = var9;\n      for (var8 = 0; var8 < var6; var8++) {\n        *var10 = *var5;\n        var10++;\n        var5++;\n      }\n      var10 = '\\0';\n      var3 = matrix_append(var3, var4, var9);\n      var4++;\n    } while (*var5 != 0xFE);\n  }\n  if (var2 != NULL) {\n    *var2 = var4;\n  }\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 36084, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  bzero (char*,int) ; \n scalar_t__ malloc (int) ; \n char** matrix_append (char**,int,char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint sb_dump(uint32_t *a1) {\n  puts(\"Superblock informaton:\");\n  printf(\"EXT2 Magic\\t%x\\n\", *a1);\n  printf(\"Inodes Count\\t%d\\t\", a1[1]);\n  printf(\"Blocks Count\\t%d\\t\", a1[2]);\n  printf(\"RBlock Count\\t%d\\n\", a1[3]);\n  printf(\"FBlock Count\\t%d\\t\", a1[4]);\n  printf(\"FInode Count\\t%d\\t\", a1[5]);\n  printf(\"First Data Block\\t%d\\n\", a1[6]);\n  printf(\"Block Size\\t%d\\t\", 1024 << a1[7]);\n  printf(\"Fragment Sz \\t%d\\t\", 1024 << a1[8]);\n  printf(\"Block/Group\\t%d\\n\", a1[9]);\n  printf(\"Frag/Group \\t%d\\t\", a1[10]);\n  printf(\"Inode/Group\\t%d\\t\", a1[11]);\n  printf(\"mtime\\t%x\\n\", a1[12]);\n  printf(\"wtime\\t%x\\t\", a1[13]);\n  printf(\"Mount #\\t%x\\t\", a1[14]);\n  printf(\"Max mounts\\t%x\\n\", a1[15]);\n  printf(\"State\\t%x\\t\", a1[16]);\n  printf(\"Errors\\t%x\\t\", a1[17]);\n  printf(\"Minor\\t%x\\n\", a1[18]);\n  printf(\"Last Chk\\t%x\\t\", a1[19]);\n  printf(\"Chk int\\t%x\\t\", a1[20]);\n  printf(\"OS\\t%x\\n\", a1[21]);\n  printf(\"Rev #\\t%x\\t\", a1[22]);\n  printf(\"ResUID\\t%x\\t\", a1[23]);\n  return printf(\"ResGID\\t%x\\n\", a1[24]);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void sb_dump(struct type1* var1) {\n  printf(\"Superblock informaton:\\n\");\n  printf(\"EXT2 Magic\\t%x\\n\", var1->field1);\n  printf(\"Inodes Count\\t%d\\t\", var1->field2);\n  printf(\"Blocks Count\\t%d\\t\", var1->field3);\n  printf(\"RBlock Count\\t%d\\n\", var1->field4);\n  printf(\"FBlock Count\\t%d\\t\", var1->field5);\n  ;\n  printf(\"FInode Count\\t%d\\t\", var1->field6);\n  printf(\"First Data Block\\t%d\\n\", var1->field7);\n  printf(\"Block Size\\t%d\\t\", 1024 << var1->field8);\n  printf(\"Fragment Sz \\t%d\\t\", 1024 << var1->field9);\n  printf(\"Block/Group\\t%d\\n\", var1->field10);\n  printf(\"Frag/Group \\t%d\\t\", var1->field11);\n  printf(\"Inode/Group\\t%d\\t\", var1->field12);\n  printf(\"mtime\\t%x\\n\", var1->field13);\n  printf(\"wtime\\t%x\\t\", var1->field14);\n  printf(\"Mount #\\t%x\\t\", var1->field15);\n  printf(\"Max mounts\\t%x\\n\", var1->field16);\n  printf(\"State\\t%x\\t\", var1->field17);\n  printf(\"Errors\\t%x\\t\", var1->field18);\n  printf(\"Minor\\t%x\\n\", var1->field19);\n  printf(\"Last Chk\\t%x\\t\", var1->field20);\n  printf(\"Chk int\\t%x\\t\", var1->field21);\n  printf(\"OS\\t%x\\n\", var1->field22);\n  printf(\"Rev #\\t%x\\t\", var1->field23);\n  printf(\"ResUID\\t%x\\t\", var1->field24);\n  printf(\"ResGID\\t%x\\n\", var1->field25);\n}", "style": "rule"}, "extra_info": {"index": 6767, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct type1 {int field1; int field2; int field3; int field4; int field5; int field6; int field7; int field8; int field9; int field10; int field11; int field12; int field13; int field14; int field15; int field16; int field17; int field18; int field19; int field20; int field21; int field22; int field23; int field24; int field25; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long mc_rand_prime(int a1, int a2) {\n  int v2;\n  int v3;\n  unsigned int v4;\n  unsigned int v5;\n  v2 = 0;\n  if (a1 >= 0) v2 = a1;\n  v3 = 2147483647;\n  v4 = v2;\n  if (a2 > 0) {\n    v3 = a2;\n    if (v2 > a2) {\n      v4 = a2;\n      v3 = v2;\n    }\n  }\n  if ((int)(v3 - v4) <= 3) {\n    return (unsigned int)-1;\n  } else {\n  LABEL_7:\n    v5 = mc_rand_odd(v4, (unsigned int)v3);\n    while (!(unsigned int)mc_isprime(v5)) {\n      v5 += 2;\n      if (v3 <= (int)v5) goto LABEL_7;\n    }\n  }\n  return v5;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int mc_rand_prime(int var1, int var2) {\n  int var3;\n  var1 = (var1 > 0) ? var1 : 0;\n  var2 = (var2 > 0) ? var2 : 0x7FFFFFFF;\n  if (var1 > var2) {\n    var3 = var2;\n    var2 = var1;\n    var1 = var3;\n  }\n  if ((var2 - var1) <= 3) {\n    return -1;\n  }\n  var3 = mc_rand_odd(var1, var2);\n  while (!mc_isprime(var3)) {\n    var3 += 2;\n    if (var3 >= var2) {\n      var3 = mc_rand_odd(var1, var2);\n    }\n  }\n  return var3;\n}", "style": "rule"}, "extra_info": {"index": 43116, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  mc_isprime (int) ; \n int mc_rand_odd (int,int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint printLine(char a1, int a2) {\n  int i;\n  if (a2 > 0) {\n    for (i = 0; i != a2; ++i) putchar(a1);\n  }\n  return putchar(10);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void printLine(char var1, int var2) {\n  int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    putchar(var1);\n  }\n  putchar('\\n');\n}", "style": "rule"}, "extra_info": {"index": 5723, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  putchar (char) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint8_t test_char() {\n  unsigned int v0;\n  bool v1;\n  unsigned int v2;\n  int v3;\n  unsigned int v4;\n  int v5;\n  unsigned int v6;\n  int v7;\n  unsigned int v8;\n  int v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  int v13;\n  unsigned int v14;\n  int v15;\n  unsigned int v16;\n  int v17;\n  unsigned int v18;\n  int v19;\n  unsigned int v20;\n  int v21;\n  unsigned int v22;\n  int v23;\n  unsigned int v24;\n  int v25;\n  unsigned int v26;\n  v0 = TEST_char_eq(97LL, 97LL);\n  v1 = (unsigned int)TEST(1LL, v0) == 0;\n  v2 = TEST_char_eq(97LL, 65LL);\n  v3 = v1 | ((unsigned int)TEST(0LL, v2) == 0);\n  v4 = TEST_char_ne(97LL, 99LL);\n  v5 = ((unsigned int)TEST(1LL, v4) == 0) | v3;\n  v6 = TEST_char_ne(101LL, 101LL);\n  v7 = ((unsigned int)TEST(0LL, v6) == 0) | v5;\n  v8 = TEST_char_lt(105LL, 120LL);\n  v9 = ((unsigned int)TEST(1LL, v8) == 0) | v7;\n  v10 = TEST_char_lt(120LL, 105LL);\n  v11 = ((unsigned int)TEST(0LL, v10) == 0) | v9;\n  v12 = TEST_char_le(105LL, 120LL);\n  v13 = ((unsigned int)TEST(1LL, v12) == 0) | v11;\n  v14 = TEST_char_le(110LL, 110LL);\n  v15 = ((unsigned int)TEST(1LL, v14) == 0) | v13;\n  v16 = TEST_char_le(120LL, 105LL);\n  v17 = ((unsigned int)TEST(0LL, v16) == 0) | v15;\n  v18 = TEST_char_gt(119LL, 110LL);\n  v19 = ((unsigned int)TEST(1LL, v18) == 0) | v17;\n  v20 = TEST_char_gt(110LL, 119LL);\n  v21 = ((unsigned int)TEST(0LL, v20) == 0) | v19;\n  v22 = TEST_char_ge(119LL, 110LL);\n  v23 = ((unsigned int)TEST(1LL, v22) == 0) | v21;\n  v24 = TEST_char_ge(112LL, 112LL);\n  v25 = ((unsigned int)TEST(1LL, v24) == 0) | v23;\n  v26 = TEST_char_ge(110LL, 119LL);\n  return (v25 | ((unsigned int)TEST(0LL, v26) == 0)) == 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static int test_char(void) {\n  if (!TEST(1, TEST_char_eq('a', 'a')) | !TEST(0, TEST_char_eq('a', 'A')) |\n      !TEST(1, TEST_char_ne('a', 'c')) | !TEST(0, TEST_char_ne('e', 'e')) |\n      !TEST(1, TEST_char_lt('i', 'x')) | !TEST(0, TEST_char_lt('x', 'i')) |\n      !TEST(1, TEST_char_le('i', 'x')) | !TEST(1, TEST_char_le('n', 'n')) |\n      !TEST(0, TEST_char_le('x', 'i')) | !TEST(1, TEST_char_gt('w', 'n')) |\n      !TEST(0, TEST_char_gt('n', 'w')) | !TEST(1, TEST_char_ge('w', 'n')) |\n      !TEST(1, TEST_char_ge('p', 'p')) | !TEST(0, TEST_char_ge('n', 'w')))\n    goto err;\n  return 1;\nerr:\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 99401, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  TEST (int,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  TEST_char_eq (char,char) ; \n int /*<<< orphan*/  TEST_char_ge (char,char) ; \n int /*<<< orphan*/  TEST_char_gt (char,char) ; \n int /*<<< orphan*/  TEST_char_le (char,char) ; \n int /*<<< orphan*/  TEST_char_lt (char,char) ; \n int /*<<< orphan*/  TEST_char_ne (char,char) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid resize_mask(int a1, double a2) {\n  long long v2;\n  long long v3;\n  long long v4;\n  uint32_t *v5;\n  int v6;\n  long long i;\n  long long v8;\n  long long v9;\n  int v10;\n  long long v11;\n  int v12;\n  uint32_t *v13;\n  long long v14;\n  if (EXPLORE == 1 && numf == a1) {\n    if (D2BINS <= 0) {\n      EXPLORE = 0;\n    } else {\n      v2 = mask;\n      v3 = HIGHESTESTATE;\n      v4 = 0LL;\n      v5 = (uint32_t *)LOWESTESTATE;\n      do {\n        v6 = D1BINS;\n        for (i = 0LL; v6 > (int)i; ++i) {\n          if (!*(uint32_t *)(*(uint64_t *)(v2 + 8 * i) + 4 * v4) &&\n              *(uint32_t *)(v3 + 4 * v4) > (int)i) {\n            v5[v4] = i;\n            v6 = D1BINS;\n          }\n        }\n        v5[v4] = v6 - (int)((double)(v6 - v5[v4]) * a2);\n        ++v4;\n      } while (D2BINS > (int)v4);\n      EXPLORE = 0;\n      if (D2BINS > 0) {\n        v8 = wllng;\n        v9 = 0LL;\n        v10 = 0;\n        if (D1BINS > 0) {\n          do {\n            v11 = 0LL;\n            do {\n              while (1) {\n                v13 = (uint32_t *)(v9 + *(uint64_t *)(v2 + 8 * v11));\n                if (*v5 > (int)v11 || *(uint32_t *)(v3 + v9) <= (int)v11) break;\n                *v13 = 1;\n                v12 = D1BINS;\n                if (D1BINS <= (int)++v11) goto LABEL_19;\n              }\n              *v13 = 0;\n              v14 = *(uint64_t *)(v8 + 8 * v11++);\n              *(uint64_t *)(v14 + 2 * v9) = 0LL;\n              v12 = D1BINS;\n            } while (D1BINS > (int)v11);\n          LABEL_19:\n            if (++v10 >= D2BINS) break;\n            ++v5;\n            v9 += 4LL;\n          } while (v12 > 0);\n        }\n      }\n    }\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void resize_mask(double var1, int var2) {\n  int var3, var4;\n  if (var5 == 1 && var6 == var2) {\n    for (var4 = 0; var4 < var7; var4++) {\n      for (var3 = 0; var3 < var8; var3++) {\n        if (var9[var3][var4] == 0 && var3 < var10[var4]) {\n          var11[var4] = var3;\n        }\n      }\n      var11[var4] = var11[var4] + (var8 - var11[var4]) -\n                    (int)(var1 * (var8 - var11[var4]));\n    }\n    var5 = 0;\n    for (var4 = 0; var4 < var7; var4++)\n      for (var3 = 0; var3 < var8; var3++) {\n        if (var3 >= var11[var4] && var3 < var10[var4]) {\n          var9[var3][var4] = 1;\n        } else {\n          var9[var3][var4] = 0;\n          var12[var3][var4] = 0.0;\n        }\n      }\n  };\n}", "style": "rule"}, "extra_info": {"index": 21083, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int* var10 ; \n int* var11 ; \n double** var12 ; \n int var5 ; \n int var6 ; \n int var7 ; \n int var8 ; \n int** var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long DMD_setClippingArea(long long a1, long long a2, long long a3,\n                              long long a4) {\n  if (!initialized) return 1LL;\n  if (a3 + a1 > dimensions[0] || a4 + a2 > dimensions[1]) return 4LL;\n  if (!a3 || !a4) return 5LL;\n  DMDIF_writeReg(69LL, a1);\n  DMDIF_writeReg(70LL, a1 + a3 - 1);\n  DMDIF_writeReg(68LL, a2 | ((a2 + a4 - 1) << 8));\n  dimensions[5] = a1;\n  dimensions[4] = a2;\n  dimensions[3] = a3;\n  dimensions[2] = a4;\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 DMD_setClippingArea(uint16_t var1, uint16_t var2, uint16_t var3,\n                          uint16_t var4) {\n  uint16_t var5;\n  uint16_t var6;\n  uint16_t var7;\n  if (!var8) {\n    return (0x00000000 | 0x0001);\n  }\n  if (var1 + var3 > var9.field1 || var2 + var4 > var9.field2) {\n    return (0x00000000 | 0x0004);\n  }\n  if (var3 == 0 || var4 == 0) {\n    return (0x00000000 | 0x0005);\n  }\n  var6 = var1 + var3 - 1;\n  var7 = var2 + var4 - 1;\n  DMDIF_writeReg(0x45, var1);\n  DMDIF_writeReg(0x46, var6);\n  var5 = var7 << 8;\n  var5 |= var2 << 0;\n  DMDIF_writeReg(0x44, var5);\n  var9.field3 = var1;\n  var9.field4 = var2;\n  var9.field5 = var3;\n  var9.field6 = var4;\n  return 0x00000000;\n}", "style": "rule"}, "extra_info": {"index": 108597, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint16_t ;\ntypedef  int type1 ;\nstruct TYPE_2__ {scalar_t__ field1; scalar_t__ field2; scalar_t__ field6; scalar_t__ field5; scalar_t__ field4; scalar_t__ field3; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  DMDIF_writeReg (int,scalar_t__) ; \n int /*<<< orphan*/  var8 ; \n TYPE_1__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long MP4AddTrackReference(long long a1, long long a2, long long a3,\n                               long long a4) {\n  long long v7;\n  long long TrackID;\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  TrackID = MP4NoErr;\n  if (!a1 || !a2) return MP4BadParamErr;\n  TrackID = MP4GetTrackID(a2, &v7);\n  if (!TrackID) {\n    if (v7)\n      return MP4AddTrackReferenceWithID(a1, v7, a3, a4);\n    else\n      return MP4InvalidMediaErr;\n  }\n  return TrackID;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "extern type1 MP4AddTrackReference(type2 var1, type2 var2, type3 var3,\n                                  type3 *var4) {\n  type1 var5;\n  type3 var6;\n  var5 = var7;\n  if ((var1 == 0) || (var2 == 0)) {\n    var5 = (var8);\n    goto bail;\n  };\n  var5 = MP4GetTrackID(var2, &var6);\n  if (var5) goto bail;\n  if (var6 == 0) {\n    var5 = (var9);\n    goto bail;\n  };\n  var5 = MP4AddTrackReferenceWithID(var1, var6, var3, var4);\n  if (var5) goto bail;\nbail:;\n  return var5;\n}", "style": "rule"}, "extra_info": {"index": 64313, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ type3 ;\ntypedef  scalar_t__ type2 ;\ntypedef  scalar_t__ type1 ;\n\n/* Variables and functions */\n scalar_t__ MP4AddTrackReferenceWithID (scalar_t__,scalar_t__,scalar_t__,scalar_t__*) ; \n scalar_t__ MP4GetTrackID (scalar_t__,scalar_t__*) ; \n scalar_t__ var7 ; \n scalar_t__ var8 ; \n scalar_t__ var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nint main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v7;\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  do {\n    printf(\"Inserisci numero della tabellina tra 2 e 10: \");\n    scanf(\"%d\", &v7);\n    v3 = v7;\n  } while ((unsigned int)(v7 - 2) > 8);\n  v4 = 1;\n  while (1) {\n    v5 = v4 * v3;\n    ++v4;\n    printf(\" %d\", v5);\n    if (v4 == 11) break;\n    v3 = v7;\n  }\n  return 0;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "main() {\n  int var1;\n  int var2;\n  int var3;\n  do {\n    printf(\"Inserisci numero della tabellina tra 2 e 10: \");\n    scanf(\"%d\", &var1);\n  } while ((var1 > 10) || (var1 < 2));\n  var2 = 1;\n  while (var2 <= 10) {\n    var3 = var1 * var2;\n    printf(\" %d\", var3);\n    var2++;\n  }\n}", "style": "rule"}, "extra_info": {"index": 84592, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n int /*<<< orphan*/  scanf (char*,int*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nuint64_t *stack_i_init(int a1) {\n  uint64_t *v1;\n  void *v2;\n  void *v4;\n  if (a1 < 0) {\n    print_error_msg(\"Error: stack_init: negative size!\");\n    return 0LL;\n  } else {\n    v1 = malloc(16uLL);\n    if (v1) {\n      v2 = calloc((unsigned int)(a1 + 1), 4uLL);\n      v1[1] = v2;\n      if (v2) {\n        *(uint32_t *)v1 = a1;\n        *((uint32_t *)v1 + 1) = -1;\n      } else {\n        print_error_msg(\"Error: stack_i_init: calloc() failed!\");\n        v4 = v1;\n        v1 = 0LL;\n        free(v4);\n      }\n    } else {\n      print_error_msg(\"Error: stack_i_init: malloc() failed!\");\n    }\n    return v1;\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "type1 *stack_i_init(int var1) {\n  if (var1 < 0) {\n    print_error_msg(\"Error: stack_init: negative size!\");\n    return NULL;\n  }\n  type1 *var2 = malloc(sizeof(var3));\n  if (var2 == NULL) {\n    print_error_msg(\"Error: stack_i_init: malloc() failed!\");\n    return NULL;\n  }\n  var2->field1 = calloc(var1 + 1, sizeof(int));\n  if (var2->field1 == NULL) {\n    print_error_msg(\"Error: stack_i_init: calloc() failed!\");\n    free(var2);\n    return NULL;\n  }\n  var2->field2 = var1;\n  var2->field3 = -1;\n  return var2;\n}", "style": "rule"}, "extra_info": {"index": 85893, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var3 ;\nstruct TYPE_5__ {int field2; int field3; int /*<<< orphan*/ * field1; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/ * calloc (int,int) ; \n int /*<<< orphan*/  free (TYPE_1__*) ; \n TYPE_1__* malloc (int) ; \n int /*<<< orphan*/  print_error_msg (char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long dbg_print_addr(int *a1) {\n  int v1;\n  int v2;\n  int v3;\n  long long v4;\n  int v5;\n  if (a1) {\n    v1 = *a1;\n    v2 = *a1 + 65535;\n    v3 = *a1 + 16777215;\n    if (*a1 >= 0) {\n      v2 = *a1;\n      v3 = *a1;\n    }\n    v4 = (unsigned char)(((unsigned int)(v2 >> 31) >> 24) + BYTE2(v2)) -\n         ((unsigned int)(v2 >> 31) >> 24);\n    v5 = v1 + 255;\n    if (v1 >= 0) v5 = *a1;\n    printf(\"%u.%u.%u.%u\\n\", (unsigned int)(v1 % 256),\n           (unsigned char)(((unsigned int)(v5 >> 31) >> 24) + BYTE1(v5)) -\n               ((unsigned int)(v5 >> 31) >> 24),\n           v4, (unsigned int)(v3 >> 24));\n    return 0LL;\n  } else {\n    puts(\"null addr\");\n    return 0LL;\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int dbg_print_addr(struct type1 *var1) {\n  type2 var2;\n  if (var1 == NULL) {\n    printf(\"null addr\\n\");\n    return 0;\n  }\n  var2 = var1->field1.field2;\n  printf(\"%u.%u.%u.%u\\n\", var2 % (256), var2 / 256 % 256,\n         var2 / 256 / 256 % 256, var2 / 256 / 256 / 256);\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 22258, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int type2 ;\nstruct TYPE_2__ {int field2; } ;\nstruct type1 {TYPE_1__ field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  printf (char*,...) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long search_symbol() {\n  int *v0;\n  long long v1;\n  uint64_t *v2;\n  int *v3;\n  long long v4;\n  unsigned int v5;\n  unsigned int v6;\n  long long v7;\n  unsigned int v8;\n  unsigned long long v10;\n  unsigned long long v11;\n  unsigned long long v12;\n  unsigned long long v13;\n  unsigned int v14;\n  unsigned int v15;\n  long long v16;\n  unsigned int v17;\n  unsigned int v18;\n  unsigned int v19;\n  char s[64];\n  char dest[72];\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  printf(\"\\t[ss] Symbol Name: \");\n  fgets(s, 64, (FILE *)(unsigned int)stdin);\n  putchar(10);\n  v0 = *(int **)(dsyms + 24);\n  if (v0) {\n    v10 = *(uint64_t *)(dsyms + 32);\n    v11 = *(uint64_t *)(dsyms + 40);\n    v12 = v10 / v11;\n    printf(\"\\t[ss] ==== %lu Dynamic Linked Symbols ====\\n\", v10 / v11);\n    if (v10 >= v11) {\n      v13 = 0LL;\n      do {\n        while (1) {\n          strncpy(dest, (const char *)(*(uint64_t *)dsyms + *v0), 64uLL);\n          v14 = strlen(s);\n          v15 = strlen(dest);\n          if ((int)Levenshtein(dest, v15, s, v14) <= 3) break;\n          ++v13;\n          v0 += 6;\n          if (v12 <= v13) goto LABEL_2;\n        }\n        v16 = (unsigned int)v0[4];\n        ++v13;\n        v0 += 6;\n        v19 = st_bind_lookup(v16);\n        v17 = st_type_lookup((unsigned int)*(v0 - 2));\n        printf(\"\\tName: %s Addr: 0x%016lx Section: %s Type: %s Bind: %s\\n\",\n               dest, (unsigned int)*(v0 - 1),\n               (const char *)*(unsigned int *)(SECTIONS +\n                                               4LL * *((uint64_t *)v0 - 2)),\n               (const char *)v17, (const char *)v19);\n      } while (v12 > v13);\n    }\n  }\nLABEL_2:\n  if (*(uint64_t *)(ssyms + 16)) {\n    v1 = *(uint32_t *)(ssyms + 24) / *(uint32_t *)(ssyms + 28);\n    printf(\"\\t[ss] ==== %lu Static  Linked Symbols ====\\n\", v1);\n    v2 = (uint64_t *)ssyms;\n    v3 = *(int **)(ssyms + 16);\n    if (v1) {\n      v4 = 0LL;\n      while (1) {\n        strncpy(dest, (const char *)(*v2 + *v3), 64uLL);\n        v5 = strlen(s);\n        v6 = strlen(dest);\n        if ((int)Levenshtein(dest, v6, s, v5) > 2) {\n          ++v4;\n          v3 += 6;\n          if (v1 == v4) return v22 - __readfsqword(40u);\n        } else {\n          v7 = (unsigned int)v3[4];\n          ++v4;\n          v3 += 6;\n          v18 = st_bind_lookup(v7);\n          v8 = st_type_lookup((unsigned int)*(v3 - 2));\n          printf(\"\\tName: %s Addr: 0x%016lx Section: %s Type: %s Bind: %s\\n\",\n                 dest, (unsigned int)*(v3 - 1),\n                 (const char *)*(unsigned int *)(SECTIONS +\n                                                 4LL * *((uint64_t *)v3 - 2)),\n                 (const char *)v8, (const char *)v18);\n          if (v1 == v4) return v22 - __readfsqword(40u);\n        }\n        v2 = (uint64_t *)ssyms;\n      }\n    }\n  } else {\n    puts(\"\\t[ss] No static symbols found, was the binary stripped?\");\n  }\n  return v22 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void search_symbol(void) {\n  char var1[64];\n  printf(\"\\t[ss] Symbol Name: \");\n  fgets(var1, 64, var2);\n  printf(\"\\n\");\n  if (var3[1].field1 != 0) {\n    uint64_t var4 = (var3[1].field2 / var3[1].field3);\n    type1* var5 = (type1*)var3[1].field1;\n    printf(\"\\t[ss] ==== %lu Dynamic Linked Symbols ====\\n\", var4);\n    int var6 = 0;\n    for (uint64_t var7 = 0; var7 < var4; var7++) {\n      char var8[64];\n      strncpy(var8, (((char*)var3[0].field1) + var5[var7].field4), 64);\n      if ((var6 = Levenshtein(var8, strlen(var8), var1, strlen(var1))) <= 3) {\n        printf(\"\\tName: %s Addr: 0x%016lx Section: %s Type: %s Bind: %s\\n\",\n               var8, var5[var7].field5, var9[var5[var7].field6].field7,\n               st_type_lookup(var5[var7].field8),\n               st_bind_lookup(var5[var7].field8));\n      }\n    }\n  }\n  if (var10[1].field1 != 0) {\n    uint64_t var4 = (var10[1].field2 / var10[1].field3);\n    printf(\"\\t[ss] ==== %lu Static  Linked Symbols ====\\n\", var4);\n    type1* var5 = (type1*)var10[1].field1;\n    int var6 = 0;\n    for (uint64_t var7 = 0; var7 < var4; var7++) {\n      char var8[64];\n      strncpy(var8, (((char*)var10[0].field1) + var5[var7].field4), 64);\n      if ((var6 = Levenshtein(var8, strlen(var8), var1, strlen(var1))) <= 2) {\n        printf(\"\\tName: %s Addr: 0x%016lx Section: %s Type: %s Bind: %s\\n\",\n               var8, var5[var7].field5, var9[var5[var7].field6].field7,\n               st_type_lookup(var5[var7].field8),\n               st_bind_lookup(var5[var7].field8));\n      }\n    }\n  } else {\n    printf(\"\\t[ss] No static symbols found, was the binary stripped?\\n\");\n  }\n}", "style": "rule"}, "extra_info": {"index": 33338, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  size_t uint64_t ;\nstruct TYPE_5__ {int field4; size_t field6; int /*<<< orphan*/  field8; int /*<<< orphan*/  field5; } ;\ntypedef  TYPE_1__ type1 ;\nstruct TYPE_8__ {scalar_t__ field1; int field2; int field3; } ;\nstruct TYPE_7__ {scalar_t__ field1; size_t field2; size_t field3; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  field7; } ;\n\n/* Variables and functions */\n int Levenshtein (char*,int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  fgets (char*,int,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  printf (char*,...) ; \n int /*<<< orphan*/  st_bind_lookup (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  st_type_lookup (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  strlen (char*) ; \n int /*<<< orphan*/  strncpy (char*,char*,int) ; \n TYPE_4__* var10 ; \n int /*<<< orphan*/  var2 ; \n TYPE_3__* var3 ; \n TYPE_2__* var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long Item_TextScroll_Paint(unsigned int *a1) {\n  unsigned int *v1;\n  double v2;\n  float v3;\n  double v4;\n  double v5;\n  double v6;\n  double v7;\n  long long result;\n  long long v9;\n  float v10;\n  float v11;\n  long long v12;\n  float v13;\n  long long v14;\n  float v15;\n  long long v16;\n  float v17;\n  float v18;\n  float v19;\n  float v20;\n  float v21;\n  float v22;\n  v1 = (unsigned int *)*((uint64_t *)a1 + 7);\n  v2 = *((double *)a1 + 2) + *((double *)a1 + 3) - 16.0 - 1.0;\n  v3 = COERCE_FLOAT(_mm_cvtsi128_si32((__m128i)*v1));\n  *(float *)&v2 = v2;\n  v18 = (float)(int)(a1[8] + 1);\n  v17 = *(float *)&v2;\n  (*(void (**)(uint64_t, double, float, double, double))(DC + 24))(\n      *(unsigned int *)(DC + 20), v2, v18, 16.0, 16.0);\n  v4 = *((double *)a1 + 5) - 32.0;\n  v1[1] = v1[2];\n  *(float *)&v4 = v4;\n  v22 = *(float *)&v4;\n  v19 = v18 + 15.0;\n  (*(void (**)(uint64_t, float, float, double, double))(DC + 24))(\n      *(unsigned int *)(DC + 16), v17, v19, 16.0, (float)(*(float *)&v4 + 1.0));\n  *(uint64_t *)&v5 = LODWORD(v22);\n  v20 = (float)(v22 - 1.0) + v19;\n  *(float *)&v5 = v20;\n  (*(void (**)(uint64_t, float, double, double, double))(DC + 24))(\n      *(unsigned int *)(DC + 12), v17, v5, 16.0, 16.0);\n  v6 = Item_TextScroll_ThumbDrawPosition(a1);\n  v7 = v20 - 16.0 - 1.0;\n  if (*(float *)&v6 > v7) {\n    HIDWORD(v6) = 0;\n    *(float *)&v6 = v7;\n  }\n  (*(void (**)(uint64_t, float, double, double, double))(DC + 24))(\n      *(unsigned int *)(DC + 8), v17, v6, 16.0, 16.0);\n  result = a1[8] + 1;\n  v9 = (int)v1[2];\n  v10 = (float)(int)result;\n  v11 = *((double *)a1 + 2) + 1.0;\n  v12 = 8 * v9;\n  v13 = *((double *)a1 + 5) - 2.0;\n  if (v3 > (float)(int)v1[2]) {\n    do {\n      result = *((uint64_t *)v1 + 2);\n      v14 = *(uint64_t *)(result + v12);\n      if (v14) {\n        v21 = v13;\n        (*(void (**)(uint64_t, uint64_t, long long, uint64_t, uint64_t,\n                     uint64_t, float, uint64_t))DC)(a1[12], a1[2], v14, 0LL,\n                                                    0LL, a1[1], v11 + 4.0, *a1);\n        v15 = *((float *)v1 + 6);\n        result = v16;\n        v13 = v13 - v15;\n        if (v15 > (float)(v21 - v15)) {\n          *((float *)v1 + 7) = v15 - v13;\n          return result;\n        }\n        ++v1[1];\n        v10 = v10 + v15;\n      }\n      LODWORD(v9) = v9 + 1;\n      v12 += 8LL;\n    } while (v3 > (float)(int)v9);\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void Item_TextScroll_Paint(type1 *var1) {\n  float var2, var3, var4, var5, var6;\n  int var7;\n  type2 *var8 = (type2 *)var1->field1;\n  var5 = var8->field2;\n  var2 = var1->field3.field4.field5 + var1->field3.field4.field6 - 16.0 - 1;\n  var3 = var1->field3.field4.field7 + 1;\n  var9->field8(var2, var3, 16.0, 16.0, var9->field9.field10);\n  var3 += 16.0 - 1;\n  var8->field11 = var8->field12;\n  var4 = var1->field3.field4.field13 - (16.0 * 2);\n  var9->field8(var2, var3, 16.0, var4 + 1, var9->field9.field14);\n  var3 += var4 - 1;\n  var9->field8(var2, var3, 16.0, 16.0, var9->field9.field15);\n  var6 = Item_TextScroll_ThumbDrawPosition(var1);\n  if (var6 > var3 - 16.0 - 1) {\n    var6 = var3 - 16.0 - 1;\n  }\n  var9->field8(var2, var6, 16.0, 16.0, var9->field9.field16);\n  var4 = var1->field3.field4.field13 - 2;\n  var2 = var1->field3.field4.field5 + 1;\n  var3 = var1->field3.field4.field7 + 1;\n  for (var7 = var8->field12; var7 < var5; var7++) {\n    const char *var10;\n    var10 = var8->field17[var7];\n    if (!var10) {\n      continue;\n    }\n    var9->field18(var2 + 4, var3, var1->field19, var1->field3.field20, var10, 0,\n                  0, var1->field21, var1->field22);\n    var4 -= var8->field23;\n    if (var4 < var8->field23) {\n      var8->field24 = var8->field23 - var4;\n      break;\n    }\n    var8->field11++;\n    var3 += var8->field23;\n  }\n}", "style": "rule"}, "extra_info": {"index": 86915, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_6__ ;\ntypedef  struct TYPE_13__   TYPE_5__ ;\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_12__ {float field2; int field11; int field12; char** field17; float field23; float field24; } ;\ntypedef  TYPE_4__ type2 ;\nstruct TYPE_10__ {double field5; double field6; int field7; double field13; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  field20; TYPE_2__ field4; } ;\nstruct TYPE_13__ {int /*<<< orphan*/  field22; int /*<<< orphan*/  field21; TYPE_3__ field3; int /*<<< orphan*/  field19; scalar_t__ field1; } ;\ntypedef  TYPE_5__ type1 ;\nstruct TYPE_9__ {int /*<<< orphan*/  field16; int /*<<< orphan*/  field15; int /*<<< orphan*/  field14; int /*<<< orphan*/  field10; } ;\nstruct TYPE_14__ {int /*<<< orphan*/  (* field18 ) (float,float,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;TYPE_1__ field9; int /*<<< orphan*/  (* field8 ) (float,float,double,double,int /*<<< orphan*/ ) ;} ;\n\n/* Variables and functions */\n float Item_TextScroll_ThumbDrawPosition (TYPE_5__*) ; \n int /*<<< orphan*/  stub1 (float,float,double,double,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stub2 (float,float,double,float,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stub3 (float,float,double,double,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stub4 (float,float,double,double,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  stub5 (float,float,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n TYPE_6__* var9 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long buttons_pressed() {\n  int i;\n  int j;\n  int k;\n  int v4;\n  v4 = 0;\n  for (i = 0; i <= 3; ++i)\n    buttonrow_input(*(uint64_t *)(button_matrix + 16LL * i + 8),\n                    *(unsigned int *)(button_matrix + 16LL * i));\n  for (j = 0; j <= 3; ++j) {\n    buttonrow_active(*(uint64_t *)(button_matrix + 16LL * j + 8),\n                     *(unsigned int *)(button_matrix + 16LL * j));\n    **(uint32_t **)(button_matrix + 16LL * j + 8) =\n        1 << *(uint32_t *)(button_matrix + 16LL * j);\n    for (k = 0; k <= 3; ++k) {\n      if (j != k) {\n        if (line_active(*(uint64_t *)(button_matrix + 16LL * k + 8),\n                        *(unsigned int *)(button_matrix + 16LL * k)))\n          v4 |= 1 << k << (4 * j);\n      }\n    }\n    buttonrow_input(*(uint64_t *)(button_matrix + 16LL * j + 8),\n                    *(unsigned int *)(button_matrix + 16LL * j));\n  }\n  if (v4 == 16388) return 55LL;\n  if (v4 <= 16388) {\n    if (v4 == 16384) return 56LL;\n    if (v4 <= 16384) {\n      if (v4 == 8704) return 53LL;\n      if (v4 <= 8704) {\n        if (v4 == 8194) return 52LL;\n        if (v4 <= 8194) {\n          if (v4 == 4352) return 50LL;\n          if (v4 <= 4352) {\n            if (v4 == 4096) return 49LL;\n            if (v4 <= 4096) {\n              if (v4 == 2176) return 35LL;\n              if (v4 <= 2176) {\n                if (v4 == 2048) return 48LL;\n                if (v4 <= 2048) {\n                  if (v4 == 512) return 54LL;\n                  if (v4 <= 512) {\n                    if (v4 == 272) return 51LL;\n                    if (v4 <= 272) {\n                      if (v4 == 136) return 99LL;\n                      if (v4 <= 136) {\n                        if (v4 == 68) return 109LL;\n                        if (v4 <= 68) {\n                          if (v4 == 64) return 57LL;\n                          if (v4 <= 64) {\n                            if (v4 == 16) return 117LL;\n                            if (v4 <= 16) {\n                              if (v4 == 2) return 100LL;\n                              if (v4 == 8) return 42LL;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static unsigned char func1(void) {\n  int var1, var2;\n  uint32_t var3 = 0;\n  for (var1 = 0; var1 < 4; var1++) {\n    buttonrow_input(var4[var1].field1, var4[var1].field2);\n  }\n  for (var1 = 0; var1 < 4; var1++) {\n    buttonrow_active(var4[var1].field1, var4[var1].field2);\n    ((type1*)var4[var1].field1)->field3 = 1 << var4[var1].field2;\n    for (var2 = 0; var2 < 4; var2++) {\n      if (var1 == var2) continue;\n      if (line_active(var4[var2].field1, var4[var2].field2)) {\n        var3 |= ((1 << var2) << (var1 * 4));\n      }\n    }\n    buttonrow_input(var4[var1].field1, var4[var1].field2);\n  }\n  switch (var3) {\n    case 0x0088:\n      return 'c';\n    case 0x0044:\n      return 'm';\n    case 0x0002:\n      return 'd';\n    case 0x0010:\n      return 'u';\n    case 0x1000:\n      return '1';\n    case 0x1100:\n      return '2';\n    case 0x0110:\n      return '3';\n    case 0x2002:\n      return '4';\n    case 0x2200:\n      return '5';\n    case 0x0200:\n      return '6';\n    case 0x4004:\n      return '7';\n    case 0x4000:\n      return '8';\n    case 0x0040:\n      return '9';\n    case 0x0008:\n      return '*';\n    case 0x0800:\n      return '0';\n    case 0x0880:\n      return '#';\n    default:\n      return 0;\n  }\n}", "style": "rule"}, "extra_info": {"index": 78231, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint32_t ;\nstruct TYPE_3__ {int field3; } ;\ntypedef  TYPE_1__ type1 ;\nstruct TYPE_4__ {int field2; scalar_t__ field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  buttonrow_active (scalar_t__,int) ; \n int /*<<< orphan*/  buttonrow_input (scalar_t__,int) ; \n scalar_t__ line_active (scalar_t__,int) ; \n TYPE_2__* var4 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long libevent_accept(int a1, short a2, long long a3) {\n  long long v3;\n  socklen_t addr_len;\n  struct sockaddr s;\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  memset(&s, 0, 4uLL);\n  addr_len = 4;\n  *(uint32_t *)&s.sa_data[2] = accept(a1, &s, &addr_len);\n  if (*(int *)&s.sa_data[2] < 0) goto LABEL_5;\n  *(uint64_t *)&s.sa_data[6] = calloc(1uLL, 4uLL);\n  if (!*(uint64_t *)&s.sa_data[6]) {\n    close(*(int *)&s.sa_data[2]);\n  LABEL_5:\n    warn(\"accept() failed\");\n    return v8 - __readfsqword(40u);\n  }\n  event_set(*(uint64_t *)&s.sa_data[6], *(unsigned int *)&s.sa_data[2],\n            EV_PERSIST | (unsigned int)EV_READ,\n            (unsigned int)libevent_readwrite, *(uint64_t *)&s.sa_data[6], v3,\n            a3, a2);\n  event_add(*(uint64_t *)&s.sa_data[6], 0LL);\n  return v8 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void func1(int var1, short var2, void *var3) {\n  struct type1 *var4;\n  type2 var5;\n  struct type3 var6;\n  int var7;\n  memset(&var6, 0, sizeof(var6));\n  var5 = sizeof(var6);\n  var7 = accept(var1, (struct type4 *)&var6, &var5);\n  if (var7 < 0) goto err;\n  var4 = calloc(1, sizeof(*var4));\n  if (var4 == NULL) goto err1;\n  event_set(&var4->field1, var7, var8 | var9, var10, var4);\n  event_add(&var4->field1, NULL);\n  return;\nerr1:\n  close(var7);\nerr:\n  warn(\"accept() failed\");\n}", "style": "rule"}, "extra_info": {"index": 24447, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var6 ;\ntypedef  int type2 ;\nstruct type4 {int dummy; } ;\nstruct type3 {int dummy; } ;\nstruct type1 {int /*<<< orphan*/  field1; } ;\n\n/* Variables and functions */\n int accept (int,struct type4*,int*) ; \n struct type1* calloc (int,int) ; \n int /*<<< orphan*/  close (int) ; \n int /*<<< orphan*/  event_add (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  event_set (int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ ,struct type1*) ; \n int /*<<< orphan*/  memset (struct type3*,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  var10 ; \n int var8 ; \n int var9 ; \n int /*<<< orphan*/  warn (char*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long daemonize(const char **argv) {\n  int v2;\n  int v3;\n  long long v4;\n  __pid_t v5;\n  unsigned int v6;\n  const char *v7;\n  int v8;\n  __pid_t v9;\n  bool v10;\n  const char *v11;\n  __pid_t v12;\n  __pid_t v14;\n  __pid_t v15;\n  int v16;\n  int v18;\n  int v19;\n  time_t timer;\n  uint8_t v21[4];\n  long long v22;\n  long long v23;\n  char s[24];\n  unsigned long long v25;\n  v25 = __readfsqword(40u);\n  if (!*(&args + 3)) {\n    if (!*(&args + 2)) goto LABEL_3;\n    goto LABEL_34;\n  }\n  if (getppid() == 1) return v25 - __readfsqword(40u);\n  v14 = fork();\n  if (v14 < 0) exit(1);\n  if (v14) exit(0);\n  setsid();\n  v15 = fork();\n  if (v15 < 0) exit(1);\n  if (v15) exit(0);\n  v16 = getdtablesize();\n  if (v16 >= 0) {\n    do close(v16);\n    while (v16-- != 0);\n  }\n  v18 = open(\"/dev/null\", O_RDWR);\n  v19 = v18;\n  if (v18 < 0) exit(1);\n  dup(v18);\n  dup(v19);\n  if (*(&args + 2))\n  LABEL_34:\n    chdir((const char *)*((unsigned int *)&args + 3));\nLABEL_3:\n  v2 = open((const char *)*((int *)&args + 2), O_CREAT | O_RDWR, 416LL);\n  v3 = v2;\n  if (v2 < 0) {\n    perror(\"lock: open\");\n    exit(1);\n  }\n  LODWORD(v4) = lockf(v2, F_TLOCK, 0LL);\n  if (v4 < 0) {\n    perror(\"lock: lockf\");\n    printf(\"Aquila is already running.\\n\");\n    exit(0);\n  }\n  v5 = getpid();\n  snprintf(s, 16uLL, \"%d\\n\", v5);\n  v6 = strlen(s);\n  write(v3, s, v6);\n  umask(23u);\n  if (args) {\n    v7 = *argv;\n    if (!**argv) v7 = \"/proc/self/exe\";\n    stat(v7, (struct stat *)&v22);\n    sigemptyset((sigset_t *)((char *)&timer + 4));\n    sigaddset((sigset_t *)((char *)&timer + 4), SIGCHLD);\n    sigprocmask(SIG_SETMASK, (const sigset_t *)((char *)&timer + 4),\n                (sigset_t *)v21);\n    time(&timer);\n  LABEL_9:\n    v8 = timer;\n    v9 = fork();\n    v10 = v9 == 0;\n    if (v9 < 0)\n    LABEL_18:\n      exit(1);\n    while (!v10) {\n      wait(0LL);\n      time(&timer);\n      if ((int)timer - v8 <= 2) sleep(3 - (timer - v8));\n      if (**argv) {\n        stat(*argv, (struct stat *)&v23);\n        if (v23 == v22) goto LABEL_9;\n      } else {\n        stat(\"/proc/self/exe\", (struct stat *)&v23);\n        if (v22 == v23) goto LABEL_9;\n      }\n      v11 = *argv;\n      if (!**argv) v11 = \"/proc/self/exe\";\n      execvp(v11, (char *const *)argv);\n      v8 = timer;\n      v12 = fork();\n      v10 = v12 == 0;\n      if (v12 < 0) goto LABEL_18;\n    }\n    sigprocmask(SIG_SETMASK, (const sigset_t *)v21, 0LL);\n  }\n  return v25 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void daemonize(char **var1) {\n  int var2, var3;\n  unsigned char var4[16];\n  if (var5.field1) {\n    if (getppid() == 1) return;\n    var2 = fork();\n    if (var2 < 0) exit(1);\n    if (var2 > 0) exit(0);\n    setsid();\n    var2 = fork();\n    if (var2 < 0) exit(1);\n    if (var2 > 0) exit(0);\n    for (var2 = getdtablesize(); var2 >= 0; --var2) close(var2);\n    var2 = open(\"/dev/null\", var6);\n    if (var2 < 0) exit(1);\n    dup(var2);\n    dup(var2);\n  }\n  if (var5.field2) chdir(var5.field3);\n  var3 = open(var5.field4, var6 | var7, 0640);\n  if (var3 < 0) {\n    perror(\"lock: open\");\n    exit(1);\n  }\n  if (lockf(var3, var8, 0) < 0) {\n    perror(\"lock: lockf\");\n    printf(\n        \"Aquila\"\n        \" is already running.\\n\");\n    exit(0);\n  }\n# 221 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/fleetcommand/aquila/refs/heads/master/src/main.c\"\n  snprintf(var4, 16, \"%d\\n\", getpid());\n  write(var3, var4, strlen(var4));\n  umask(027);\n  if (var5.field5) {\n    type1 var9, var10;\n    type2 var11, var12;\n    struct type3 var13, var14;\n    stat(*var1[0] ? var1[0] : \"/proc/self/exe\", &var13);\n    sigemptyset(&var11);\n    sigaddset(&var11, var15);\n    sigprocmask(var16, &var11, &var12);\n    time(&var10);\n    do {\n      var9 = var10;\n      var2 = fork();\n      if (var2 < 0) exit(1);\n      if (var2 == 0) break;\n      wait(NULL);\n      time(&var10);\n      if ((var10 - var9) < 3) sleep(3 - (var10 - var9));\n      stat(*var1[0] ? var1[0] : \"/proc/self/exe\", &var14);\n      if (var14.field6 != var13.field6)\n        execvp(*var1[0] ? var1[0] : \"/proc/self/exe\", var1);\n    } while (1);\n    sigprocmask(var16, &var12, NULL);\n  }\n}", "style": "rule"}, "extra_info": {"index": 85030, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type2 ;\ntypedef  int type1 ;\nstruct type3 {scalar_t__ field6; } ;\nstruct TYPE_2__ {scalar_t__ field5; int /*<<< orphan*/  field4; int /*<<< orphan*/  field3; scalar_t__ field2; scalar_t__ field1; } ;\n\n/* Variables and functions */\n int /*<<< orphan*/  chdir (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  close (int) ; \n int /*<<< orphan*/  dup (int) ; \n int /*<<< orphan*/  execvp (char*,char**) ; \n int /*<<< orphan*/  exit (int) ; \n int fork () ; \n int getdtablesize () ; \n int getpid () ; \n int getppid () ; \n scalar_t__ lockf (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; \n int open (char*,int,...) ; \n int /*<<< orphan*/  perror (char*) ; \n int /*<<< orphan*/  printf (char*) ; \n int /*<<< orphan*/  setsid () ; \n int /*<<< orphan*/  sigaddset (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  sigemptyset (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  sigprocmask (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  sleep (int) ; \n int /*<<< orphan*/  snprintf (unsigned char*,int,char*,int) ; \n int /*<<< orphan*/  stat (char*,struct type3*) ; \n int /*<<< orphan*/  strlen (unsigned char*) ; \n int /*<<< orphan*/  time (int*) ; \n int /*<<< orphan*/  umask (int) ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var16 ; \n TYPE_1__ var5 ; \n int var6 ; \n int var7 ; \n int /*<<< orphan*/  var8 ; \n int /*<<< orphan*/  wait (int /*<<< orphan*/ *) ; \n int /*<<< orphan*/  write (int,unsigned char*,int /*<<< orphan*/ ) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nunsigned long long retrieve_status(long long a1, long long a2, long long a3) {\n  long long result_buffer;\n  int v4;\n  long long v5;\n  unsigned int v6;\n  long long v7;\n  long long v8;\n  uint64_t *target;\n  long long v10;\n  char *v11;\n  long long v12;\n  void (*v13)(uint64_t, uint64_t, uint64_t, long long, long long);\n  void (***v15)(uint64_t, uint64_t, uint64_t, long long, long long);\n  int num_targets;\n  long long v17;\n  unsigned int v19;\n  unsigned int v20;\n  long long v21;\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  result_buffer = get_result_buffer(a2, a3, &v21);\n  v4 = STATUSTYPE_TABLE;\n  if ((DM_STATUS_TABLE_FLAG & *(uint32_t *)a2) == 0) v4 = STATUSTYPE_INFO;\n  v20 = v4;\n  num_targets = dm_table_get_num_targets(a1);\n  if (num_targets) {\n    v19 = 0;\n    v5 = result_buffer;\n    v6 = 0;\n    v17 = 0LL;\n    while (1) {\n      target = (uint64_t *)dm_table_get_target(a1, v6);\n      if ((unsigned long long)(v21 + result_buffer - v5) <= 24) break;\n      v10 = target[1];\n      v11 = (char *)*(unsigned int *)(v5 + 4);\n      *(uint64_t *)(v5 + 16) = 0LL;\n      *(uint64_t *)(v5 + 8) = v10;\n      v15 = (void (***)(uint64_t, uint64_t, uint64_t, long long,\n                        long long))target;\n      strncpy(v11, (const char *)*(unsigned int *)(*target + 8LL), 4uLL);\n      v12 = v21 + result_buffer - (v5 + 24);\n      if (!v12) break;\n      v13 = **v15;\n      if (v13) {\n        if ((DM_NOFLUSH_FLAG & *(uint32_t *)a2) != 0)\n          v19 |= DM_STATUS_NOFLUSH_FLAG;\n        v13(v15, v20, v19, v5 + 24, v12);\n      } else {\n        *(uint8_t *)(v5 + 24) = 0;\n      }\n      v7 = (int)(strlen((const char *)(v5 + 24)) + 1);\n      if (v12 == v7) break;\n      ++v6;\n      v17 = *(int *)(a2 + 4) + v5 + 24 + v7 - result_buffer;\n      v8 = align_ptr();\n      *(uint32_t *)v5 = v8 - result_buffer;\n      if (num_targets == v6) goto LABEL_16;\n      v5 = v8;\n    }\n    *(uint32_t *)a2 |= DM_BUFFER_FULL_FLAG;\n  LABEL_16:\n    if (v17) *(uint64_t *)(a2 + 8) = v17;\n  }\n  *(uint32_t *)(a2 + 16) = num_targets;\n  return v22 - __readfsqword(40u);\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "static void retrieve_status(struct type1 *var1, struct type2 *var2,\n                            size_t var3) {\n  unsigned int var4, var5;\n  struct type3 *var6;\n  char *var7, *var8;\n  type4 var9;\n  size_t var10, var11, var12 = 0;\n  unsigned var13 = 0;\n  var8 = var7 = get_result_buffer(var2, var3, &var11);\n  if (var2->field1 & var14)\n    var9 = var15;\n  else\n    var9 = var16;\n  var5 = dm_table_get_num_targets(var1);\n  for (var4 = 0; var4 < var5; var4++) {\n    struct type5 *var17 = dm_table_get_target(var1, var4);\n    size_t var18;\n    var10 = var11 - (var8 - var7);\n    if (var10 <= sizeof(struct type3)) {\n      var2->field1 |= var19;\n      break;\n    }\n    var6 = (struct type3 *)var8;\n    var6->field2 = 0;\n    var6->field3 = var17->field4;\n    var6->field5 = var17->field6;\n    strncpy(var6->field7, var17->field8->field9, sizeof(var6->field7));\n    var8 += sizeof(struct type3);\n    var10 = var11 - (var8 - var7);\n    if (var10 <= 0) {\n      var2->field1 |= var19;\n      break;\n    }\n    if (var17->field8->field2) {\n      if (var2->field1 & var20) var13 |= var21;\n      var17->field8->field2(var17, var9, var13, var8, var10);\n    } else\n      var8[0] = '\\0';\n    var18 = strlen(var8) + 1;\n    if (var18 == var10) {\n      var2->field1 |= var19;\n      break;\n    }\n    var8 += var18;\n    var12 = var2->field10 + (var8 - var7);\n    var8 = align_ptr(var8);\n    var6->field11 = var8 - var7;\n  }\n  if (var12) var2->field12 = var12;\n  var2->field13 = var5;\n}", "style": "rule"}, "extra_info": {"index": 88336, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  type4 ;\nstruct type5 {TYPE_1__* field8; int /*<<< orphan*/  field6; int /*<<< orphan*/  field4; } ;\nstruct type3 {int field11; int /*<<< orphan*/  field7; int /*<<< orphan*/  field5; int /*<<< orphan*/  field3; scalar_t__ field2; } ;\nstruct type2 {int field1; int field10; size_t field12; unsigned int field13; } ;\nstruct type1 {int dummy; } ;\nstruct TYPE_2__ {int /*<<< orphan*/  (* field2 ) (struct type5*,int /*<<< orphan*/ ,unsigned int,char*,size_t) ;int /*<<< orphan*/  field9; } ;\n\n/* Variables and functions */\n char* align_ptr (char*) ; \n unsigned int dm_table_get_num_targets (struct type1*) ; \n struct type5* dm_table_get_target (struct type1*,unsigned int) ; \n char* get_result_buffer (struct type2*,size_t,size_t*) ; \n int strlen (char*) ; \n int /*<<< orphan*/  strncpy (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; \n int /*<<< orphan*/  stub1 (struct type5*,int /*<<< orphan*/ ,unsigned int,char*,size_t) ; \n int var14 ; \n int /*<<< orphan*/  var15 ; \n int /*<<< orphan*/  var16 ; \n int var19 ; \n int var20 ; \n unsigned int var21 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long calc_log_lookup() {\n  long long result;\n  __m128i v1;\n  float v2;\n  int i;\n  unsigned int v4;\n  result = log_table_lookup;\n  *(uint32_t *)log_table_lookup = 63;\n  for (i = 1; i <= 255; ++i) {\n    v1 = 0LL;\n    *(float *)v1.m128i_i32 = (float)i / 255.0;\n    v2 = log10(*(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v1)).m128i_i64) *\n         -40.0;\n    if (v2 <= 63.0)\n      v4 = (int)v2;\n    else\n      v4 = 63;\n    result = v4;\n    *(uint32_t *)(4LL * i + log_table_lookup) = v4;\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void calc_log_lookup() {\n  int var1;\n  float var2;\n  uint8_t var3;\n  var4[0] = 63;\n  for (var1 = 1; var1 < 256; ++var1) {\n    var2 = -40.0 * log10((float)var1 / 255.0);\n    if (var2 > 63.0) {\n      var3 = 63;\n    } else {\n      var3 = (uint8_t)var2;\n    }\n    var4[var1] = var3;\n  }\n}", "style": "rule"}, "extra_info": {"index": 44407, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint8_t ;\n\n/* Variables and functions */\n double log10 (float) ; \n int* var4 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long goldbach_number(int a1) {\n  int i;\n  for (i = 1; i < a1; ++i) {\n    if (is_prime((unsigned int)i) && is_prime((unsigned int)(a1 - i)))\n      return 1LL;\n  }\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int goldbach_number(int var1) {\n  int var2;\n  for (var2 = 1; var2 < var1; ++var2) {\n    if (is_prime(var2) && is_prime(var1 - var2)) {\n      return 1;\n    }\n  }\n  return 0;\n}", "style": "rule"}, "extra_info": {"index": 89865, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n scalar_t__ is_prime (int) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid chunk_free(uint64_t *a1) {\n  void *ptr;\n  while (a1) {\n    ptr = a1;\n    a1 = (uint64_t *)*a1;\n    free(ptr);\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void chunk_free(type1* var1) {\n  while (var1 != NULL) {\n    type1* var2 = var1;\n    var1 = var1->field1;\n    free(var2);\n  }\n}", "style": "rule"}, "extra_info": {"index": 31390, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {struct TYPE_4__* field1; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  free (TYPE_1__*) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long draw_box_caption(uint32_t *a1, int a2, uint64_t *a3) {\n  unsigned int v3;\n  uint8_t *v4;\n  uint64_t *v5;\n  long long result;\n  signed int v8;\n  unsigned int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  uint8_t *v14;\n  v10 = *a1 + a2;\n  v11 = a1[2] - a2;\n  v12 = a1[3] - a2;\n  v8 = v10;\n  v9 = a1[1] + a2;\nLABEL_13:\n  v5 = a3++;\n  v14 = (uint8_t *)*v5;\n  if (*v5) {\n    while (1) {\n      while (1) {\n        v4 = v14++;\n        v13 = (char)*v4;\n        if (!*v4) goto LABEL_13;\n        if (v8 == v10) break;\n      LABEL_5:\n        putchar((char)v13);\n        ++v8;\n        if (v13 == 32 && v11 - v8 - 1 <= (int)next_word(v14)) {\n          while (v8 < v11) {\n            putchar(32);\n            ++v8;\n          }\n        }\n        if (v8 >= v11) {\n          putchar(32);\n          v8 = v10;\n          ++v9;\n        }\n      }\n      if (v13 != 32) {\n        v3 = v8++;\n        cup(v9, v3);\n        putchar(32);\n        goto LABEL_5;\n      }\n    }\n  }\n  while (1) {\n    result = v9;\n    if ((int)v9 > v12) break;\n    if (v8 == v10) cup(v9, (unsigned int)v8);\n    putchar(32);\n    if (++v8 >= v11) {\n      putchar(32);\n      v8 = v10;\n      ++v9;\n    }\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void draw_box_caption(type1 *var1, int var2, const char **var3) {\n  int var4 = (var1->field1 + var2);\n  int var5 = (var1->field2 + var2);\n  int var6 = (var1->field3 - var2);\n  int var7 = (var1->field4 - var2);\n  int var8 = var4;\n  int var9 = var5;\n  int var10;\n  const char *var11;\n  while ((var11 = *var3++) != 0) {\n    while ((var10 = *var11++) != 0) {\n      if (var8 == var4) {\n        if (var10 == ' ') continue;\n        cup(var9, var8++);\n        putchar(' ');\n      }\n      putchar(var10);\n      var8++;\n      if ((var10 == ' ') && (next_word(var11) > (var6 - var8 - 2))) {\n        while (var8 < var6) {\n          putchar(' ');\n          var8++;\n        }\n      }\n      if (var8 >= var6) {\n        putchar(' ');\n        var8 = var4;\n        var9++;\n      }\n    }\n  }\n  while (var9 <= var7) {\n    if (var8 == var4) {\n      cup(var9, var8);\n    }\n    putchar(' ');\n    if (++var8 >= var6) {\n      putchar(' ');\n      var8 = var4;\n      var9++;\n    }\n  }\n}", "style": "rule"}, "extra_info": {"index": 10617, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int field1; int field2; int field3; int field4; } ;\ntypedef  TYPE_1__ type1 ;\n\n/* Variables and functions */\n int /*<<< orphan*/  cup (int,int) ; \n int next_word (char const*) ; \n int /*<<< orphan*/  putchar (char) ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long kmod_elf_strip_vermagic(long long a1) {\n  long long v2;\n  int v3;\n  int i;\n  int section;\n  uint8_t *v6;\n  uint8_t *v7;\n  char *s1;\n  unsigned int n;\n  long long v10;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  section = kmod_elf_get_section(a1, \".modinfo\", &v6, &v3);\n  if (section < 0) return (unsigned int)section;\n  v7 = v6;\n  if (!v6 || !v3) return 0LL;\n  while (!*v7 && v3 > 1) {\n    ++v7;\n    --v3;\n  }\n  if (v3 <= 1) return 0LL;\n  for (i = 0;; ++i) {\n    if (i >= v3) return (unsigned int)-ENOENT;\n    if (v7[i]) {\n      if (i + 1 < v3) {\n        s1 = &v7[i];\n        n = 9LL;\n        if (i + 9LL < (unsigned long long)v3) break;\n      }\n    }\n  LABEL_22:;\n  }\n  LODWORD(v2) = strncmp(s1, \"vermagic=\", n);\n  if (v2) {\n    i += strlen(s1);\n    goto LABEL_22;\n  }\n  s1 += n;\n  v10 = (long long)&s1[-*(uint64_t *)(a1 + 8)] >> 2;\n  if (!*(uint64_t *)a1) {\n    *(uint64_t *)a1 = malloc(*(unsigned int *)(a1 + 16));\n    if (!*(uint64_t *)a1) return (unsigned int)-errno;\n    memcpy(*(void **)a1, *(const void **)(a1 + 8), *(unsigned int *)(a1 + 16));\n    *(uint64_t *)(a1 + 8) = *(uint64_t *)a1;\n  }\n  n = (int)strlen(s1);\n  memset((void *)(*(uint64_t *)a1 + 4 * v10), 0, n);\n  return 0LL;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int kmod_elf_strip_vermagic(struct type1 *var1) {\n  uint64_t var2, var3;\n  const void *var4;\n  const char *var5;\n  int var6;\n  var6 = kmod_elf_get_section(var1, \".modinfo\", &var4, &var3);\n  if (var6 < 0) return var6;\n  var5 = var4;\n  if (var5 == NULL || var3 == 0) return 0;\n  while (var5[0] == '\\0' && var3 > 1) {\n    var5++;\n    var3--;\n  }\n  if (var3 <= 1) return 0;\n  for (var2 = 0; var2 < var3; var2++) {\n    const char *var7;\n    size_t var8, var9;\n    if (var5[var2] == '\\0') continue;\n    if (var2 + 1 >= var3) continue;\n    var7 = var5 + var2;\n    var9 = sizeof(\"vermagic=\") - 1;\n    if (var2 + var9 >= var3) continue;\n    if (strncmp(var7, \"vermagic=\", var9) != 0) {\n      var2 += strlen(var7);\n      continue;\n    }\n    var7 += var9;\n    var8 = (const uint8_t *)var7 - var1->field1;\n    if (var1->field2 == NULL) {\n      var1->field2 = malloc(var1->field3);\n      if (var1->field2 == NULL) return -var10;\n      memcpy(var1->field2, var1->field1, var1->field3);\n      var1->field1 = var1->field2;\n      ;\n    }\n    var9 = strlen(var7);\n    ;\n    memset(var1->field2 + var8, '\\0', var9);\n    return 0;\n  };\n  return -var11;\n}", "style": "rule"}, "extra_info": {"index": 74285, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  int uint64_t ;\nstruct type1 {int /*<<< orphan*/  const* field2; int /*<<< orphan*/  const* field1; int /*<<< orphan*/  field3; } ;\n\n/* Variables and functions */\n int kmod_elf_get_section (struct type1*,char*,void const**,int*) ; \n int /*<<< orphan*/  const* malloc (int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  memcpy (int /*<<< orphan*/  const*,int /*<<< orphan*/  const*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  memset (int /*<<< orphan*/  const*,char,size_t) ; \n int strlen (char const*) ; \n scalar_t__ strncmp (char const*,char*,size_t) ; \n int var10 ; \n int var11 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nvoid *xrealloc(void *a1, unsigned int a2) {\n  void *result;\n  result = realloc(a1, a2);\n  if (!result) {\n    fprintf((FILE *)(unsigned int)stderr, \"Error: could not allocate memory\");\n    printf(\"Error: could not allocate memory\");\n    exit(-1);\n  }\n  return result;\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "void *xrealloc(void *var1, size_t var2) {\n  void *var3 = realloc(var1, var2);\n  if (var3 != NULL) {\n    return var3;\n  } else {\n    fprintf(var4, \"Error: could not allocate memory\");\n    printf(\"Error: could not allocate memory\");\n    exit(-1);\n  }\n}", "style": "rule"}, "extra_info": {"index": 91491, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  exit (int) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ; \n int /*<<< orphan*/  printf (char*) ; \n void* realloc (void*,size_t) ; \n int /*<<< orphan*/  var4 ; \n\n"}}
{"data_source": "llm4decompile_exe", "prompt": [{"content": "# This is the assembly code:\nlong long GPIOWrite(int a1, int a2) {\n  int fd;\n  char s[40];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  snprintf(s, 30uLL, \"/sys/class/gpio/gpio%d/value\", a1);\n  fd = open(s, O_WRONLY);\n  if (fd == -1) {\n    fprintf((FILE *)(unsigned int)stderr,\n            \"Failed to open gpio value %s for writing!\\n\", s);\n    perror(\"open\");\n    return 4294967295LL;\n  } else if ((unsigned int)write(fd, &s_values_str_0[a2 != 0], 1uLL) == 1) {\n    close(fd);\n    return 0LL;\n  } else {\n    fprintf((FILE *)(unsigned int)stderr, \"Failed to write value on %s!\\n\", s);\n    perror(\"write\");\n    return 4294967295LL;\n  }\n}\n# What is the source code?\n", "role": "user"}], "ability": "decompile", "reward_model": {"ground_truth": "int GPIOWrite(int var1, int var2) {\n  static const char var3[] = \"01\";\n  char var4[30];\n  int var5;\n  snprintf(var4, 30, \"/sys/class/gpio/gpio%d/value\", var1);\n  var5 = open(var4, var6);\n  if (-1 == var5) {\n    fprintf(var7, \"Failed to open gpio value %s for writing!\\n\", var4);\n    perror(\"open\");\n    return (-1);\n  }\n  if (1 != write(var5, &var3[0 == var2 ? 0 : 1], 1)) {\n    fprintf(var7, \"Failed to write value on %s!\\n\", var4);\n    perror(\"write\");\n    return (-1);\n  }\n  close(var5);\n  return (0);\n}", "style": "rule"}, "extra_info": {"index": 1641, "split": "train", "header": "#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n int /*<<< orphan*/  close (int) ; \n int /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ; \n int open (char*,int /*<<< orphan*/ ) ; \n int /*<<< orphan*/  perror (char*) ; \n int /*<<< orphan*/  snprintf (char*,int,char*,int) ; \n int /*<<< orphan*/  var6 ; \n int /*<<< orphan*/  var7 ; \n int write (int,char const*,int) ; \n\n"}}
